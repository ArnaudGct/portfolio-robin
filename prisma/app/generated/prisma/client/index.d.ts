
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model account
 * 
 */
export type account = $Result.DefaultSelection<Prisma.$accountPayload>
/**
 * Model accueil_general
 * 
 */
export type accueil_general = $Result.DefaultSelection<Prisma.$accueil_generalPayload>
/**
 * Model apropos_etudes
 * 
 */
export type apropos_etudes = $Result.DefaultSelection<Prisma.$apropos_etudesPayload>
/**
 * Model apropos_experiences
 * 
 */
export type apropos_experiences = $Result.DefaultSelection<Prisma.$apropos_experiencesPayload>
/**
 * Model apropos_general
 * 
 */
export type apropos_general = $Result.DefaultSelection<Prisma.$apropos_generalPayload>
/**
 * Model apropos_outils
 * 
 */
export type apropos_outils = $Result.DefaultSelection<Prisma.$apropos_outilsPayload>
/**
 * Model photos
 * 
 */
export type photos = $Result.DefaultSelection<Prisma.$photosPayload>
/**
 * Model photos_albums
 * 
 */
export type photos_albums = $Result.DefaultSelection<Prisma.$photos_albumsPayload>
/**
 * Model photos_albums_link
 * 
 */
export type photos_albums_link = $Result.DefaultSelection<Prisma.$photos_albums_linkPayload>
/**
 * Model photos_albums_tags_link
 * 
 */
export type photos_albums_tags_link = $Result.DefaultSelection<Prisma.$photos_albums_tags_linkPayload>
/**
 * Model photos_tags
 * 
 */
export type photos_tags = $Result.DefaultSelection<Prisma.$photos_tagsPayload>
/**
 * Model photos_tags_link
 * 
 */
export type photos_tags_link = $Result.DefaultSelection<Prisma.$photos_tags_linkPayload>
/**
 * Model photos_tags_recherche
 * 
 */
export type photos_tags_recherche = $Result.DefaultSelection<Prisma.$photos_tags_recherchePayload>
/**
 * Model photos_tags_recherche_link
 * 
 */
export type photos_tags_recherche_link = $Result.DefaultSelection<Prisma.$photos_tags_recherche_linkPayload>
/**
 * Model session
 * 
 */
export type session = $Result.DefaultSelection<Prisma.$sessionPayload>
/**
 * Model user
 * 
 */
export type user = $Result.DefaultSelection<Prisma.$userPayload>
/**
 * Model utilisateurs
 * 
 */
export type utilisateurs = $Result.DefaultSelection<Prisma.$utilisateursPayload>
/**
 * Model verification
 * 
 */
export type verification = $Result.DefaultSelection<Prisma.$verificationPayload>
/**
 * Model videos
 * 
 */
export type videos = $Result.DefaultSelection<Prisma.$videosPayload>
/**
 * Model videos_tags
 * 
 */
export type videos_tags = $Result.DefaultSelection<Prisma.$videos_tagsPayload>
/**
 * Model videos_tags_link
 * 
 */
export type videos_tags_link = $Result.DefaultSelection<Prisma.$videos_tags_linkPayload>
/**
 * Model accueil_clients
 * 
 */
export type accueil_clients = $Result.DefaultSelection<Prisma.$accueil_clientsPayload>
/**
 * Model accueil_faq
 * 
 */
export type accueil_faq = $Result.DefaultSelection<Prisma.$accueil_faqPayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Accounts
 * const accounts = await prisma.account.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Accounts
   * const accounts = await prisma.account.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.account`: Exposes CRUD operations for the **account** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accounts
    * const accounts = await prisma.account.findMany()
    * ```
    */
  get account(): Prisma.accountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.accueil_general`: Exposes CRUD operations for the **accueil_general** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accueil_generals
    * const accueil_generals = await prisma.accueil_general.findMany()
    * ```
    */
  get accueil_general(): Prisma.accueil_generalDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.apropos_etudes`: Exposes CRUD operations for the **apropos_etudes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Apropos_etudes
    * const apropos_etudes = await prisma.apropos_etudes.findMany()
    * ```
    */
  get apropos_etudes(): Prisma.apropos_etudesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.apropos_experiences`: Exposes CRUD operations for the **apropos_experiences** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Apropos_experiences
    * const apropos_experiences = await prisma.apropos_experiences.findMany()
    * ```
    */
  get apropos_experiences(): Prisma.apropos_experiencesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.apropos_general`: Exposes CRUD operations for the **apropos_general** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Apropos_generals
    * const apropos_generals = await prisma.apropos_general.findMany()
    * ```
    */
  get apropos_general(): Prisma.apropos_generalDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.apropos_outils`: Exposes CRUD operations for the **apropos_outils** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Apropos_outils
    * const apropos_outils = await prisma.apropos_outils.findMany()
    * ```
    */
  get apropos_outils(): Prisma.apropos_outilsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.photos`: Exposes CRUD operations for the **photos** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Photos
    * const photos = await prisma.photos.findMany()
    * ```
    */
  get photos(): Prisma.photosDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.photos_albums`: Exposes CRUD operations for the **photos_albums** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Photos_albums
    * const photos_albums = await prisma.photos_albums.findMany()
    * ```
    */
  get photos_albums(): Prisma.photos_albumsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.photos_albums_link`: Exposes CRUD operations for the **photos_albums_link** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Photos_albums_links
    * const photos_albums_links = await prisma.photos_albums_link.findMany()
    * ```
    */
  get photos_albums_link(): Prisma.photos_albums_linkDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.photos_albums_tags_link`: Exposes CRUD operations for the **photos_albums_tags_link** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Photos_albums_tags_links
    * const photos_albums_tags_links = await prisma.photos_albums_tags_link.findMany()
    * ```
    */
  get photos_albums_tags_link(): Prisma.photos_albums_tags_linkDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.photos_tags`: Exposes CRUD operations for the **photos_tags** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Photos_tags
    * const photos_tags = await prisma.photos_tags.findMany()
    * ```
    */
  get photos_tags(): Prisma.photos_tagsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.photos_tags_link`: Exposes CRUD operations for the **photos_tags_link** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Photos_tags_links
    * const photos_tags_links = await prisma.photos_tags_link.findMany()
    * ```
    */
  get photos_tags_link(): Prisma.photos_tags_linkDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.photos_tags_recherche`: Exposes CRUD operations for the **photos_tags_recherche** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Photos_tags_recherches
    * const photos_tags_recherches = await prisma.photos_tags_recherche.findMany()
    * ```
    */
  get photos_tags_recherche(): Prisma.photos_tags_rechercheDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.photos_tags_recherche_link`: Exposes CRUD operations for the **photos_tags_recherche_link** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Photos_tags_recherche_links
    * const photos_tags_recherche_links = await prisma.photos_tags_recherche_link.findMany()
    * ```
    */
  get photos_tags_recherche_link(): Prisma.photos_tags_recherche_linkDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.sessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **user** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.userDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.utilisateurs`: Exposes CRUD operations for the **utilisateurs** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Utilisateurs
    * const utilisateurs = await prisma.utilisateurs.findMany()
    * ```
    */
  get utilisateurs(): Prisma.utilisateursDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.verification`: Exposes CRUD operations for the **verification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Verifications
    * const verifications = await prisma.verification.findMany()
    * ```
    */
  get verification(): Prisma.verificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.videos`: Exposes CRUD operations for the **videos** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Videos
    * const videos = await prisma.videos.findMany()
    * ```
    */
  get videos(): Prisma.videosDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.videos_tags`: Exposes CRUD operations for the **videos_tags** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Videos_tags
    * const videos_tags = await prisma.videos_tags.findMany()
    * ```
    */
  get videos_tags(): Prisma.videos_tagsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.videos_tags_link`: Exposes CRUD operations for the **videos_tags_link** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Videos_tags_links
    * const videos_tags_links = await prisma.videos_tags_link.findMany()
    * ```
    */
  get videos_tags_link(): Prisma.videos_tags_linkDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.accueil_clients`: Exposes CRUD operations for the **accueil_clients** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accueil_clients
    * const accueil_clients = await prisma.accueil_clients.findMany()
    * ```
    */
  get accueil_clients(): Prisma.accueil_clientsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.accueil_faq`: Exposes CRUD operations for the **accueil_faq** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accueil_faqs
    * const accueil_faqs = await prisma.accueil_faq.findMany()
    * ```
    */
  get accueil_faq(): Prisma.accueil_faqDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.19.0
   * Query Engine version: 2ba551f319ab1df4bc874a89965d8b3641056773
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    account: 'account',
    accueil_general: 'accueil_general',
    apropos_etudes: 'apropos_etudes',
    apropos_experiences: 'apropos_experiences',
    apropos_general: 'apropos_general',
    apropos_outils: 'apropos_outils',
    photos: 'photos',
    photos_albums: 'photos_albums',
    photos_albums_link: 'photos_albums_link',
    photos_albums_tags_link: 'photos_albums_tags_link',
    photos_tags: 'photos_tags',
    photos_tags_link: 'photos_tags_link',
    photos_tags_recherche: 'photos_tags_recherche',
    photos_tags_recherche_link: 'photos_tags_recherche_link',
    session: 'session',
    user: 'user',
    utilisateurs: 'utilisateurs',
    verification: 'verification',
    videos: 'videos',
    videos_tags: 'videos_tags',
    videos_tags_link: 'videos_tags_link',
    accueil_clients: 'accueil_clients',
    accueil_faq: 'accueil_faq'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "account" | "accueil_general" | "apropos_etudes" | "apropos_experiences" | "apropos_general" | "apropos_outils" | "photos" | "photos_albums" | "photos_albums_link" | "photos_albums_tags_link" | "photos_tags" | "photos_tags_link" | "photos_tags_recherche" | "photos_tags_recherche_link" | "session" | "user" | "utilisateurs" | "verification" | "videos" | "videos_tags" | "videos_tags_link" | "accueil_clients" | "accueil_faq"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      account: {
        payload: Prisma.$accountPayload<ExtArgs>
        fields: Prisma.accountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.accountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$accountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.accountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$accountPayload>
          }
          findFirst: {
            args: Prisma.accountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$accountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.accountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$accountPayload>
          }
          findMany: {
            args: Prisma.accountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$accountPayload>[]
          }
          create: {
            args: Prisma.accountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$accountPayload>
          }
          createMany: {
            args: Prisma.accountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.accountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$accountPayload>
          }
          update: {
            args: Prisma.accountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$accountPayload>
          }
          deleteMany: {
            args: Prisma.accountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.accountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.accountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$accountPayload>
          }
          aggregate: {
            args: Prisma.AccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccount>
          }
          groupBy: {
            args: Prisma.accountGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.accountCountArgs<ExtArgs>
            result: $Utils.Optional<AccountCountAggregateOutputType> | number
          }
        }
      }
      accueil_general: {
        payload: Prisma.$accueil_generalPayload<ExtArgs>
        fields: Prisma.accueil_generalFieldRefs
        operations: {
          findUnique: {
            args: Prisma.accueil_generalFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$accueil_generalPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.accueil_generalFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$accueil_generalPayload>
          }
          findFirst: {
            args: Prisma.accueil_generalFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$accueil_generalPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.accueil_generalFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$accueil_generalPayload>
          }
          findMany: {
            args: Prisma.accueil_generalFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$accueil_generalPayload>[]
          }
          create: {
            args: Prisma.accueil_generalCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$accueil_generalPayload>
          }
          createMany: {
            args: Prisma.accueil_generalCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.accueil_generalDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$accueil_generalPayload>
          }
          update: {
            args: Prisma.accueil_generalUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$accueil_generalPayload>
          }
          deleteMany: {
            args: Prisma.accueil_generalDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.accueil_generalUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.accueil_generalUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$accueil_generalPayload>
          }
          aggregate: {
            args: Prisma.Accueil_generalAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccueil_general>
          }
          groupBy: {
            args: Prisma.accueil_generalGroupByArgs<ExtArgs>
            result: $Utils.Optional<Accueil_generalGroupByOutputType>[]
          }
          count: {
            args: Prisma.accueil_generalCountArgs<ExtArgs>
            result: $Utils.Optional<Accueil_generalCountAggregateOutputType> | number
          }
        }
      }
      apropos_etudes: {
        payload: Prisma.$apropos_etudesPayload<ExtArgs>
        fields: Prisma.apropos_etudesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.apropos_etudesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$apropos_etudesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.apropos_etudesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$apropos_etudesPayload>
          }
          findFirst: {
            args: Prisma.apropos_etudesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$apropos_etudesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.apropos_etudesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$apropos_etudesPayload>
          }
          findMany: {
            args: Prisma.apropos_etudesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$apropos_etudesPayload>[]
          }
          create: {
            args: Prisma.apropos_etudesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$apropos_etudesPayload>
          }
          createMany: {
            args: Prisma.apropos_etudesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.apropos_etudesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$apropos_etudesPayload>
          }
          update: {
            args: Prisma.apropos_etudesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$apropos_etudesPayload>
          }
          deleteMany: {
            args: Prisma.apropos_etudesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.apropos_etudesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.apropos_etudesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$apropos_etudesPayload>
          }
          aggregate: {
            args: Prisma.Apropos_etudesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateApropos_etudes>
          }
          groupBy: {
            args: Prisma.apropos_etudesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Apropos_etudesGroupByOutputType>[]
          }
          count: {
            args: Prisma.apropos_etudesCountArgs<ExtArgs>
            result: $Utils.Optional<Apropos_etudesCountAggregateOutputType> | number
          }
        }
      }
      apropos_experiences: {
        payload: Prisma.$apropos_experiencesPayload<ExtArgs>
        fields: Prisma.apropos_experiencesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.apropos_experiencesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$apropos_experiencesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.apropos_experiencesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$apropos_experiencesPayload>
          }
          findFirst: {
            args: Prisma.apropos_experiencesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$apropos_experiencesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.apropos_experiencesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$apropos_experiencesPayload>
          }
          findMany: {
            args: Prisma.apropos_experiencesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$apropos_experiencesPayload>[]
          }
          create: {
            args: Prisma.apropos_experiencesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$apropos_experiencesPayload>
          }
          createMany: {
            args: Prisma.apropos_experiencesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.apropos_experiencesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$apropos_experiencesPayload>
          }
          update: {
            args: Prisma.apropos_experiencesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$apropos_experiencesPayload>
          }
          deleteMany: {
            args: Prisma.apropos_experiencesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.apropos_experiencesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.apropos_experiencesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$apropos_experiencesPayload>
          }
          aggregate: {
            args: Prisma.Apropos_experiencesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateApropos_experiences>
          }
          groupBy: {
            args: Prisma.apropos_experiencesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Apropos_experiencesGroupByOutputType>[]
          }
          count: {
            args: Prisma.apropos_experiencesCountArgs<ExtArgs>
            result: $Utils.Optional<Apropos_experiencesCountAggregateOutputType> | number
          }
        }
      }
      apropos_general: {
        payload: Prisma.$apropos_generalPayload<ExtArgs>
        fields: Prisma.apropos_generalFieldRefs
        operations: {
          findUnique: {
            args: Prisma.apropos_generalFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$apropos_generalPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.apropos_generalFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$apropos_generalPayload>
          }
          findFirst: {
            args: Prisma.apropos_generalFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$apropos_generalPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.apropos_generalFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$apropos_generalPayload>
          }
          findMany: {
            args: Prisma.apropos_generalFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$apropos_generalPayload>[]
          }
          create: {
            args: Prisma.apropos_generalCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$apropos_generalPayload>
          }
          createMany: {
            args: Prisma.apropos_generalCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.apropos_generalDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$apropos_generalPayload>
          }
          update: {
            args: Prisma.apropos_generalUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$apropos_generalPayload>
          }
          deleteMany: {
            args: Prisma.apropos_generalDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.apropos_generalUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.apropos_generalUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$apropos_generalPayload>
          }
          aggregate: {
            args: Prisma.Apropos_generalAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateApropos_general>
          }
          groupBy: {
            args: Prisma.apropos_generalGroupByArgs<ExtArgs>
            result: $Utils.Optional<Apropos_generalGroupByOutputType>[]
          }
          count: {
            args: Prisma.apropos_generalCountArgs<ExtArgs>
            result: $Utils.Optional<Apropos_generalCountAggregateOutputType> | number
          }
        }
      }
      apropos_outils: {
        payload: Prisma.$apropos_outilsPayload<ExtArgs>
        fields: Prisma.apropos_outilsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.apropos_outilsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$apropos_outilsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.apropos_outilsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$apropos_outilsPayload>
          }
          findFirst: {
            args: Prisma.apropos_outilsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$apropos_outilsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.apropos_outilsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$apropos_outilsPayload>
          }
          findMany: {
            args: Prisma.apropos_outilsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$apropos_outilsPayload>[]
          }
          create: {
            args: Prisma.apropos_outilsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$apropos_outilsPayload>
          }
          createMany: {
            args: Prisma.apropos_outilsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.apropos_outilsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$apropos_outilsPayload>
          }
          update: {
            args: Prisma.apropos_outilsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$apropos_outilsPayload>
          }
          deleteMany: {
            args: Prisma.apropos_outilsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.apropos_outilsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.apropos_outilsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$apropos_outilsPayload>
          }
          aggregate: {
            args: Prisma.Apropos_outilsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateApropos_outils>
          }
          groupBy: {
            args: Prisma.apropos_outilsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Apropos_outilsGroupByOutputType>[]
          }
          count: {
            args: Prisma.apropos_outilsCountArgs<ExtArgs>
            result: $Utils.Optional<Apropos_outilsCountAggregateOutputType> | number
          }
        }
      }
      photos: {
        payload: Prisma.$photosPayload<ExtArgs>
        fields: Prisma.photosFieldRefs
        operations: {
          findUnique: {
            args: Prisma.photosFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$photosPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.photosFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$photosPayload>
          }
          findFirst: {
            args: Prisma.photosFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$photosPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.photosFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$photosPayload>
          }
          findMany: {
            args: Prisma.photosFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$photosPayload>[]
          }
          create: {
            args: Prisma.photosCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$photosPayload>
          }
          createMany: {
            args: Prisma.photosCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.photosDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$photosPayload>
          }
          update: {
            args: Prisma.photosUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$photosPayload>
          }
          deleteMany: {
            args: Prisma.photosDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.photosUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.photosUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$photosPayload>
          }
          aggregate: {
            args: Prisma.PhotosAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePhotos>
          }
          groupBy: {
            args: Prisma.photosGroupByArgs<ExtArgs>
            result: $Utils.Optional<PhotosGroupByOutputType>[]
          }
          count: {
            args: Prisma.photosCountArgs<ExtArgs>
            result: $Utils.Optional<PhotosCountAggregateOutputType> | number
          }
        }
      }
      photos_albums: {
        payload: Prisma.$photos_albumsPayload<ExtArgs>
        fields: Prisma.photos_albumsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.photos_albumsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$photos_albumsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.photos_albumsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$photos_albumsPayload>
          }
          findFirst: {
            args: Prisma.photos_albumsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$photos_albumsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.photos_albumsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$photos_albumsPayload>
          }
          findMany: {
            args: Prisma.photos_albumsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$photos_albumsPayload>[]
          }
          create: {
            args: Prisma.photos_albumsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$photos_albumsPayload>
          }
          createMany: {
            args: Prisma.photos_albumsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.photos_albumsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$photos_albumsPayload>
          }
          update: {
            args: Prisma.photos_albumsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$photos_albumsPayload>
          }
          deleteMany: {
            args: Prisma.photos_albumsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.photos_albumsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.photos_albumsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$photos_albumsPayload>
          }
          aggregate: {
            args: Prisma.Photos_albumsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePhotos_albums>
          }
          groupBy: {
            args: Prisma.photos_albumsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Photos_albumsGroupByOutputType>[]
          }
          count: {
            args: Prisma.photos_albumsCountArgs<ExtArgs>
            result: $Utils.Optional<Photos_albumsCountAggregateOutputType> | number
          }
        }
      }
      photos_albums_link: {
        payload: Prisma.$photos_albums_linkPayload<ExtArgs>
        fields: Prisma.photos_albums_linkFieldRefs
        operations: {
          findUnique: {
            args: Prisma.photos_albums_linkFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$photos_albums_linkPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.photos_albums_linkFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$photos_albums_linkPayload>
          }
          findFirst: {
            args: Prisma.photos_albums_linkFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$photos_albums_linkPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.photos_albums_linkFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$photos_albums_linkPayload>
          }
          findMany: {
            args: Prisma.photos_albums_linkFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$photos_albums_linkPayload>[]
          }
          create: {
            args: Prisma.photos_albums_linkCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$photos_albums_linkPayload>
          }
          createMany: {
            args: Prisma.photos_albums_linkCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.photos_albums_linkDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$photos_albums_linkPayload>
          }
          update: {
            args: Prisma.photos_albums_linkUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$photos_albums_linkPayload>
          }
          deleteMany: {
            args: Prisma.photos_albums_linkDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.photos_albums_linkUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.photos_albums_linkUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$photos_albums_linkPayload>
          }
          aggregate: {
            args: Prisma.Photos_albums_linkAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePhotos_albums_link>
          }
          groupBy: {
            args: Prisma.photos_albums_linkGroupByArgs<ExtArgs>
            result: $Utils.Optional<Photos_albums_linkGroupByOutputType>[]
          }
          count: {
            args: Prisma.photos_albums_linkCountArgs<ExtArgs>
            result: $Utils.Optional<Photos_albums_linkCountAggregateOutputType> | number
          }
        }
      }
      photos_albums_tags_link: {
        payload: Prisma.$photos_albums_tags_linkPayload<ExtArgs>
        fields: Prisma.photos_albums_tags_linkFieldRefs
        operations: {
          findUnique: {
            args: Prisma.photos_albums_tags_linkFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$photos_albums_tags_linkPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.photos_albums_tags_linkFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$photos_albums_tags_linkPayload>
          }
          findFirst: {
            args: Prisma.photos_albums_tags_linkFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$photos_albums_tags_linkPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.photos_albums_tags_linkFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$photos_albums_tags_linkPayload>
          }
          findMany: {
            args: Prisma.photos_albums_tags_linkFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$photos_albums_tags_linkPayload>[]
          }
          create: {
            args: Prisma.photos_albums_tags_linkCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$photos_albums_tags_linkPayload>
          }
          createMany: {
            args: Prisma.photos_albums_tags_linkCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.photos_albums_tags_linkDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$photos_albums_tags_linkPayload>
          }
          update: {
            args: Prisma.photos_albums_tags_linkUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$photos_albums_tags_linkPayload>
          }
          deleteMany: {
            args: Prisma.photos_albums_tags_linkDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.photos_albums_tags_linkUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.photos_albums_tags_linkUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$photos_albums_tags_linkPayload>
          }
          aggregate: {
            args: Prisma.Photos_albums_tags_linkAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePhotos_albums_tags_link>
          }
          groupBy: {
            args: Prisma.photos_albums_tags_linkGroupByArgs<ExtArgs>
            result: $Utils.Optional<Photos_albums_tags_linkGroupByOutputType>[]
          }
          count: {
            args: Prisma.photos_albums_tags_linkCountArgs<ExtArgs>
            result: $Utils.Optional<Photos_albums_tags_linkCountAggregateOutputType> | number
          }
        }
      }
      photos_tags: {
        payload: Prisma.$photos_tagsPayload<ExtArgs>
        fields: Prisma.photos_tagsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.photos_tagsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$photos_tagsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.photos_tagsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$photos_tagsPayload>
          }
          findFirst: {
            args: Prisma.photos_tagsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$photos_tagsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.photos_tagsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$photos_tagsPayload>
          }
          findMany: {
            args: Prisma.photos_tagsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$photos_tagsPayload>[]
          }
          create: {
            args: Prisma.photos_tagsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$photos_tagsPayload>
          }
          createMany: {
            args: Prisma.photos_tagsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.photos_tagsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$photos_tagsPayload>
          }
          update: {
            args: Prisma.photos_tagsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$photos_tagsPayload>
          }
          deleteMany: {
            args: Prisma.photos_tagsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.photos_tagsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.photos_tagsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$photos_tagsPayload>
          }
          aggregate: {
            args: Prisma.Photos_tagsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePhotos_tags>
          }
          groupBy: {
            args: Prisma.photos_tagsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Photos_tagsGroupByOutputType>[]
          }
          count: {
            args: Prisma.photos_tagsCountArgs<ExtArgs>
            result: $Utils.Optional<Photos_tagsCountAggregateOutputType> | number
          }
        }
      }
      photos_tags_link: {
        payload: Prisma.$photos_tags_linkPayload<ExtArgs>
        fields: Prisma.photos_tags_linkFieldRefs
        operations: {
          findUnique: {
            args: Prisma.photos_tags_linkFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$photos_tags_linkPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.photos_tags_linkFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$photos_tags_linkPayload>
          }
          findFirst: {
            args: Prisma.photos_tags_linkFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$photos_tags_linkPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.photos_tags_linkFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$photos_tags_linkPayload>
          }
          findMany: {
            args: Prisma.photos_tags_linkFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$photos_tags_linkPayload>[]
          }
          create: {
            args: Prisma.photos_tags_linkCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$photos_tags_linkPayload>
          }
          createMany: {
            args: Prisma.photos_tags_linkCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.photos_tags_linkDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$photos_tags_linkPayload>
          }
          update: {
            args: Prisma.photos_tags_linkUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$photos_tags_linkPayload>
          }
          deleteMany: {
            args: Prisma.photos_tags_linkDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.photos_tags_linkUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.photos_tags_linkUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$photos_tags_linkPayload>
          }
          aggregate: {
            args: Prisma.Photos_tags_linkAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePhotos_tags_link>
          }
          groupBy: {
            args: Prisma.photos_tags_linkGroupByArgs<ExtArgs>
            result: $Utils.Optional<Photos_tags_linkGroupByOutputType>[]
          }
          count: {
            args: Prisma.photos_tags_linkCountArgs<ExtArgs>
            result: $Utils.Optional<Photos_tags_linkCountAggregateOutputType> | number
          }
        }
      }
      photos_tags_recherche: {
        payload: Prisma.$photos_tags_recherchePayload<ExtArgs>
        fields: Prisma.photos_tags_rechercheFieldRefs
        operations: {
          findUnique: {
            args: Prisma.photos_tags_rechercheFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$photos_tags_recherchePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.photos_tags_rechercheFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$photos_tags_recherchePayload>
          }
          findFirst: {
            args: Prisma.photos_tags_rechercheFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$photos_tags_recherchePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.photos_tags_rechercheFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$photos_tags_recherchePayload>
          }
          findMany: {
            args: Prisma.photos_tags_rechercheFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$photos_tags_recherchePayload>[]
          }
          create: {
            args: Prisma.photos_tags_rechercheCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$photos_tags_recherchePayload>
          }
          createMany: {
            args: Prisma.photos_tags_rechercheCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.photos_tags_rechercheDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$photos_tags_recherchePayload>
          }
          update: {
            args: Prisma.photos_tags_rechercheUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$photos_tags_recherchePayload>
          }
          deleteMany: {
            args: Prisma.photos_tags_rechercheDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.photos_tags_rechercheUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.photos_tags_rechercheUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$photos_tags_recherchePayload>
          }
          aggregate: {
            args: Prisma.Photos_tags_rechercheAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePhotos_tags_recherche>
          }
          groupBy: {
            args: Prisma.photos_tags_rechercheGroupByArgs<ExtArgs>
            result: $Utils.Optional<Photos_tags_rechercheGroupByOutputType>[]
          }
          count: {
            args: Prisma.photos_tags_rechercheCountArgs<ExtArgs>
            result: $Utils.Optional<Photos_tags_rechercheCountAggregateOutputType> | number
          }
        }
      }
      photos_tags_recherche_link: {
        payload: Prisma.$photos_tags_recherche_linkPayload<ExtArgs>
        fields: Prisma.photos_tags_recherche_linkFieldRefs
        operations: {
          findUnique: {
            args: Prisma.photos_tags_recherche_linkFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$photos_tags_recherche_linkPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.photos_tags_recherche_linkFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$photos_tags_recherche_linkPayload>
          }
          findFirst: {
            args: Prisma.photos_tags_recherche_linkFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$photos_tags_recherche_linkPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.photos_tags_recherche_linkFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$photos_tags_recherche_linkPayload>
          }
          findMany: {
            args: Prisma.photos_tags_recherche_linkFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$photos_tags_recherche_linkPayload>[]
          }
          create: {
            args: Prisma.photos_tags_recherche_linkCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$photos_tags_recherche_linkPayload>
          }
          createMany: {
            args: Prisma.photos_tags_recherche_linkCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.photos_tags_recherche_linkDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$photos_tags_recherche_linkPayload>
          }
          update: {
            args: Prisma.photos_tags_recherche_linkUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$photos_tags_recherche_linkPayload>
          }
          deleteMany: {
            args: Prisma.photos_tags_recherche_linkDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.photos_tags_recherche_linkUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.photos_tags_recherche_linkUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$photos_tags_recherche_linkPayload>
          }
          aggregate: {
            args: Prisma.Photos_tags_recherche_linkAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePhotos_tags_recherche_link>
          }
          groupBy: {
            args: Prisma.photos_tags_recherche_linkGroupByArgs<ExtArgs>
            result: $Utils.Optional<Photos_tags_recherche_linkGroupByOutputType>[]
          }
          count: {
            args: Prisma.photos_tags_recherche_linkCountArgs<ExtArgs>
            result: $Utils.Optional<Photos_tags_recherche_linkCountAggregateOutputType> | number
          }
        }
      }
      session: {
        payload: Prisma.$sessionPayload<ExtArgs>
        fields: Prisma.sessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.sessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.sessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionPayload>
          }
          findFirst: {
            args: Prisma.sessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.sessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionPayload>
          }
          findMany: {
            args: Prisma.sessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionPayload>[]
          }
          create: {
            args: Prisma.sessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionPayload>
          }
          createMany: {
            args: Prisma.sessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.sessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionPayload>
          }
          update: {
            args: Prisma.sessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionPayload>
          }
          deleteMany: {
            args: Prisma.sessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.sessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.sessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.sessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.sessionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
      user: {
        payload: Prisma.$userPayload<ExtArgs>
        fields: Prisma.userFieldRefs
        operations: {
          findUnique: {
            args: Prisma.userFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.userFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          findFirst: {
            args: Prisma.userFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.userFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          findMany: {
            args: Prisma.userFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>[]
          }
          create: {
            args: Prisma.userCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          createMany: {
            args: Prisma.userCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.userDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          update: {
            args: Prisma.userUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          deleteMany: {
            args: Prisma.userDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.userUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.userUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.userGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.userCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      utilisateurs: {
        payload: Prisma.$utilisateursPayload<ExtArgs>
        fields: Prisma.utilisateursFieldRefs
        operations: {
          findUnique: {
            args: Prisma.utilisateursFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$utilisateursPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.utilisateursFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$utilisateursPayload>
          }
          findFirst: {
            args: Prisma.utilisateursFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$utilisateursPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.utilisateursFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$utilisateursPayload>
          }
          findMany: {
            args: Prisma.utilisateursFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$utilisateursPayload>[]
          }
          create: {
            args: Prisma.utilisateursCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$utilisateursPayload>
          }
          createMany: {
            args: Prisma.utilisateursCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.utilisateursDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$utilisateursPayload>
          }
          update: {
            args: Prisma.utilisateursUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$utilisateursPayload>
          }
          deleteMany: {
            args: Prisma.utilisateursDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.utilisateursUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.utilisateursUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$utilisateursPayload>
          }
          aggregate: {
            args: Prisma.UtilisateursAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUtilisateurs>
          }
          groupBy: {
            args: Prisma.utilisateursGroupByArgs<ExtArgs>
            result: $Utils.Optional<UtilisateursGroupByOutputType>[]
          }
          count: {
            args: Prisma.utilisateursCountArgs<ExtArgs>
            result: $Utils.Optional<UtilisateursCountAggregateOutputType> | number
          }
        }
      }
      verification: {
        payload: Prisma.$verificationPayload<ExtArgs>
        fields: Prisma.verificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.verificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$verificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.verificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$verificationPayload>
          }
          findFirst: {
            args: Prisma.verificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$verificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.verificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$verificationPayload>
          }
          findMany: {
            args: Prisma.verificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$verificationPayload>[]
          }
          create: {
            args: Prisma.verificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$verificationPayload>
          }
          createMany: {
            args: Prisma.verificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.verificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$verificationPayload>
          }
          update: {
            args: Prisma.verificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$verificationPayload>
          }
          deleteMany: {
            args: Prisma.verificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.verificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.verificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$verificationPayload>
          }
          aggregate: {
            args: Prisma.VerificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVerification>
          }
          groupBy: {
            args: Prisma.verificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<VerificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.verificationCountArgs<ExtArgs>
            result: $Utils.Optional<VerificationCountAggregateOutputType> | number
          }
        }
      }
      videos: {
        payload: Prisma.$videosPayload<ExtArgs>
        fields: Prisma.videosFieldRefs
        operations: {
          findUnique: {
            args: Prisma.videosFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$videosPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.videosFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$videosPayload>
          }
          findFirst: {
            args: Prisma.videosFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$videosPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.videosFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$videosPayload>
          }
          findMany: {
            args: Prisma.videosFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$videosPayload>[]
          }
          create: {
            args: Prisma.videosCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$videosPayload>
          }
          createMany: {
            args: Prisma.videosCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.videosDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$videosPayload>
          }
          update: {
            args: Prisma.videosUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$videosPayload>
          }
          deleteMany: {
            args: Prisma.videosDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.videosUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.videosUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$videosPayload>
          }
          aggregate: {
            args: Prisma.VideosAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVideos>
          }
          groupBy: {
            args: Prisma.videosGroupByArgs<ExtArgs>
            result: $Utils.Optional<VideosGroupByOutputType>[]
          }
          count: {
            args: Prisma.videosCountArgs<ExtArgs>
            result: $Utils.Optional<VideosCountAggregateOutputType> | number
          }
        }
      }
      videos_tags: {
        payload: Prisma.$videos_tagsPayload<ExtArgs>
        fields: Prisma.videos_tagsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.videos_tagsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$videos_tagsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.videos_tagsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$videos_tagsPayload>
          }
          findFirst: {
            args: Prisma.videos_tagsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$videos_tagsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.videos_tagsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$videos_tagsPayload>
          }
          findMany: {
            args: Prisma.videos_tagsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$videos_tagsPayload>[]
          }
          create: {
            args: Prisma.videos_tagsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$videos_tagsPayload>
          }
          createMany: {
            args: Prisma.videos_tagsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.videos_tagsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$videos_tagsPayload>
          }
          update: {
            args: Prisma.videos_tagsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$videos_tagsPayload>
          }
          deleteMany: {
            args: Prisma.videos_tagsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.videos_tagsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.videos_tagsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$videos_tagsPayload>
          }
          aggregate: {
            args: Prisma.Videos_tagsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVideos_tags>
          }
          groupBy: {
            args: Prisma.videos_tagsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Videos_tagsGroupByOutputType>[]
          }
          count: {
            args: Prisma.videos_tagsCountArgs<ExtArgs>
            result: $Utils.Optional<Videos_tagsCountAggregateOutputType> | number
          }
        }
      }
      videos_tags_link: {
        payload: Prisma.$videos_tags_linkPayload<ExtArgs>
        fields: Prisma.videos_tags_linkFieldRefs
        operations: {
          findUnique: {
            args: Prisma.videos_tags_linkFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$videos_tags_linkPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.videos_tags_linkFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$videos_tags_linkPayload>
          }
          findFirst: {
            args: Prisma.videos_tags_linkFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$videos_tags_linkPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.videos_tags_linkFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$videos_tags_linkPayload>
          }
          findMany: {
            args: Prisma.videos_tags_linkFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$videos_tags_linkPayload>[]
          }
          create: {
            args: Prisma.videos_tags_linkCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$videos_tags_linkPayload>
          }
          createMany: {
            args: Prisma.videos_tags_linkCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.videos_tags_linkDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$videos_tags_linkPayload>
          }
          update: {
            args: Prisma.videos_tags_linkUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$videos_tags_linkPayload>
          }
          deleteMany: {
            args: Prisma.videos_tags_linkDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.videos_tags_linkUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.videos_tags_linkUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$videos_tags_linkPayload>
          }
          aggregate: {
            args: Prisma.Videos_tags_linkAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVideos_tags_link>
          }
          groupBy: {
            args: Prisma.videos_tags_linkGroupByArgs<ExtArgs>
            result: $Utils.Optional<Videos_tags_linkGroupByOutputType>[]
          }
          count: {
            args: Prisma.videos_tags_linkCountArgs<ExtArgs>
            result: $Utils.Optional<Videos_tags_linkCountAggregateOutputType> | number
          }
        }
      }
      accueil_clients: {
        payload: Prisma.$accueil_clientsPayload<ExtArgs>
        fields: Prisma.accueil_clientsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.accueil_clientsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$accueil_clientsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.accueil_clientsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$accueil_clientsPayload>
          }
          findFirst: {
            args: Prisma.accueil_clientsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$accueil_clientsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.accueil_clientsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$accueil_clientsPayload>
          }
          findMany: {
            args: Prisma.accueil_clientsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$accueil_clientsPayload>[]
          }
          create: {
            args: Prisma.accueil_clientsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$accueil_clientsPayload>
          }
          createMany: {
            args: Prisma.accueil_clientsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.accueil_clientsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$accueil_clientsPayload>
          }
          update: {
            args: Prisma.accueil_clientsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$accueil_clientsPayload>
          }
          deleteMany: {
            args: Prisma.accueil_clientsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.accueil_clientsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.accueil_clientsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$accueil_clientsPayload>
          }
          aggregate: {
            args: Prisma.Accueil_clientsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccueil_clients>
          }
          groupBy: {
            args: Prisma.accueil_clientsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Accueil_clientsGroupByOutputType>[]
          }
          count: {
            args: Prisma.accueil_clientsCountArgs<ExtArgs>
            result: $Utils.Optional<Accueil_clientsCountAggregateOutputType> | number
          }
        }
      }
      accueil_faq: {
        payload: Prisma.$accueil_faqPayload<ExtArgs>
        fields: Prisma.accueil_faqFieldRefs
        operations: {
          findUnique: {
            args: Prisma.accueil_faqFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$accueil_faqPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.accueil_faqFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$accueil_faqPayload>
          }
          findFirst: {
            args: Prisma.accueil_faqFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$accueil_faqPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.accueil_faqFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$accueil_faqPayload>
          }
          findMany: {
            args: Prisma.accueil_faqFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$accueil_faqPayload>[]
          }
          create: {
            args: Prisma.accueil_faqCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$accueil_faqPayload>
          }
          createMany: {
            args: Prisma.accueil_faqCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.accueil_faqDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$accueil_faqPayload>
          }
          update: {
            args: Prisma.accueil_faqUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$accueil_faqPayload>
          }
          deleteMany: {
            args: Prisma.accueil_faqDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.accueil_faqUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.accueil_faqUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$accueil_faqPayload>
          }
          aggregate: {
            args: Prisma.Accueil_faqAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccueil_faq>
          }
          groupBy: {
            args: Prisma.accueil_faqGroupByArgs<ExtArgs>
            result: $Utils.Optional<Accueil_faqGroupByOutputType>[]
          }
          count: {
            args: Prisma.accueil_faqCountArgs<ExtArgs>
            result: $Utils.Optional<Accueil_faqCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    account?: accountOmit
    accueil_general?: accueil_generalOmit
    apropos_etudes?: apropos_etudesOmit
    apropos_experiences?: apropos_experiencesOmit
    apropos_general?: apropos_generalOmit
    apropos_outils?: apropos_outilsOmit
    photos?: photosOmit
    photos_albums?: photos_albumsOmit
    photos_albums_link?: photos_albums_linkOmit
    photos_albums_tags_link?: photos_albums_tags_linkOmit
    photos_tags?: photos_tagsOmit
    photos_tags_link?: photos_tags_linkOmit
    photos_tags_recherche?: photos_tags_rechercheOmit
    photos_tags_recherche_link?: photos_tags_recherche_linkOmit
    session?: sessionOmit
    user?: userOmit
    utilisateurs?: utilisateursOmit
    verification?: verificationOmit
    videos?: videosOmit
    videos_tags?: videos_tagsOmit
    videos_tags_link?: videos_tags_linkOmit
    accueil_clients?: accueil_clientsOmit
    accueil_faq?: accueil_faqOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type PhotosCountOutputType
   */

  export type PhotosCountOutputType = {
    photos_albums_link: number
    photos_tags_link: number
    photos_tags_recherche_link: number
  }

  export type PhotosCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    photos_albums_link?: boolean | PhotosCountOutputTypeCountPhotos_albums_linkArgs
    photos_tags_link?: boolean | PhotosCountOutputTypeCountPhotos_tags_linkArgs
    photos_tags_recherche_link?: boolean | PhotosCountOutputTypeCountPhotos_tags_recherche_linkArgs
  }

  // Custom InputTypes
  /**
   * PhotosCountOutputType without action
   */
  export type PhotosCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhotosCountOutputType
     */
    select?: PhotosCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PhotosCountOutputType without action
   */
  export type PhotosCountOutputTypeCountPhotos_albums_linkArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: photos_albums_linkWhereInput
  }

  /**
   * PhotosCountOutputType without action
   */
  export type PhotosCountOutputTypeCountPhotos_tags_linkArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: photos_tags_linkWhereInput
  }

  /**
   * PhotosCountOutputType without action
   */
  export type PhotosCountOutputTypeCountPhotos_tags_recherche_linkArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: photos_tags_recherche_linkWhereInput
  }


  /**
   * Count Type Photos_albumsCountOutputType
   */

  export type Photos_albumsCountOutputType = {
    photos_albums_link: number
    photos_albums_tags_link: number
  }

  export type Photos_albumsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    photos_albums_link?: boolean | Photos_albumsCountOutputTypeCountPhotos_albums_linkArgs
    photos_albums_tags_link?: boolean | Photos_albumsCountOutputTypeCountPhotos_albums_tags_linkArgs
  }

  // Custom InputTypes
  /**
   * Photos_albumsCountOutputType without action
   */
  export type Photos_albumsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Photos_albumsCountOutputType
     */
    select?: Photos_albumsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Photos_albumsCountOutputType without action
   */
  export type Photos_albumsCountOutputTypeCountPhotos_albums_linkArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: photos_albums_linkWhereInput
  }

  /**
   * Photos_albumsCountOutputType without action
   */
  export type Photos_albumsCountOutputTypeCountPhotos_albums_tags_linkArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: photos_albums_tags_linkWhereInput
  }


  /**
   * Count Type Photos_tagsCountOutputType
   */

  export type Photos_tagsCountOutputType = {
    photos_albums_tags_link: number
    photos_tags_link: number
  }

  export type Photos_tagsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    photos_albums_tags_link?: boolean | Photos_tagsCountOutputTypeCountPhotos_albums_tags_linkArgs
    photos_tags_link?: boolean | Photos_tagsCountOutputTypeCountPhotos_tags_linkArgs
  }

  // Custom InputTypes
  /**
   * Photos_tagsCountOutputType without action
   */
  export type Photos_tagsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Photos_tagsCountOutputType
     */
    select?: Photos_tagsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Photos_tagsCountOutputType without action
   */
  export type Photos_tagsCountOutputTypeCountPhotos_albums_tags_linkArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: photos_albums_tags_linkWhereInput
  }

  /**
   * Photos_tagsCountOutputType without action
   */
  export type Photos_tagsCountOutputTypeCountPhotos_tags_linkArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: photos_tags_linkWhereInput
  }


  /**
   * Count Type Photos_tags_rechercheCountOutputType
   */

  export type Photos_tags_rechercheCountOutputType = {
    photos_tags_recherche_link: number
  }

  export type Photos_tags_rechercheCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    photos_tags_recherche_link?: boolean | Photos_tags_rechercheCountOutputTypeCountPhotos_tags_recherche_linkArgs
  }

  // Custom InputTypes
  /**
   * Photos_tags_rechercheCountOutputType without action
   */
  export type Photos_tags_rechercheCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Photos_tags_rechercheCountOutputType
     */
    select?: Photos_tags_rechercheCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Photos_tags_rechercheCountOutputType without action
   */
  export type Photos_tags_rechercheCountOutputTypeCountPhotos_tags_recherche_linkArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: photos_tags_recherche_linkWhereInput
  }


  /**
   * Count Type VideosCountOutputType
   */

  export type VideosCountOutputType = {
    videos_tags_link: number
  }

  export type VideosCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    videos_tags_link?: boolean | VideosCountOutputTypeCountVideos_tags_linkArgs
  }

  // Custom InputTypes
  /**
   * VideosCountOutputType without action
   */
  export type VideosCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideosCountOutputType
     */
    select?: VideosCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * VideosCountOutputType without action
   */
  export type VideosCountOutputTypeCountVideos_tags_linkArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: videos_tags_linkWhereInput
  }


  /**
   * Count Type Videos_tagsCountOutputType
   */

  export type Videos_tagsCountOutputType = {
    videos_tags_link: number
  }

  export type Videos_tagsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    videos_tags_link?: boolean | Videos_tagsCountOutputTypeCountVideos_tags_linkArgs
  }

  // Custom InputTypes
  /**
   * Videos_tagsCountOutputType without action
   */
  export type Videos_tagsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Videos_tagsCountOutputType
     */
    select?: Videos_tagsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Videos_tagsCountOutputType without action
   */
  export type Videos_tagsCountOutputTypeCountVideos_tags_linkArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: videos_tags_linkWhereInput
  }


  /**
   * Models
   */

  /**
   * Model account
   */

  export type AggregateAccount = {
    _count: AccountCountAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  export type AccountMinAggregateOutputType = {
    id: string | null
    accountId: string | null
    providerId: string | null
    userId: string | null
    accessToken: string | null
    refreshToken: string | null
    idToken: string | null
    accessTokenExpiresAt: Date | null
    refreshTokenExpiresAt: Date | null
    scope: string | null
    password: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AccountMaxAggregateOutputType = {
    id: string | null
    accountId: string | null
    providerId: string | null
    userId: string | null
    accessToken: string | null
    refreshToken: string | null
    idToken: string | null
    accessTokenExpiresAt: Date | null
    refreshTokenExpiresAt: Date | null
    scope: string | null
    password: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AccountCountAggregateOutputType = {
    id: number
    accountId: number
    providerId: number
    userId: number
    accessToken: number
    refreshToken: number
    idToken: number
    accessTokenExpiresAt: number
    refreshTokenExpiresAt: number
    scope: number
    password: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AccountMinAggregateInputType = {
    id?: true
    accountId?: true
    providerId?: true
    userId?: true
    accessToken?: true
    refreshToken?: true
    idToken?: true
    accessTokenExpiresAt?: true
    refreshTokenExpiresAt?: true
    scope?: true
    password?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AccountMaxAggregateInputType = {
    id?: true
    accountId?: true
    providerId?: true
    userId?: true
    accessToken?: true
    refreshToken?: true
    idToken?: true
    accessTokenExpiresAt?: true
    refreshTokenExpiresAt?: true
    scope?: true
    password?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AccountCountAggregateInputType = {
    id?: true
    accountId?: true
    providerId?: true
    userId?: true
    accessToken?: true
    refreshToken?: true
    idToken?: true
    accessTokenExpiresAt?: true
    refreshTokenExpiresAt?: true
    scope?: true
    password?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which account to aggregate.
     */
    where?: accountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of accounts to fetch.
     */
    orderBy?: accountOrderByWithRelationInput | accountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: accountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned accounts
    **/
    _count?: true | AccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountMaxAggregateInputType
  }

  export type GetAccountAggregateType<T extends AccountAggregateArgs> = {
        [P in keyof T & keyof AggregateAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccount[P]>
      : GetScalarType<T[P], AggregateAccount[P]>
  }




  export type accountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: accountWhereInput
    orderBy?: accountOrderByWithAggregationInput | accountOrderByWithAggregationInput[]
    by: AccountScalarFieldEnum[] | AccountScalarFieldEnum
    having?: accountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountCountAggregateInputType | true
    _min?: AccountMinAggregateInputType
    _max?: AccountMaxAggregateInputType
  }

  export type AccountGroupByOutputType = {
    id: string
    accountId: string
    providerId: string
    userId: string
    accessToken: string | null
    refreshToken: string | null
    idToken: string | null
    accessTokenExpiresAt: Date | null
    refreshTokenExpiresAt: Date | null
    scope: string | null
    password: string | null
    createdAt: Date
    updatedAt: Date
    _count: AccountCountAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  type GetAccountGroupByPayload<T extends accountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountGroupByOutputType[P]>
            : GetScalarType<T[P], AccountGroupByOutputType[P]>
        }
      >
    >


  export type accountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountId?: boolean
    providerId?: boolean
    userId?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    idToken?: boolean
    accessTokenExpiresAt?: boolean
    refreshTokenExpiresAt?: boolean
    scope?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["account"]>



  export type accountSelectScalar = {
    id?: boolean
    accountId?: boolean
    providerId?: boolean
    userId?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    idToken?: boolean
    accessTokenExpiresAt?: boolean
    refreshTokenExpiresAt?: boolean
    scope?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type accountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "accountId" | "providerId" | "userId" | "accessToken" | "refreshToken" | "idToken" | "accessTokenExpiresAt" | "refreshTokenExpiresAt" | "scope" | "password" | "createdAt" | "updatedAt", ExtArgs["result"]["account"]>

  export type $accountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "account"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      accountId: string
      providerId: string
      userId: string
      accessToken: string | null
      refreshToken: string | null
      idToken: string | null
      accessTokenExpiresAt: Date | null
      refreshTokenExpiresAt: Date | null
      scope: string | null
      password: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["account"]>
    composites: {}
  }

  type accountGetPayload<S extends boolean | null | undefined | accountDefaultArgs> = $Result.GetResult<Prisma.$accountPayload, S>

  type accountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<accountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AccountCountAggregateInputType | true
    }

  export interface accountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['account'], meta: { name: 'account' } }
    /**
     * Find zero or one Account that matches the filter.
     * @param {accountFindUniqueArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends accountFindUniqueArgs>(args: SelectSubset<T, accountFindUniqueArgs<ExtArgs>>): Prisma__accountClient<$Result.GetResult<Prisma.$accountPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Account that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {accountFindUniqueOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends accountFindUniqueOrThrowArgs>(args: SelectSubset<T, accountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__accountClient<$Result.GetResult<Prisma.$accountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {accountFindFirstArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends accountFindFirstArgs>(args?: SelectSubset<T, accountFindFirstArgs<ExtArgs>>): Prisma__accountClient<$Result.GetResult<Prisma.$accountPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {accountFindFirstOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends accountFindFirstOrThrowArgs>(args?: SelectSubset<T, accountFindFirstOrThrowArgs<ExtArgs>>): Prisma__accountClient<$Result.GetResult<Prisma.$accountPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {accountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accounts
     * const accounts = await prisma.account.findMany()
     * 
     * // Get first 10 Accounts
     * const accounts = await prisma.account.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountWithIdOnly = await prisma.account.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends accountFindManyArgs>(args?: SelectSubset<T, accountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$accountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Account.
     * @param {accountCreateArgs} args - Arguments to create a Account.
     * @example
     * // Create one Account
     * const Account = await prisma.account.create({
     *   data: {
     *     // ... data to create a Account
     *   }
     * })
     * 
     */
    create<T extends accountCreateArgs>(args: SelectSubset<T, accountCreateArgs<ExtArgs>>): Prisma__accountClient<$Result.GetResult<Prisma.$accountPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Accounts.
     * @param {accountCreateManyArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends accountCreateManyArgs>(args?: SelectSubset<T, accountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Account.
     * @param {accountDeleteArgs} args - Arguments to delete one Account.
     * @example
     * // Delete one Account
     * const Account = await prisma.account.delete({
     *   where: {
     *     // ... filter to delete one Account
     *   }
     * })
     * 
     */
    delete<T extends accountDeleteArgs>(args: SelectSubset<T, accountDeleteArgs<ExtArgs>>): Prisma__accountClient<$Result.GetResult<Prisma.$accountPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Account.
     * @param {accountUpdateArgs} args - Arguments to update one Account.
     * @example
     * // Update one Account
     * const account = await prisma.account.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends accountUpdateArgs>(args: SelectSubset<T, accountUpdateArgs<ExtArgs>>): Prisma__accountClient<$Result.GetResult<Prisma.$accountPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Accounts.
     * @param {accountDeleteManyArgs} args - Arguments to filter Accounts to delete.
     * @example
     * // Delete a few Accounts
     * const { count } = await prisma.account.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends accountDeleteManyArgs>(args?: SelectSubset<T, accountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {accountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends accountUpdateManyArgs>(args: SelectSubset<T, accountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Account.
     * @param {accountUpsertArgs} args - Arguments to update or create a Account.
     * @example
     * // Update or create a Account
     * const account = await prisma.account.upsert({
     *   create: {
     *     // ... data to create a Account
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Account we want to update
     *   }
     * })
     */
    upsert<T extends accountUpsertArgs>(args: SelectSubset<T, accountUpsertArgs<ExtArgs>>): Prisma__accountClient<$Result.GetResult<Prisma.$accountPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {accountCountArgs} args - Arguments to filter Accounts to count.
     * @example
     * // Count the number of Accounts
     * const count = await prisma.account.count({
     *   where: {
     *     // ... the filter for the Accounts we want to count
     *   }
     * })
    **/
    count<T extends accountCountArgs>(
      args?: Subset<T, accountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountAggregateArgs>(args: Subset<T, AccountAggregateArgs>): Prisma.PrismaPromise<GetAccountAggregateType<T>>

    /**
     * Group by Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {accountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends accountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: accountGroupByArgs['orderBy'] }
        : { orderBy?: accountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, accountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the account model
   */
  readonly fields: accountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for account.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__accountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the account model
   */
  interface accountFieldRefs {
    readonly id: FieldRef<"account", 'String'>
    readonly accountId: FieldRef<"account", 'String'>
    readonly providerId: FieldRef<"account", 'String'>
    readonly userId: FieldRef<"account", 'String'>
    readonly accessToken: FieldRef<"account", 'String'>
    readonly refreshToken: FieldRef<"account", 'String'>
    readonly idToken: FieldRef<"account", 'String'>
    readonly accessTokenExpiresAt: FieldRef<"account", 'DateTime'>
    readonly refreshTokenExpiresAt: FieldRef<"account", 'DateTime'>
    readonly scope: FieldRef<"account", 'String'>
    readonly password: FieldRef<"account", 'String'>
    readonly createdAt: FieldRef<"account", 'DateTime'>
    readonly updatedAt: FieldRef<"account", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * account findUnique
   */
  export type accountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the account
     */
    select?: accountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the account
     */
    omit?: accountOmit<ExtArgs> | null
    /**
     * Filter, which account to fetch.
     */
    where: accountWhereUniqueInput
  }

  /**
   * account findUniqueOrThrow
   */
  export type accountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the account
     */
    select?: accountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the account
     */
    omit?: accountOmit<ExtArgs> | null
    /**
     * Filter, which account to fetch.
     */
    where: accountWhereUniqueInput
  }

  /**
   * account findFirst
   */
  export type accountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the account
     */
    select?: accountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the account
     */
    omit?: accountOmit<ExtArgs> | null
    /**
     * Filter, which account to fetch.
     */
    where?: accountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of accounts to fetch.
     */
    orderBy?: accountOrderByWithRelationInput | accountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for accounts.
     */
    cursor?: accountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * account findFirstOrThrow
   */
  export type accountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the account
     */
    select?: accountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the account
     */
    omit?: accountOmit<ExtArgs> | null
    /**
     * Filter, which account to fetch.
     */
    where?: accountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of accounts to fetch.
     */
    orderBy?: accountOrderByWithRelationInput | accountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for accounts.
     */
    cursor?: accountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * account findMany
   */
  export type accountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the account
     */
    select?: accountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the account
     */
    omit?: accountOmit<ExtArgs> | null
    /**
     * Filter, which accounts to fetch.
     */
    where?: accountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of accounts to fetch.
     */
    orderBy?: accountOrderByWithRelationInput | accountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing accounts.
     */
    cursor?: accountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` accounts.
     */
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * account create
   */
  export type accountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the account
     */
    select?: accountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the account
     */
    omit?: accountOmit<ExtArgs> | null
    /**
     * The data needed to create a account.
     */
    data: XOR<accountCreateInput, accountUncheckedCreateInput>
  }

  /**
   * account createMany
   */
  export type accountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many accounts.
     */
    data: accountCreateManyInput | accountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * account update
   */
  export type accountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the account
     */
    select?: accountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the account
     */
    omit?: accountOmit<ExtArgs> | null
    /**
     * The data needed to update a account.
     */
    data: XOR<accountUpdateInput, accountUncheckedUpdateInput>
    /**
     * Choose, which account to update.
     */
    where: accountWhereUniqueInput
  }

  /**
   * account updateMany
   */
  export type accountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update accounts.
     */
    data: XOR<accountUpdateManyMutationInput, accountUncheckedUpdateManyInput>
    /**
     * Filter which accounts to update
     */
    where?: accountWhereInput
    /**
     * Limit how many accounts to update.
     */
    limit?: number
  }

  /**
   * account upsert
   */
  export type accountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the account
     */
    select?: accountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the account
     */
    omit?: accountOmit<ExtArgs> | null
    /**
     * The filter to search for the account to update in case it exists.
     */
    where: accountWhereUniqueInput
    /**
     * In case the account found by the `where` argument doesn't exist, create a new account with this data.
     */
    create: XOR<accountCreateInput, accountUncheckedCreateInput>
    /**
     * In case the account was found with the provided `where` argument, update it with this data.
     */
    update: XOR<accountUpdateInput, accountUncheckedUpdateInput>
  }

  /**
   * account delete
   */
  export type accountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the account
     */
    select?: accountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the account
     */
    omit?: accountOmit<ExtArgs> | null
    /**
     * Filter which account to delete.
     */
    where: accountWhereUniqueInput
  }

  /**
   * account deleteMany
   */
  export type accountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which accounts to delete
     */
    where?: accountWhereInput
    /**
     * Limit how many accounts to delete.
     */
    limit?: number
  }

  /**
   * account without action
   */
  export type accountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the account
     */
    select?: accountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the account
     */
    omit?: accountOmit<ExtArgs> | null
  }


  /**
   * Model accueil_general
   */

  export type AggregateAccueil_general = {
    _count: Accueil_generalCountAggregateOutputType | null
    _avg: Accueil_generalAvgAggregateOutputType | null
    _sum: Accueil_generalSumAggregateOutputType | null
    _min: Accueil_generalMinAggregateOutputType | null
    _max: Accueil_generalMaxAggregateOutputType | null
  }

  export type Accueil_generalAvgAggregateOutputType = {
    id_gen: number | null
  }

  export type Accueil_generalSumAggregateOutputType = {
    id_gen: number | null
  }

  export type Accueil_generalMinAggregateOutputType = {
    id_gen: number | null
    video_desktop: string | null
    video_mobile: string | null
    video_cover: string | null
    photo: string | null
    photo_alt: string | null
    description: string | null
    localisation: string | null
  }

  export type Accueil_generalMaxAggregateOutputType = {
    id_gen: number | null
    video_desktop: string | null
    video_mobile: string | null
    video_cover: string | null
    photo: string | null
    photo_alt: string | null
    description: string | null
    localisation: string | null
  }

  export type Accueil_generalCountAggregateOutputType = {
    id_gen: number
    video_desktop: number
    video_mobile: number
    video_cover: number
    photo: number
    photo_alt: number
    description: number
    localisation: number
    _all: number
  }


  export type Accueil_generalAvgAggregateInputType = {
    id_gen?: true
  }

  export type Accueil_generalSumAggregateInputType = {
    id_gen?: true
  }

  export type Accueil_generalMinAggregateInputType = {
    id_gen?: true
    video_desktop?: true
    video_mobile?: true
    video_cover?: true
    photo?: true
    photo_alt?: true
    description?: true
    localisation?: true
  }

  export type Accueil_generalMaxAggregateInputType = {
    id_gen?: true
    video_desktop?: true
    video_mobile?: true
    video_cover?: true
    photo?: true
    photo_alt?: true
    description?: true
    localisation?: true
  }

  export type Accueil_generalCountAggregateInputType = {
    id_gen?: true
    video_desktop?: true
    video_mobile?: true
    video_cover?: true
    photo?: true
    photo_alt?: true
    description?: true
    localisation?: true
    _all?: true
  }

  export type Accueil_generalAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which accueil_general to aggregate.
     */
    where?: accueil_generalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of accueil_generals to fetch.
     */
    orderBy?: accueil_generalOrderByWithRelationInput | accueil_generalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: accueil_generalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` accueil_generals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` accueil_generals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned accueil_generals
    **/
    _count?: true | Accueil_generalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Accueil_generalAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Accueil_generalSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Accueil_generalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Accueil_generalMaxAggregateInputType
  }

  export type GetAccueil_generalAggregateType<T extends Accueil_generalAggregateArgs> = {
        [P in keyof T & keyof AggregateAccueil_general]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccueil_general[P]>
      : GetScalarType<T[P], AggregateAccueil_general[P]>
  }




  export type accueil_generalGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: accueil_generalWhereInput
    orderBy?: accueil_generalOrderByWithAggregationInput | accueil_generalOrderByWithAggregationInput[]
    by: Accueil_generalScalarFieldEnum[] | Accueil_generalScalarFieldEnum
    having?: accueil_generalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Accueil_generalCountAggregateInputType | true
    _avg?: Accueil_generalAvgAggregateInputType
    _sum?: Accueil_generalSumAggregateInputType
    _min?: Accueil_generalMinAggregateInputType
    _max?: Accueil_generalMaxAggregateInputType
  }

  export type Accueil_generalGroupByOutputType = {
    id_gen: number
    video_desktop: string
    video_mobile: string
    video_cover: string
    photo: string
    photo_alt: string
    description: string
    localisation: string
    _count: Accueil_generalCountAggregateOutputType | null
    _avg: Accueil_generalAvgAggregateOutputType | null
    _sum: Accueil_generalSumAggregateOutputType | null
    _min: Accueil_generalMinAggregateOutputType | null
    _max: Accueil_generalMaxAggregateOutputType | null
  }

  type GetAccueil_generalGroupByPayload<T extends accueil_generalGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Accueil_generalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Accueil_generalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Accueil_generalGroupByOutputType[P]>
            : GetScalarType<T[P], Accueil_generalGroupByOutputType[P]>
        }
      >
    >


  export type accueil_generalSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_gen?: boolean
    video_desktop?: boolean
    video_mobile?: boolean
    video_cover?: boolean
    photo?: boolean
    photo_alt?: boolean
    description?: boolean
    localisation?: boolean
  }, ExtArgs["result"]["accueil_general"]>



  export type accueil_generalSelectScalar = {
    id_gen?: boolean
    video_desktop?: boolean
    video_mobile?: boolean
    video_cover?: boolean
    photo?: boolean
    photo_alt?: boolean
    description?: boolean
    localisation?: boolean
  }

  export type accueil_generalOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id_gen" | "video_desktop" | "video_mobile" | "video_cover" | "photo" | "photo_alt" | "description" | "localisation", ExtArgs["result"]["accueil_general"]>

  export type $accueil_generalPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "accueil_general"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id_gen: number
      video_desktop: string
      video_mobile: string
      video_cover: string
      photo: string
      photo_alt: string
      description: string
      localisation: string
    }, ExtArgs["result"]["accueil_general"]>
    composites: {}
  }

  type accueil_generalGetPayload<S extends boolean | null | undefined | accueil_generalDefaultArgs> = $Result.GetResult<Prisma.$accueil_generalPayload, S>

  type accueil_generalCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<accueil_generalFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Accueil_generalCountAggregateInputType | true
    }

  export interface accueil_generalDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['accueil_general'], meta: { name: 'accueil_general' } }
    /**
     * Find zero or one Accueil_general that matches the filter.
     * @param {accueil_generalFindUniqueArgs} args - Arguments to find a Accueil_general
     * @example
     * // Get one Accueil_general
     * const accueil_general = await prisma.accueil_general.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends accueil_generalFindUniqueArgs>(args: SelectSubset<T, accueil_generalFindUniqueArgs<ExtArgs>>): Prisma__accueil_generalClient<$Result.GetResult<Prisma.$accueil_generalPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Accueil_general that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {accueil_generalFindUniqueOrThrowArgs} args - Arguments to find a Accueil_general
     * @example
     * // Get one Accueil_general
     * const accueil_general = await prisma.accueil_general.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends accueil_generalFindUniqueOrThrowArgs>(args: SelectSubset<T, accueil_generalFindUniqueOrThrowArgs<ExtArgs>>): Prisma__accueil_generalClient<$Result.GetResult<Prisma.$accueil_generalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Accueil_general that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {accueil_generalFindFirstArgs} args - Arguments to find a Accueil_general
     * @example
     * // Get one Accueil_general
     * const accueil_general = await prisma.accueil_general.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends accueil_generalFindFirstArgs>(args?: SelectSubset<T, accueil_generalFindFirstArgs<ExtArgs>>): Prisma__accueil_generalClient<$Result.GetResult<Prisma.$accueil_generalPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Accueil_general that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {accueil_generalFindFirstOrThrowArgs} args - Arguments to find a Accueil_general
     * @example
     * // Get one Accueil_general
     * const accueil_general = await prisma.accueil_general.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends accueil_generalFindFirstOrThrowArgs>(args?: SelectSubset<T, accueil_generalFindFirstOrThrowArgs<ExtArgs>>): Prisma__accueil_generalClient<$Result.GetResult<Prisma.$accueil_generalPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Accueil_generals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {accueil_generalFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accueil_generals
     * const accueil_generals = await prisma.accueil_general.findMany()
     * 
     * // Get first 10 Accueil_generals
     * const accueil_generals = await prisma.accueil_general.findMany({ take: 10 })
     * 
     * // Only select the `id_gen`
     * const accueil_generalWithId_genOnly = await prisma.accueil_general.findMany({ select: { id_gen: true } })
     * 
     */
    findMany<T extends accueil_generalFindManyArgs>(args?: SelectSubset<T, accueil_generalFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$accueil_generalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Accueil_general.
     * @param {accueil_generalCreateArgs} args - Arguments to create a Accueil_general.
     * @example
     * // Create one Accueil_general
     * const Accueil_general = await prisma.accueil_general.create({
     *   data: {
     *     // ... data to create a Accueil_general
     *   }
     * })
     * 
     */
    create<T extends accueil_generalCreateArgs>(args: SelectSubset<T, accueil_generalCreateArgs<ExtArgs>>): Prisma__accueil_generalClient<$Result.GetResult<Prisma.$accueil_generalPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Accueil_generals.
     * @param {accueil_generalCreateManyArgs} args - Arguments to create many Accueil_generals.
     * @example
     * // Create many Accueil_generals
     * const accueil_general = await prisma.accueil_general.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends accueil_generalCreateManyArgs>(args?: SelectSubset<T, accueil_generalCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Accueil_general.
     * @param {accueil_generalDeleteArgs} args - Arguments to delete one Accueil_general.
     * @example
     * // Delete one Accueil_general
     * const Accueil_general = await prisma.accueil_general.delete({
     *   where: {
     *     // ... filter to delete one Accueil_general
     *   }
     * })
     * 
     */
    delete<T extends accueil_generalDeleteArgs>(args: SelectSubset<T, accueil_generalDeleteArgs<ExtArgs>>): Prisma__accueil_generalClient<$Result.GetResult<Prisma.$accueil_generalPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Accueil_general.
     * @param {accueil_generalUpdateArgs} args - Arguments to update one Accueil_general.
     * @example
     * // Update one Accueil_general
     * const accueil_general = await prisma.accueil_general.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends accueil_generalUpdateArgs>(args: SelectSubset<T, accueil_generalUpdateArgs<ExtArgs>>): Prisma__accueil_generalClient<$Result.GetResult<Prisma.$accueil_generalPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Accueil_generals.
     * @param {accueil_generalDeleteManyArgs} args - Arguments to filter Accueil_generals to delete.
     * @example
     * // Delete a few Accueil_generals
     * const { count } = await prisma.accueil_general.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends accueil_generalDeleteManyArgs>(args?: SelectSubset<T, accueil_generalDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accueil_generals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {accueil_generalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accueil_generals
     * const accueil_general = await prisma.accueil_general.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends accueil_generalUpdateManyArgs>(args: SelectSubset<T, accueil_generalUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Accueil_general.
     * @param {accueil_generalUpsertArgs} args - Arguments to update or create a Accueil_general.
     * @example
     * // Update or create a Accueil_general
     * const accueil_general = await prisma.accueil_general.upsert({
     *   create: {
     *     // ... data to create a Accueil_general
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Accueil_general we want to update
     *   }
     * })
     */
    upsert<T extends accueil_generalUpsertArgs>(args: SelectSubset<T, accueil_generalUpsertArgs<ExtArgs>>): Prisma__accueil_generalClient<$Result.GetResult<Prisma.$accueil_generalPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Accueil_generals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {accueil_generalCountArgs} args - Arguments to filter Accueil_generals to count.
     * @example
     * // Count the number of Accueil_generals
     * const count = await prisma.accueil_general.count({
     *   where: {
     *     // ... the filter for the Accueil_generals we want to count
     *   }
     * })
    **/
    count<T extends accueil_generalCountArgs>(
      args?: Subset<T, accueil_generalCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Accueil_generalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Accueil_general.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Accueil_generalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Accueil_generalAggregateArgs>(args: Subset<T, Accueil_generalAggregateArgs>): Prisma.PrismaPromise<GetAccueil_generalAggregateType<T>>

    /**
     * Group by Accueil_general.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {accueil_generalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends accueil_generalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: accueil_generalGroupByArgs['orderBy'] }
        : { orderBy?: accueil_generalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, accueil_generalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccueil_generalGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the accueil_general model
   */
  readonly fields: accueil_generalFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for accueil_general.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__accueil_generalClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the accueil_general model
   */
  interface accueil_generalFieldRefs {
    readonly id_gen: FieldRef<"accueil_general", 'Int'>
    readonly video_desktop: FieldRef<"accueil_general", 'String'>
    readonly video_mobile: FieldRef<"accueil_general", 'String'>
    readonly video_cover: FieldRef<"accueil_general", 'String'>
    readonly photo: FieldRef<"accueil_general", 'String'>
    readonly photo_alt: FieldRef<"accueil_general", 'String'>
    readonly description: FieldRef<"accueil_general", 'String'>
    readonly localisation: FieldRef<"accueil_general", 'String'>
  }
    

  // Custom InputTypes
  /**
   * accueil_general findUnique
   */
  export type accueil_generalFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accueil_general
     */
    select?: accueil_generalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the accueil_general
     */
    omit?: accueil_generalOmit<ExtArgs> | null
    /**
     * Filter, which accueil_general to fetch.
     */
    where: accueil_generalWhereUniqueInput
  }

  /**
   * accueil_general findUniqueOrThrow
   */
  export type accueil_generalFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accueil_general
     */
    select?: accueil_generalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the accueil_general
     */
    omit?: accueil_generalOmit<ExtArgs> | null
    /**
     * Filter, which accueil_general to fetch.
     */
    where: accueil_generalWhereUniqueInput
  }

  /**
   * accueil_general findFirst
   */
  export type accueil_generalFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accueil_general
     */
    select?: accueil_generalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the accueil_general
     */
    omit?: accueil_generalOmit<ExtArgs> | null
    /**
     * Filter, which accueil_general to fetch.
     */
    where?: accueil_generalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of accueil_generals to fetch.
     */
    orderBy?: accueil_generalOrderByWithRelationInput | accueil_generalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for accueil_generals.
     */
    cursor?: accueil_generalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` accueil_generals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` accueil_generals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of accueil_generals.
     */
    distinct?: Accueil_generalScalarFieldEnum | Accueil_generalScalarFieldEnum[]
  }

  /**
   * accueil_general findFirstOrThrow
   */
  export type accueil_generalFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accueil_general
     */
    select?: accueil_generalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the accueil_general
     */
    omit?: accueil_generalOmit<ExtArgs> | null
    /**
     * Filter, which accueil_general to fetch.
     */
    where?: accueil_generalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of accueil_generals to fetch.
     */
    orderBy?: accueil_generalOrderByWithRelationInput | accueil_generalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for accueil_generals.
     */
    cursor?: accueil_generalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` accueil_generals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` accueil_generals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of accueil_generals.
     */
    distinct?: Accueil_generalScalarFieldEnum | Accueil_generalScalarFieldEnum[]
  }

  /**
   * accueil_general findMany
   */
  export type accueil_generalFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accueil_general
     */
    select?: accueil_generalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the accueil_general
     */
    omit?: accueil_generalOmit<ExtArgs> | null
    /**
     * Filter, which accueil_generals to fetch.
     */
    where?: accueil_generalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of accueil_generals to fetch.
     */
    orderBy?: accueil_generalOrderByWithRelationInput | accueil_generalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing accueil_generals.
     */
    cursor?: accueil_generalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` accueil_generals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` accueil_generals.
     */
    skip?: number
    distinct?: Accueil_generalScalarFieldEnum | Accueil_generalScalarFieldEnum[]
  }

  /**
   * accueil_general create
   */
  export type accueil_generalCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accueil_general
     */
    select?: accueil_generalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the accueil_general
     */
    omit?: accueil_generalOmit<ExtArgs> | null
    /**
     * The data needed to create a accueil_general.
     */
    data: XOR<accueil_generalCreateInput, accueil_generalUncheckedCreateInput>
  }

  /**
   * accueil_general createMany
   */
  export type accueil_generalCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many accueil_generals.
     */
    data: accueil_generalCreateManyInput | accueil_generalCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * accueil_general update
   */
  export type accueil_generalUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accueil_general
     */
    select?: accueil_generalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the accueil_general
     */
    omit?: accueil_generalOmit<ExtArgs> | null
    /**
     * The data needed to update a accueil_general.
     */
    data: XOR<accueil_generalUpdateInput, accueil_generalUncheckedUpdateInput>
    /**
     * Choose, which accueil_general to update.
     */
    where: accueil_generalWhereUniqueInput
  }

  /**
   * accueil_general updateMany
   */
  export type accueil_generalUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update accueil_generals.
     */
    data: XOR<accueil_generalUpdateManyMutationInput, accueil_generalUncheckedUpdateManyInput>
    /**
     * Filter which accueil_generals to update
     */
    where?: accueil_generalWhereInput
    /**
     * Limit how many accueil_generals to update.
     */
    limit?: number
  }

  /**
   * accueil_general upsert
   */
  export type accueil_generalUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accueil_general
     */
    select?: accueil_generalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the accueil_general
     */
    omit?: accueil_generalOmit<ExtArgs> | null
    /**
     * The filter to search for the accueil_general to update in case it exists.
     */
    where: accueil_generalWhereUniqueInput
    /**
     * In case the accueil_general found by the `where` argument doesn't exist, create a new accueil_general with this data.
     */
    create: XOR<accueil_generalCreateInput, accueil_generalUncheckedCreateInput>
    /**
     * In case the accueil_general was found with the provided `where` argument, update it with this data.
     */
    update: XOR<accueil_generalUpdateInput, accueil_generalUncheckedUpdateInput>
  }

  /**
   * accueil_general delete
   */
  export type accueil_generalDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accueil_general
     */
    select?: accueil_generalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the accueil_general
     */
    omit?: accueil_generalOmit<ExtArgs> | null
    /**
     * Filter which accueil_general to delete.
     */
    where: accueil_generalWhereUniqueInput
  }

  /**
   * accueil_general deleteMany
   */
  export type accueil_generalDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which accueil_generals to delete
     */
    where?: accueil_generalWhereInput
    /**
     * Limit how many accueil_generals to delete.
     */
    limit?: number
  }

  /**
   * accueil_general without action
   */
  export type accueil_generalDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accueil_general
     */
    select?: accueil_generalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the accueil_general
     */
    omit?: accueil_generalOmit<ExtArgs> | null
  }


  /**
   * Model apropos_etudes
   */

  export type AggregateApropos_etudes = {
    _count: Apropos_etudesCountAggregateOutputType | null
    _avg: Apropos_etudesAvgAggregateOutputType | null
    _sum: Apropos_etudesSumAggregateOutputType | null
    _min: Apropos_etudesMinAggregateOutputType | null
    _max: Apropos_etudesMaxAggregateOutputType | null
  }

  export type Apropos_etudesAvgAggregateOutputType = {
    id_etu: number | null
  }

  export type Apropos_etudesSumAggregateOutputType = {
    id_etu: number | null
  }

  export type Apropos_etudesMinAggregateOutputType = {
    id_etu: number | null
    date_debut: Date | null
    date_fin: Date | null
    titre: string | null
    nom_ecole: string | null
    lien_ecole: string | null
    afficher: boolean | null
  }

  export type Apropos_etudesMaxAggregateOutputType = {
    id_etu: number | null
    date_debut: Date | null
    date_fin: Date | null
    titre: string | null
    nom_ecole: string | null
    lien_ecole: string | null
    afficher: boolean | null
  }

  export type Apropos_etudesCountAggregateOutputType = {
    id_etu: number
    date_debut: number
    date_fin: number
    titre: number
    nom_ecole: number
    lien_ecole: number
    afficher: number
    _all: number
  }


  export type Apropos_etudesAvgAggregateInputType = {
    id_etu?: true
  }

  export type Apropos_etudesSumAggregateInputType = {
    id_etu?: true
  }

  export type Apropos_etudesMinAggregateInputType = {
    id_etu?: true
    date_debut?: true
    date_fin?: true
    titre?: true
    nom_ecole?: true
    lien_ecole?: true
    afficher?: true
  }

  export type Apropos_etudesMaxAggregateInputType = {
    id_etu?: true
    date_debut?: true
    date_fin?: true
    titre?: true
    nom_ecole?: true
    lien_ecole?: true
    afficher?: true
  }

  export type Apropos_etudesCountAggregateInputType = {
    id_etu?: true
    date_debut?: true
    date_fin?: true
    titre?: true
    nom_ecole?: true
    lien_ecole?: true
    afficher?: true
    _all?: true
  }

  export type Apropos_etudesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which apropos_etudes to aggregate.
     */
    where?: apropos_etudesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of apropos_etudes to fetch.
     */
    orderBy?: apropos_etudesOrderByWithRelationInput | apropos_etudesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: apropos_etudesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` apropos_etudes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` apropos_etudes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned apropos_etudes
    **/
    _count?: true | Apropos_etudesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Apropos_etudesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Apropos_etudesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Apropos_etudesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Apropos_etudesMaxAggregateInputType
  }

  export type GetApropos_etudesAggregateType<T extends Apropos_etudesAggregateArgs> = {
        [P in keyof T & keyof AggregateApropos_etudes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateApropos_etudes[P]>
      : GetScalarType<T[P], AggregateApropos_etudes[P]>
  }




  export type apropos_etudesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: apropos_etudesWhereInput
    orderBy?: apropos_etudesOrderByWithAggregationInput | apropos_etudesOrderByWithAggregationInput[]
    by: Apropos_etudesScalarFieldEnum[] | Apropos_etudesScalarFieldEnum
    having?: apropos_etudesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Apropos_etudesCountAggregateInputType | true
    _avg?: Apropos_etudesAvgAggregateInputType
    _sum?: Apropos_etudesSumAggregateInputType
    _min?: Apropos_etudesMinAggregateInputType
    _max?: Apropos_etudesMaxAggregateInputType
  }

  export type Apropos_etudesGroupByOutputType = {
    id_etu: number
    date_debut: Date
    date_fin: Date | null
    titre: string
    nom_ecole: string
    lien_ecole: string
    afficher: boolean
    _count: Apropos_etudesCountAggregateOutputType | null
    _avg: Apropos_etudesAvgAggregateOutputType | null
    _sum: Apropos_etudesSumAggregateOutputType | null
    _min: Apropos_etudesMinAggregateOutputType | null
    _max: Apropos_etudesMaxAggregateOutputType | null
  }

  type GetApropos_etudesGroupByPayload<T extends apropos_etudesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Apropos_etudesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Apropos_etudesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Apropos_etudesGroupByOutputType[P]>
            : GetScalarType<T[P], Apropos_etudesGroupByOutputType[P]>
        }
      >
    >


  export type apropos_etudesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_etu?: boolean
    date_debut?: boolean
    date_fin?: boolean
    titre?: boolean
    nom_ecole?: boolean
    lien_ecole?: boolean
    afficher?: boolean
  }, ExtArgs["result"]["apropos_etudes"]>



  export type apropos_etudesSelectScalar = {
    id_etu?: boolean
    date_debut?: boolean
    date_fin?: boolean
    titre?: boolean
    nom_ecole?: boolean
    lien_ecole?: boolean
    afficher?: boolean
  }

  export type apropos_etudesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id_etu" | "date_debut" | "date_fin" | "titre" | "nom_ecole" | "lien_ecole" | "afficher", ExtArgs["result"]["apropos_etudes"]>

  export type $apropos_etudesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "apropos_etudes"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id_etu: number
      date_debut: Date
      date_fin: Date | null
      titre: string
      nom_ecole: string
      lien_ecole: string
      afficher: boolean
    }, ExtArgs["result"]["apropos_etudes"]>
    composites: {}
  }

  type apropos_etudesGetPayload<S extends boolean | null | undefined | apropos_etudesDefaultArgs> = $Result.GetResult<Prisma.$apropos_etudesPayload, S>

  type apropos_etudesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<apropos_etudesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Apropos_etudesCountAggregateInputType | true
    }

  export interface apropos_etudesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['apropos_etudes'], meta: { name: 'apropos_etudes' } }
    /**
     * Find zero or one Apropos_etudes that matches the filter.
     * @param {apropos_etudesFindUniqueArgs} args - Arguments to find a Apropos_etudes
     * @example
     * // Get one Apropos_etudes
     * const apropos_etudes = await prisma.apropos_etudes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends apropos_etudesFindUniqueArgs>(args: SelectSubset<T, apropos_etudesFindUniqueArgs<ExtArgs>>): Prisma__apropos_etudesClient<$Result.GetResult<Prisma.$apropos_etudesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Apropos_etudes that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {apropos_etudesFindUniqueOrThrowArgs} args - Arguments to find a Apropos_etudes
     * @example
     * // Get one Apropos_etudes
     * const apropos_etudes = await prisma.apropos_etudes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends apropos_etudesFindUniqueOrThrowArgs>(args: SelectSubset<T, apropos_etudesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__apropos_etudesClient<$Result.GetResult<Prisma.$apropos_etudesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Apropos_etudes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {apropos_etudesFindFirstArgs} args - Arguments to find a Apropos_etudes
     * @example
     * // Get one Apropos_etudes
     * const apropos_etudes = await prisma.apropos_etudes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends apropos_etudesFindFirstArgs>(args?: SelectSubset<T, apropos_etudesFindFirstArgs<ExtArgs>>): Prisma__apropos_etudesClient<$Result.GetResult<Prisma.$apropos_etudesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Apropos_etudes that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {apropos_etudesFindFirstOrThrowArgs} args - Arguments to find a Apropos_etudes
     * @example
     * // Get one Apropos_etudes
     * const apropos_etudes = await prisma.apropos_etudes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends apropos_etudesFindFirstOrThrowArgs>(args?: SelectSubset<T, apropos_etudesFindFirstOrThrowArgs<ExtArgs>>): Prisma__apropos_etudesClient<$Result.GetResult<Prisma.$apropos_etudesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Apropos_etudes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {apropos_etudesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Apropos_etudes
     * const apropos_etudes = await prisma.apropos_etudes.findMany()
     * 
     * // Get first 10 Apropos_etudes
     * const apropos_etudes = await prisma.apropos_etudes.findMany({ take: 10 })
     * 
     * // Only select the `id_etu`
     * const apropos_etudesWithId_etuOnly = await prisma.apropos_etudes.findMany({ select: { id_etu: true } })
     * 
     */
    findMany<T extends apropos_etudesFindManyArgs>(args?: SelectSubset<T, apropos_etudesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$apropos_etudesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Apropos_etudes.
     * @param {apropos_etudesCreateArgs} args - Arguments to create a Apropos_etudes.
     * @example
     * // Create one Apropos_etudes
     * const Apropos_etudes = await prisma.apropos_etudes.create({
     *   data: {
     *     // ... data to create a Apropos_etudes
     *   }
     * })
     * 
     */
    create<T extends apropos_etudesCreateArgs>(args: SelectSubset<T, apropos_etudesCreateArgs<ExtArgs>>): Prisma__apropos_etudesClient<$Result.GetResult<Prisma.$apropos_etudesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Apropos_etudes.
     * @param {apropos_etudesCreateManyArgs} args - Arguments to create many Apropos_etudes.
     * @example
     * // Create many Apropos_etudes
     * const apropos_etudes = await prisma.apropos_etudes.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends apropos_etudesCreateManyArgs>(args?: SelectSubset<T, apropos_etudesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Apropos_etudes.
     * @param {apropos_etudesDeleteArgs} args - Arguments to delete one Apropos_etudes.
     * @example
     * // Delete one Apropos_etudes
     * const Apropos_etudes = await prisma.apropos_etudes.delete({
     *   where: {
     *     // ... filter to delete one Apropos_etudes
     *   }
     * })
     * 
     */
    delete<T extends apropos_etudesDeleteArgs>(args: SelectSubset<T, apropos_etudesDeleteArgs<ExtArgs>>): Prisma__apropos_etudesClient<$Result.GetResult<Prisma.$apropos_etudesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Apropos_etudes.
     * @param {apropos_etudesUpdateArgs} args - Arguments to update one Apropos_etudes.
     * @example
     * // Update one Apropos_etudes
     * const apropos_etudes = await prisma.apropos_etudes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends apropos_etudesUpdateArgs>(args: SelectSubset<T, apropos_etudesUpdateArgs<ExtArgs>>): Prisma__apropos_etudesClient<$Result.GetResult<Prisma.$apropos_etudesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Apropos_etudes.
     * @param {apropos_etudesDeleteManyArgs} args - Arguments to filter Apropos_etudes to delete.
     * @example
     * // Delete a few Apropos_etudes
     * const { count } = await prisma.apropos_etudes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends apropos_etudesDeleteManyArgs>(args?: SelectSubset<T, apropos_etudesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Apropos_etudes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {apropos_etudesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Apropos_etudes
     * const apropos_etudes = await prisma.apropos_etudes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends apropos_etudesUpdateManyArgs>(args: SelectSubset<T, apropos_etudesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Apropos_etudes.
     * @param {apropos_etudesUpsertArgs} args - Arguments to update or create a Apropos_etudes.
     * @example
     * // Update or create a Apropos_etudes
     * const apropos_etudes = await prisma.apropos_etudes.upsert({
     *   create: {
     *     // ... data to create a Apropos_etudes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Apropos_etudes we want to update
     *   }
     * })
     */
    upsert<T extends apropos_etudesUpsertArgs>(args: SelectSubset<T, apropos_etudesUpsertArgs<ExtArgs>>): Prisma__apropos_etudesClient<$Result.GetResult<Prisma.$apropos_etudesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Apropos_etudes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {apropos_etudesCountArgs} args - Arguments to filter Apropos_etudes to count.
     * @example
     * // Count the number of Apropos_etudes
     * const count = await prisma.apropos_etudes.count({
     *   where: {
     *     // ... the filter for the Apropos_etudes we want to count
     *   }
     * })
    **/
    count<T extends apropos_etudesCountArgs>(
      args?: Subset<T, apropos_etudesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Apropos_etudesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Apropos_etudes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Apropos_etudesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Apropos_etudesAggregateArgs>(args: Subset<T, Apropos_etudesAggregateArgs>): Prisma.PrismaPromise<GetApropos_etudesAggregateType<T>>

    /**
     * Group by Apropos_etudes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {apropos_etudesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends apropos_etudesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: apropos_etudesGroupByArgs['orderBy'] }
        : { orderBy?: apropos_etudesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, apropos_etudesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetApropos_etudesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the apropos_etudes model
   */
  readonly fields: apropos_etudesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for apropos_etudes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__apropos_etudesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the apropos_etudes model
   */
  interface apropos_etudesFieldRefs {
    readonly id_etu: FieldRef<"apropos_etudes", 'Int'>
    readonly date_debut: FieldRef<"apropos_etudes", 'DateTime'>
    readonly date_fin: FieldRef<"apropos_etudes", 'DateTime'>
    readonly titre: FieldRef<"apropos_etudes", 'String'>
    readonly nom_ecole: FieldRef<"apropos_etudes", 'String'>
    readonly lien_ecole: FieldRef<"apropos_etudes", 'String'>
    readonly afficher: FieldRef<"apropos_etudes", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * apropos_etudes findUnique
   */
  export type apropos_etudesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the apropos_etudes
     */
    select?: apropos_etudesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the apropos_etudes
     */
    omit?: apropos_etudesOmit<ExtArgs> | null
    /**
     * Filter, which apropos_etudes to fetch.
     */
    where: apropos_etudesWhereUniqueInput
  }

  /**
   * apropos_etudes findUniqueOrThrow
   */
  export type apropos_etudesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the apropos_etudes
     */
    select?: apropos_etudesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the apropos_etudes
     */
    omit?: apropos_etudesOmit<ExtArgs> | null
    /**
     * Filter, which apropos_etudes to fetch.
     */
    where: apropos_etudesWhereUniqueInput
  }

  /**
   * apropos_etudes findFirst
   */
  export type apropos_etudesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the apropos_etudes
     */
    select?: apropos_etudesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the apropos_etudes
     */
    omit?: apropos_etudesOmit<ExtArgs> | null
    /**
     * Filter, which apropos_etudes to fetch.
     */
    where?: apropos_etudesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of apropos_etudes to fetch.
     */
    orderBy?: apropos_etudesOrderByWithRelationInput | apropos_etudesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for apropos_etudes.
     */
    cursor?: apropos_etudesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` apropos_etudes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` apropos_etudes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of apropos_etudes.
     */
    distinct?: Apropos_etudesScalarFieldEnum | Apropos_etudesScalarFieldEnum[]
  }

  /**
   * apropos_etudes findFirstOrThrow
   */
  export type apropos_etudesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the apropos_etudes
     */
    select?: apropos_etudesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the apropos_etudes
     */
    omit?: apropos_etudesOmit<ExtArgs> | null
    /**
     * Filter, which apropos_etudes to fetch.
     */
    where?: apropos_etudesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of apropos_etudes to fetch.
     */
    orderBy?: apropos_etudesOrderByWithRelationInput | apropos_etudesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for apropos_etudes.
     */
    cursor?: apropos_etudesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` apropos_etudes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` apropos_etudes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of apropos_etudes.
     */
    distinct?: Apropos_etudesScalarFieldEnum | Apropos_etudesScalarFieldEnum[]
  }

  /**
   * apropos_etudes findMany
   */
  export type apropos_etudesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the apropos_etudes
     */
    select?: apropos_etudesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the apropos_etudes
     */
    omit?: apropos_etudesOmit<ExtArgs> | null
    /**
     * Filter, which apropos_etudes to fetch.
     */
    where?: apropos_etudesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of apropos_etudes to fetch.
     */
    orderBy?: apropos_etudesOrderByWithRelationInput | apropos_etudesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing apropos_etudes.
     */
    cursor?: apropos_etudesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` apropos_etudes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` apropos_etudes.
     */
    skip?: number
    distinct?: Apropos_etudesScalarFieldEnum | Apropos_etudesScalarFieldEnum[]
  }

  /**
   * apropos_etudes create
   */
  export type apropos_etudesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the apropos_etudes
     */
    select?: apropos_etudesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the apropos_etudes
     */
    omit?: apropos_etudesOmit<ExtArgs> | null
    /**
     * The data needed to create a apropos_etudes.
     */
    data: XOR<apropos_etudesCreateInput, apropos_etudesUncheckedCreateInput>
  }

  /**
   * apropos_etudes createMany
   */
  export type apropos_etudesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many apropos_etudes.
     */
    data: apropos_etudesCreateManyInput | apropos_etudesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * apropos_etudes update
   */
  export type apropos_etudesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the apropos_etudes
     */
    select?: apropos_etudesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the apropos_etudes
     */
    omit?: apropos_etudesOmit<ExtArgs> | null
    /**
     * The data needed to update a apropos_etudes.
     */
    data: XOR<apropos_etudesUpdateInput, apropos_etudesUncheckedUpdateInput>
    /**
     * Choose, which apropos_etudes to update.
     */
    where: apropos_etudesWhereUniqueInput
  }

  /**
   * apropos_etudes updateMany
   */
  export type apropos_etudesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update apropos_etudes.
     */
    data: XOR<apropos_etudesUpdateManyMutationInput, apropos_etudesUncheckedUpdateManyInput>
    /**
     * Filter which apropos_etudes to update
     */
    where?: apropos_etudesWhereInput
    /**
     * Limit how many apropos_etudes to update.
     */
    limit?: number
  }

  /**
   * apropos_etudes upsert
   */
  export type apropos_etudesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the apropos_etudes
     */
    select?: apropos_etudesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the apropos_etudes
     */
    omit?: apropos_etudesOmit<ExtArgs> | null
    /**
     * The filter to search for the apropos_etudes to update in case it exists.
     */
    where: apropos_etudesWhereUniqueInput
    /**
     * In case the apropos_etudes found by the `where` argument doesn't exist, create a new apropos_etudes with this data.
     */
    create: XOR<apropos_etudesCreateInput, apropos_etudesUncheckedCreateInput>
    /**
     * In case the apropos_etudes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<apropos_etudesUpdateInput, apropos_etudesUncheckedUpdateInput>
  }

  /**
   * apropos_etudes delete
   */
  export type apropos_etudesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the apropos_etudes
     */
    select?: apropos_etudesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the apropos_etudes
     */
    omit?: apropos_etudesOmit<ExtArgs> | null
    /**
     * Filter which apropos_etudes to delete.
     */
    where: apropos_etudesWhereUniqueInput
  }

  /**
   * apropos_etudes deleteMany
   */
  export type apropos_etudesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which apropos_etudes to delete
     */
    where?: apropos_etudesWhereInput
    /**
     * Limit how many apropos_etudes to delete.
     */
    limit?: number
  }

  /**
   * apropos_etudes without action
   */
  export type apropos_etudesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the apropos_etudes
     */
    select?: apropos_etudesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the apropos_etudes
     */
    omit?: apropos_etudesOmit<ExtArgs> | null
  }


  /**
   * Model apropos_experiences
   */

  export type AggregateApropos_experiences = {
    _count: Apropos_experiencesCountAggregateOutputType | null
    _avg: Apropos_experiencesAvgAggregateOutputType | null
    _sum: Apropos_experiencesSumAggregateOutputType | null
    _min: Apropos_experiencesMinAggregateOutputType | null
    _max: Apropos_experiencesMaxAggregateOutputType | null
  }

  export type Apropos_experiencesAvgAggregateOutputType = {
    id_exp: number | null
  }

  export type Apropos_experiencesSumAggregateOutputType = {
    id_exp: number | null
  }

  export type Apropos_experiencesMinAggregateOutputType = {
    id_exp: number | null
    date_debut: Date | null
    date_fin: Date | null
    titre: string | null
    nom_entreprise: string | null
    lien_entreprise: string | null
    afficher: boolean | null
  }

  export type Apropos_experiencesMaxAggregateOutputType = {
    id_exp: number | null
    date_debut: Date | null
    date_fin: Date | null
    titre: string | null
    nom_entreprise: string | null
    lien_entreprise: string | null
    afficher: boolean | null
  }

  export type Apropos_experiencesCountAggregateOutputType = {
    id_exp: number
    date_debut: number
    date_fin: number
    titre: number
    nom_entreprise: number
    lien_entreprise: number
    afficher: number
    _all: number
  }


  export type Apropos_experiencesAvgAggregateInputType = {
    id_exp?: true
  }

  export type Apropos_experiencesSumAggregateInputType = {
    id_exp?: true
  }

  export type Apropos_experiencesMinAggregateInputType = {
    id_exp?: true
    date_debut?: true
    date_fin?: true
    titre?: true
    nom_entreprise?: true
    lien_entreprise?: true
    afficher?: true
  }

  export type Apropos_experiencesMaxAggregateInputType = {
    id_exp?: true
    date_debut?: true
    date_fin?: true
    titre?: true
    nom_entreprise?: true
    lien_entreprise?: true
    afficher?: true
  }

  export type Apropos_experiencesCountAggregateInputType = {
    id_exp?: true
    date_debut?: true
    date_fin?: true
    titre?: true
    nom_entreprise?: true
    lien_entreprise?: true
    afficher?: true
    _all?: true
  }

  export type Apropos_experiencesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which apropos_experiences to aggregate.
     */
    where?: apropos_experiencesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of apropos_experiences to fetch.
     */
    orderBy?: apropos_experiencesOrderByWithRelationInput | apropos_experiencesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: apropos_experiencesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` apropos_experiences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` apropos_experiences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned apropos_experiences
    **/
    _count?: true | Apropos_experiencesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Apropos_experiencesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Apropos_experiencesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Apropos_experiencesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Apropos_experiencesMaxAggregateInputType
  }

  export type GetApropos_experiencesAggregateType<T extends Apropos_experiencesAggregateArgs> = {
        [P in keyof T & keyof AggregateApropos_experiences]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateApropos_experiences[P]>
      : GetScalarType<T[P], AggregateApropos_experiences[P]>
  }




  export type apropos_experiencesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: apropos_experiencesWhereInput
    orderBy?: apropos_experiencesOrderByWithAggregationInput | apropos_experiencesOrderByWithAggregationInput[]
    by: Apropos_experiencesScalarFieldEnum[] | Apropos_experiencesScalarFieldEnum
    having?: apropos_experiencesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Apropos_experiencesCountAggregateInputType | true
    _avg?: Apropos_experiencesAvgAggregateInputType
    _sum?: Apropos_experiencesSumAggregateInputType
    _min?: Apropos_experiencesMinAggregateInputType
    _max?: Apropos_experiencesMaxAggregateInputType
  }

  export type Apropos_experiencesGroupByOutputType = {
    id_exp: number
    date_debut: Date
    date_fin: Date | null
    titre: string
    nom_entreprise: string
    lien_entreprise: string
    afficher: boolean
    _count: Apropos_experiencesCountAggregateOutputType | null
    _avg: Apropos_experiencesAvgAggregateOutputType | null
    _sum: Apropos_experiencesSumAggregateOutputType | null
    _min: Apropos_experiencesMinAggregateOutputType | null
    _max: Apropos_experiencesMaxAggregateOutputType | null
  }

  type GetApropos_experiencesGroupByPayload<T extends apropos_experiencesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Apropos_experiencesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Apropos_experiencesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Apropos_experiencesGroupByOutputType[P]>
            : GetScalarType<T[P], Apropos_experiencesGroupByOutputType[P]>
        }
      >
    >


  export type apropos_experiencesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_exp?: boolean
    date_debut?: boolean
    date_fin?: boolean
    titre?: boolean
    nom_entreprise?: boolean
    lien_entreprise?: boolean
    afficher?: boolean
  }, ExtArgs["result"]["apropos_experiences"]>



  export type apropos_experiencesSelectScalar = {
    id_exp?: boolean
    date_debut?: boolean
    date_fin?: boolean
    titre?: boolean
    nom_entreprise?: boolean
    lien_entreprise?: boolean
    afficher?: boolean
  }

  export type apropos_experiencesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id_exp" | "date_debut" | "date_fin" | "titre" | "nom_entreprise" | "lien_entreprise" | "afficher", ExtArgs["result"]["apropos_experiences"]>

  export type $apropos_experiencesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "apropos_experiences"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id_exp: number
      date_debut: Date
      date_fin: Date | null
      titre: string
      nom_entreprise: string
      lien_entreprise: string
      afficher: boolean
    }, ExtArgs["result"]["apropos_experiences"]>
    composites: {}
  }

  type apropos_experiencesGetPayload<S extends boolean | null | undefined | apropos_experiencesDefaultArgs> = $Result.GetResult<Prisma.$apropos_experiencesPayload, S>

  type apropos_experiencesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<apropos_experiencesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Apropos_experiencesCountAggregateInputType | true
    }

  export interface apropos_experiencesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['apropos_experiences'], meta: { name: 'apropos_experiences' } }
    /**
     * Find zero or one Apropos_experiences that matches the filter.
     * @param {apropos_experiencesFindUniqueArgs} args - Arguments to find a Apropos_experiences
     * @example
     * // Get one Apropos_experiences
     * const apropos_experiences = await prisma.apropos_experiences.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends apropos_experiencesFindUniqueArgs>(args: SelectSubset<T, apropos_experiencesFindUniqueArgs<ExtArgs>>): Prisma__apropos_experiencesClient<$Result.GetResult<Prisma.$apropos_experiencesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Apropos_experiences that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {apropos_experiencesFindUniqueOrThrowArgs} args - Arguments to find a Apropos_experiences
     * @example
     * // Get one Apropos_experiences
     * const apropos_experiences = await prisma.apropos_experiences.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends apropos_experiencesFindUniqueOrThrowArgs>(args: SelectSubset<T, apropos_experiencesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__apropos_experiencesClient<$Result.GetResult<Prisma.$apropos_experiencesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Apropos_experiences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {apropos_experiencesFindFirstArgs} args - Arguments to find a Apropos_experiences
     * @example
     * // Get one Apropos_experiences
     * const apropos_experiences = await prisma.apropos_experiences.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends apropos_experiencesFindFirstArgs>(args?: SelectSubset<T, apropos_experiencesFindFirstArgs<ExtArgs>>): Prisma__apropos_experiencesClient<$Result.GetResult<Prisma.$apropos_experiencesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Apropos_experiences that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {apropos_experiencesFindFirstOrThrowArgs} args - Arguments to find a Apropos_experiences
     * @example
     * // Get one Apropos_experiences
     * const apropos_experiences = await prisma.apropos_experiences.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends apropos_experiencesFindFirstOrThrowArgs>(args?: SelectSubset<T, apropos_experiencesFindFirstOrThrowArgs<ExtArgs>>): Prisma__apropos_experiencesClient<$Result.GetResult<Prisma.$apropos_experiencesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Apropos_experiences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {apropos_experiencesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Apropos_experiences
     * const apropos_experiences = await prisma.apropos_experiences.findMany()
     * 
     * // Get first 10 Apropos_experiences
     * const apropos_experiences = await prisma.apropos_experiences.findMany({ take: 10 })
     * 
     * // Only select the `id_exp`
     * const apropos_experiencesWithId_expOnly = await prisma.apropos_experiences.findMany({ select: { id_exp: true } })
     * 
     */
    findMany<T extends apropos_experiencesFindManyArgs>(args?: SelectSubset<T, apropos_experiencesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$apropos_experiencesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Apropos_experiences.
     * @param {apropos_experiencesCreateArgs} args - Arguments to create a Apropos_experiences.
     * @example
     * // Create one Apropos_experiences
     * const Apropos_experiences = await prisma.apropos_experiences.create({
     *   data: {
     *     // ... data to create a Apropos_experiences
     *   }
     * })
     * 
     */
    create<T extends apropos_experiencesCreateArgs>(args: SelectSubset<T, apropos_experiencesCreateArgs<ExtArgs>>): Prisma__apropos_experiencesClient<$Result.GetResult<Prisma.$apropos_experiencesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Apropos_experiences.
     * @param {apropos_experiencesCreateManyArgs} args - Arguments to create many Apropos_experiences.
     * @example
     * // Create many Apropos_experiences
     * const apropos_experiences = await prisma.apropos_experiences.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends apropos_experiencesCreateManyArgs>(args?: SelectSubset<T, apropos_experiencesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Apropos_experiences.
     * @param {apropos_experiencesDeleteArgs} args - Arguments to delete one Apropos_experiences.
     * @example
     * // Delete one Apropos_experiences
     * const Apropos_experiences = await prisma.apropos_experiences.delete({
     *   where: {
     *     // ... filter to delete one Apropos_experiences
     *   }
     * })
     * 
     */
    delete<T extends apropos_experiencesDeleteArgs>(args: SelectSubset<T, apropos_experiencesDeleteArgs<ExtArgs>>): Prisma__apropos_experiencesClient<$Result.GetResult<Prisma.$apropos_experiencesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Apropos_experiences.
     * @param {apropos_experiencesUpdateArgs} args - Arguments to update one Apropos_experiences.
     * @example
     * // Update one Apropos_experiences
     * const apropos_experiences = await prisma.apropos_experiences.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends apropos_experiencesUpdateArgs>(args: SelectSubset<T, apropos_experiencesUpdateArgs<ExtArgs>>): Prisma__apropos_experiencesClient<$Result.GetResult<Prisma.$apropos_experiencesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Apropos_experiences.
     * @param {apropos_experiencesDeleteManyArgs} args - Arguments to filter Apropos_experiences to delete.
     * @example
     * // Delete a few Apropos_experiences
     * const { count } = await prisma.apropos_experiences.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends apropos_experiencesDeleteManyArgs>(args?: SelectSubset<T, apropos_experiencesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Apropos_experiences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {apropos_experiencesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Apropos_experiences
     * const apropos_experiences = await prisma.apropos_experiences.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends apropos_experiencesUpdateManyArgs>(args: SelectSubset<T, apropos_experiencesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Apropos_experiences.
     * @param {apropos_experiencesUpsertArgs} args - Arguments to update or create a Apropos_experiences.
     * @example
     * // Update or create a Apropos_experiences
     * const apropos_experiences = await prisma.apropos_experiences.upsert({
     *   create: {
     *     // ... data to create a Apropos_experiences
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Apropos_experiences we want to update
     *   }
     * })
     */
    upsert<T extends apropos_experiencesUpsertArgs>(args: SelectSubset<T, apropos_experiencesUpsertArgs<ExtArgs>>): Prisma__apropos_experiencesClient<$Result.GetResult<Prisma.$apropos_experiencesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Apropos_experiences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {apropos_experiencesCountArgs} args - Arguments to filter Apropos_experiences to count.
     * @example
     * // Count the number of Apropos_experiences
     * const count = await prisma.apropos_experiences.count({
     *   where: {
     *     // ... the filter for the Apropos_experiences we want to count
     *   }
     * })
    **/
    count<T extends apropos_experiencesCountArgs>(
      args?: Subset<T, apropos_experiencesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Apropos_experiencesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Apropos_experiences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Apropos_experiencesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Apropos_experiencesAggregateArgs>(args: Subset<T, Apropos_experiencesAggregateArgs>): Prisma.PrismaPromise<GetApropos_experiencesAggregateType<T>>

    /**
     * Group by Apropos_experiences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {apropos_experiencesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends apropos_experiencesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: apropos_experiencesGroupByArgs['orderBy'] }
        : { orderBy?: apropos_experiencesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, apropos_experiencesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetApropos_experiencesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the apropos_experiences model
   */
  readonly fields: apropos_experiencesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for apropos_experiences.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__apropos_experiencesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the apropos_experiences model
   */
  interface apropos_experiencesFieldRefs {
    readonly id_exp: FieldRef<"apropos_experiences", 'Int'>
    readonly date_debut: FieldRef<"apropos_experiences", 'DateTime'>
    readonly date_fin: FieldRef<"apropos_experiences", 'DateTime'>
    readonly titre: FieldRef<"apropos_experiences", 'String'>
    readonly nom_entreprise: FieldRef<"apropos_experiences", 'String'>
    readonly lien_entreprise: FieldRef<"apropos_experiences", 'String'>
    readonly afficher: FieldRef<"apropos_experiences", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * apropos_experiences findUnique
   */
  export type apropos_experiencesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the apropos_experiences
     */
    select?: apropos_experiencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the apropos_experiences
     */
    omit?: apropos_experiencesOmit<ExtArgs> | null
    /**
     * Filter, which apropos_experiences to fetch.
     */
    where: apropos_experiencesWhereUniqueInput
  }

  /**
   * apropos_experiences findUniqueOrThrow
   */
  export type apropos_experiencesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the apropos_experiences
     */
    select?: apropos_experiencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the apropos_experiences
     */
    omit?: apropos_experiencesOmit<ExtArgs> | null
    /**
     * Filter, which apropos_experiences to fetch.
     */
    where: apropos_experiencesWhereUniqueInput
  }

  /**
   * apropos_experiences findFirst
   */
  export type apropos_experiencesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the apropos_experiences
     */
    select?: apropos_experiencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the apropos_experiences
     */
    omit?: apropos_experiencesOmit<ExtArgs> | null
    /**
     * Filter, which apropos_experiences to fetch.
     */
    where?: apropos_experiencesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of apropos_experiences to fetch.
     */
    orderBy?: apropos_experiencesOrderByWithRelationInput | apropos_experiencesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for apropos_experiences.
     */
    cursor?: apropos_experiencesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` apropos_experiences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` apropos_experiences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of apropos_experiences.
     */
    distinct?: Apropos_experiencesScalarFieldEnum | Apropos_experiencesScalarFieldEnum[]
  }

  /**
   * apropos_experiences findFirstOrThrow
   */
  export type apropos_experiencesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the apropos_experiences
     */
    select?: apropos_experiencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the apropos_experiences
     */
    omit?: apropos_experiencesOmit<ExtArgs> | null
    /**
     * Filter, which apropos_experiences to fetch.
     */
    where?: apropos_experiencesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of apropos_experiences to fetch.
     */
    orderBy?: apropos_experiencesOrderByWithRelationInput | apropos_experiencesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for apropos_experiences.
     */
    cursor?: apropos_experiencesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` apropos_experiences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` apropos_experiences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of apropos_experiences.
     */
    distinct?: Apropos_experiencesScalarFieldEnum | Apropos_experiencesScalarFieldEnum[]
  }

  /**
   * apropos_experiences findMany
   */
  export type apropos_experiencesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the apropos_experiences
     */
    select?: apropos_experiencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the apropos_experiences
     */
    omit?: apropos_experiencesOmit<ExtArgs> | null
    /**
     * Filter, which apropos_experiences to fetch.
     */
    where?: apropos_experiencesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of apropos_experiences to fetch.
     */
    orderBy?: apropos_experiencesOrderByWithRelationInput | apropos_experiencesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing apropos_experiences.
     */
    cursor?: apropos_experiencesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` apropos_experiences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` apropos_experiences.
     */
    skip?: number
    distinct?: Apropos_experiencesScalarFieldEnum | Apropos_experiencesScalarFieldEnum[]
  }

  /**
   * apropos_experiences create
   */
  export type apropos_experiencesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the apropos_experiences
     */
    select?: apropos_experiencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the apropos_experiences
     */
    omit?: apropos_experiencesOmit<ExtArgs> | null
    /**
     * The data needed to create a apropos_experiences.
     */
    data: XOR<apropos_experiencesCreateInput, apropos_experiencesUncheckedCreateInput>
  }

  /**
   * apropos_experiences createMany
   */
  export type apropos_experiencesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many apropos_experiences.
     */
    data: apropos_experiencesCreateManyInput | apropos_experiencesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * apropos_experiences update
   */
  export type apropos_experiencesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the apropos_experiences
     */
    select?: apropos_experiencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the apropos_experiences
     */
    omit?: apropos_experiencesOmit<ExtArgs> | null
    /**
     * The data needed to update a apropos_experiences.
     */
    data: XOR<apropos_experiencesUpdateInput, apropos_experiencesUncheckedUpdateInput>
    /**
     * Choose, which apropos_experiences to update.
     */
    where: apropos_experiencesWhereUniqueInput
  }

  /**
   * apropos_experiences updateMany
   */
  export type apropos_experiencesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update apropos_experiences.
     */
    data: XOR<apropos_experiencesUpdateManyMutationInput, apropos_experiencesUncheckedUpdateManyInput>
    /**
     * Filter which apropos_experiences to update
     */
    where?: apropos_experiencesWhereInput
    /**
     * Limit how many apropos_experiences to update.
     */
    limit?: number
  }

  /**
   * apropos_experiences upsert
   */
  export type apropos_experiencesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the apropos_experiences
     */
    select?: apropos_experiencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the apropos_experiences
     */
    omit?: apropos_experiencesOmit<ExtArgs> | null
    /**
     * The filter to search for the apropos_experiences to update in case it exists.
     */
    where: apropos_experiencesWhereUniqueInput
    /**
     * In case the apropos_experiences found by the `where` argument doesn't exist, create a new apropos_experiences with this data.
     */
    create: XOR<apropos_experiencesCreateInput, apropos_experiencesUncheckedCreateInput>
    /**
     * In case the apropos_experiences was found with the provided `where` argument, update it with this data.
     */
    update: XOR<apropos_experiencesUpdateInput, apropos_experiencesUncheckedUpdateInput>
  }

  /**
   * apropos_experiences delete
   */
  export type apropos_experiencesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the apropos_experiences
     */
    select?: apropos_experiencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the apropos_experiences
     */
    omit?: apropos_experiencesOmit<ExtArgs> | null
    /**
     * Filter which apropos_experiences to delete.
     */
    where: apropos_experiencesWhereUniqueInput
  }

  /**
   * apropos_experiences deleteMany
   */
  export type apropos_experiencesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which apropos_experiences to delete
     */
    where?: apropos_experiencesWhereInput
    /**
     * Limit how many apropos_experiences to delete.
     */
    limit?: number
  }

  /**
   * apropos_experiences without action
   */
  export type apropos_experiencesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the apropos_experiences
     */
    select?: apropos_experiencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the apropos_experiences
     */
    omit?: apropos_experiencesOmit<ExtArgs> | null
  }


  /**
   * Model apropos_general
   */

  export type AggregateApropos_general = {
    _count: Apropos_generalCountAggregateOutputType | null
    _avg: Apropos_generalAvgAggregateOutputType | null
    _sum: Apropos_generalSumAggregateOutputType | null
    _min: Apropos_generalMinAggregateOutputType | null
    _max: Apropos_generalMaxAggregateOutputType | null
  }

  export type Apropos_generalAvgAggregateOutputType = {
    id_gen: number | null
  }

  export type Apropos_generalSumAggregateOutputType = {
    id_gen: number | null
  }

  export type Apropos_generalMinAggregateOutputType = {
    id_gen: number | null
    photo: string | null
    photo_alt: string | null
    description: string | null
  }

  export type Apropos_generalMaxAggregateOutputType = {
    id_gen: number | null
    photo: string | null
    photo_alt: string | null
    description: string | null
  }

  export type Apropos_generalCountAggregateOutputType = {
    id_gen: number
    photo: number
    photo_alt: number
    description: number
    _all: number
  }


  export type Apropos_generalAvgAggregateInputType = {
    id_gen?: true
  }

  export type Apropos_generalSumAggregateInputType = {
    id_gen?: true
  }

  export type Apropos_generalMinAggregateInputType = {
    id_gen?: true
    photo?: true
    photo_alt?: true
    description?: true
  }

  export type Apropos_generalMaxAggregateInputType = {
    id_gen?: true
    photo?: true
    photo_alt?: true
    description?: true
  }

  export type Apropos_generalCountAggregateInputType = {
    id_gen?: true
    photo?: true
    photo_alt?: true
    description?: true
    _all?: true
  }

  export type Apropos_generalAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which apropos_general to aggregate.
     */
    where?: apropos_generalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of apropos_generals to fetch.
     */
    orderBy?: apropos_generalOrderByWithRelationInput | apropos_generalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: apropos_generalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` apropos_generals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` apropos_generals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned apropos_generals
    **/
    _count?: true | Apropos_generalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Apropos_generalAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Apropos_generalSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Apropos_generalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Apropos_generalMaxAggregateInputType
  }

  export type GetApropos_generalAggregateType<T extends Apropos_generalAggregateArgs> = {
        [P in keyof T & keyof AggregateApropos_general]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateApropos_general[P]>
      : GetScalarType<T[P], AggregateApropos_general[P]>
  }




  export type apropos_generalGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: apropos_generalWhereInput
    orderBy?: apropos_generalOrderByWithAggregationInput | apropos_generalOrderByWithAggregationInput[]
    by: Apropos_generalScalarFieldEnum[] | Apropos_generalScalarFieldEnum
    having?: apropos_generalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Apropos_generalCountAggregateInputType | true
    _avg?: Apropos_generalAvgAggregateInputType
    _sum?: Apropos_generalSumAggregateInputType
    _min?: Apropos_generalMinAggregateInputType
    _max?: Apropos_generalMaxAggregateInputType
  }

  export type Apropos_generalGroupByOutputType = {
    id_gen: number
    photo: string
    photo_alt: string
    description: string
    _count: Apropos_generalCountAggregateOutputType | null
    _avg: Apropos_generalAvgAggregateOutputType | null
    _sum: Apropos_generalSumAggregateOutputType | null
    _min: Apropos_generalMinAggregateOutputType | null
    _max: Apropos_generalMaxAggregateOutputType | null
  }

  type GetApropos_generalGroupByPayload<T extends apropos_generalGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Apropos_generalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Apropos_generalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Apropos_generalGroupByOutputType[P]>
            : GetScalarType<T[P], Apropos_generalGroupByOutputType[P]>
        }
      >
    >


  export type apropos_generalSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_gen?: boolean
    photo?: boolean
    photo_alt?: boolean
    description?: boolean
  }, ExtArgs["result"]["apropos_general"]>



  export type apropos_generalSelectScalar = {
    id_gen?: boolean
    photo?: boolean
    photo_alt?: boolean
    description?: boolean
  }

  export type apropos_generalOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id_gen" | "photo" | "photo_alt" | "description", ExtArgs["result"]["apropos_general"]>

  export type $apropos_generalPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "apropos_general"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id_gen: number
      photo: string
      photo_alt: string
      description: string
    }, ExtArgs["result"]["apropos_general"]>
    composites: {}
  }

  type apropos_generalGetPayload<S extends boolean | null | undefined | apropos_generalDefaultArgs> = $Result.GetResult<Prisma.$apropos_generalPayload, S>

  type apropos_generalCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<apropos_generalFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Apropos_generalCountAggregateInputType | true
    }

  export interface apropos_generalDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['apropos_general'], meta: { name: 'apropos_general' } }
    /**
     * Find zero or one Apropos_general that matches the filter.
     * @param {apropos_generalFindUniqueArgs} args - Arguments to find a Apropos_general
     * @example
     * // Get one Apropos_general
     * const apropos_general = await prisma.apropos_general.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends apropos_generalFindUniqueArgs>(args: SelectSubset<T, apropos_generalFindUniqueArgs<ExtArgs>>): Prisma__apropos_generalClient<$Result.GetResult<Prisma.$apropos_generalPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Apropos_general that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {apropos_generalFindUniqueOrThrowArgs} args - Arguments to find a Apropos_general
     * @example
     * // Get one Apropos_general
     * const apropos_general = await prisma.apropos_general.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends apropos_generalFindUniqueOrThrowArgs>(args: SelectSubset<T, apropos_generalFindUniqueOrThrowArgs<ExtArgs>>): Prisma__apropos_generalClient<$Result.GetResult<Prisma.$apropos_generalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Apropos_general that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {apropos_generalFindFirstArgs} args - Arguments to find a Apropos_general
     * @example
     * // Get one Apropos_general
     * const apropos_general = await prisma.apropos_general.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends apropos_generalFindFirstArgs>(args?: SelectSubset<T, apropos_generalFindFirstArgs<ExtArgs>>): Prisma__apropos_generalClient<$Result.GetResult<Prisma.$apropos_generalPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Apropos_general that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {apropos_generalFindFirstOrThrowArgs} args - Arguments to find a Apropos_general
     * @example
     * // Get one Apropos_general
     * const apropos_general = await prisma.apropos_general.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends apropos_generalFindFirstOrThrowArgs>(args?: SelectSubset<T, apropos_generalFindFirstOrThrowArgs<ExtArgs>>): Prisma__apropos_generalClient<$Result.GetResult<Prisma.$apropos_generalPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Apropos_generals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {apropos_generalFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Apropos_generals
     * const apropos_generals = await prisma.apropos_general.findMany()
     * 
     * // Get first 10 Apropos_generals
     * const apropos_generals = await prisma.apropos_general.findMany({ take: 10 })
     * 
     * // Only select the `id_gen`
     * const apropos_generalWithId_genOnly = await prisma.apropos_general.findMany({ select: { id_gen: true } })
     * 
     */
    findMany<T extends apropos_generalFindManyArgs>(args?: SelectSubset<T, apropos_generalFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$apropos_generalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Apropos_general.
     * @param {apropos_generalCreateArgs} args - Arguments to create a Apropos_general.
     * @example
     * // Create one Apropos_general
     * const Apropos_general = await prisma.apropos_general.create({
     *   data: {
     *     // ... data to create a Apropos_general
     *   }
     * })
     * 
     */
    create<T extends apropos_generalCreateArgs>(args: SelectSubset<T, apropos_generalCreateArgs<ExtArgs>>): Prisma__apropos_generalClient<$Result.GetResult<Prisma.$apropos_generalPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Apropos_generals.
     * @param {apropos_generalCreateManyArgs} args - Arguments to create many Apropos_generals.
     * @example
     * // Create many Apropos_generals
     * const apropos_general = await prisma.apropos_general.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends apropos_generalCreateManyArgs>(args?: SelectSubset<T, apropos_generalCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Apropos_general.
     * @param {apropos_generalDeleteArgs} args - Arguments to delete one Apropos_general.
     * @example
     * // Delete one Apropos_general
     * const Apropos_general = await prisma.apropos_general.delete({
     *   where: {
     *     // ... filter to delete one Apropos_general
     *   }
     * })
     * 
     */
    delete<T extends apropos_generalDeleteArgs>(args: SelectSubset<T, apropos_generalDeleteArgs<ExtArgs>>): Prisma__apropos_generalClient<$Result.GetResult<Prisma.$apropos_generalPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Apropos_general.
     * @param {apropos_generalUpdateArgs} args - Arguments to update one Apropos_general.
     * @example
     * // Update one Apropos_general
     * const apropos_general = await prisma.apropos_general.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends apropos_generalUpdateArgs>(args: SelectSubset<T, apropos_generalUpdateArgs<ExtArgs>>): Prisma__apropos_generalClient<$Result.GetResult<Prisma.$apropos_generalPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Apropos_generals.
     * @param {apropos_generalDeleteManyArgs} args - Arguments to filter Apropos_generals to delete.
     * @example
     * // Delete a few Apropos_generals
     * const { count } = await prisma.apropos_general.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends apropos_generalDeleteManyArgs>(args?: SelectSubset<T, apropos_generalDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Apropos_generals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {apropos_generalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Apropos_generals
     * const apropos_general = await prisma.apropos_general.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends apropos_generalUpdateManyArgs>(args: SelectSubset<T, apropos_generalUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Apropos_general.
     * @param {apropos_generalUpsertArgs} args - Arguments to update or create a Apropos_general.
     * @example
     * // Update or create a Apropos_general
     * const apropos_general = await prisma.apropos_general.upsert({
     *   create: {
     *     // ... data to create a Apropos_general
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Apropos_general we want to update
     *   }
     * })
     */
    upsert<T extends apropos_generalUpsertArgs>(args: SelectSubset<T, apropos_generalUpsertArgs<ExtArgs>>): Prisma__apropos_generalClient<$Result.GetResult<Prisma.$apropos_generalPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Apropos_generals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {apropos_generalCountArgs} args - Arguments to filter Apropos_generals to count.
     * @example
     * // Count the number of Apropos_generals
     * const count = await prisma.apropos_general.count({
     *   where: {
     *     // ... the filter for the Apropos_generals we want to count
     *   }
     * })
    **/
    count<T extends apropos_generalCountArgs>(
      args?: Subset<T, apropos_generalCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Apropos_generalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Apropos_general.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Apropos_generalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Apropos_generalAggregateArgs>(args: Subset<T, Apropos_generalAggregateArgs>): Prisma.PrismaPromise<GetApropos_generalAggregateType<T>>

    /**
     * Group by Apropos_general.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {apropos_generalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends apropos_generalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: apropos_generalGroupByArgs['orderBy'] }
        : { orderBy?: apropos_generalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, apropos_generalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetApropos_generalGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the apropos_general model
   */
  readonly fields: apropos_generalFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for apropos_general.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__apropos_generalClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the apropos_general model
   */
  interface apropos_generalFieldRefs {
    readonly id_gen: FieldRef<"apropos_general", 'Int'>
    readonly photo: FieldRef<"apropos_general", 'String'>
    readonly photo_alt: FieldRef<"apropos_general", 'String'>
    readonly description: FieldRef<"apropos_general", 'String'>
  }
    

  // Custom InputTypes
  /**
   * apropos_general findUnique
   */
  export type apropos_generalFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the apropos_general
     */
    select?: apropos_generalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the apropos_general
     */
    omit?: apropos_generalOmit<ExtArgs> | null
    /**
     * Filter, which apropos_general to fetch.
     */
    where: apropos_generalWhereUniqueInput
  }

  /**
   * apropos_general findUniqueOrThrow
   */
  export type apropos_generalFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the apropos_general
     */
    select?: apropos_generalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the apropos_general
     */
    omit?: apropos_generalOmit<ExtArgs> | null
    /**
     * Filter, which apropos_general to fetch.
     */
    where: apropos_generalWhereUniqueInput
  }

  /**
   * apropos_general findFirst
   */
  export type apropos_generalFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the apropos_general
     */
    select?: apropos_generalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the apropos_general
     */
    omit?: apropos_generalOmit<ExtArgs> | null
    /**
     * Filter, which apropos_general to fetch.
     */
    where?: apropos_generalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of apropos_generals to fetch.
     */
    orderBy?: apropos_generalOrderByWithRelationInput | apropos_generalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for apropos_generals.
     */
    cursor?: apropos_generalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` apropos_generals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` apropos_generals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of apropos_generals.
     */
    distinct?: Apropos_generalScalarFieldEnum | Apropos_generalScalarFieldEnum[]
  }

  /**
   * apropos_general findFirstOrThrow
   */
  export type apropos_generalFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the apropos_general
     */
    select?: apropos_generalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the apropos_general
     */
    omit?: apropos_generalOmit<ExtArgs> | null
    /**
     * Filter, which apropos_general to fetch.
     */
    where?: apropos_generalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of apropos_generals to fetch.
     */
    orderBy?: apropos_generalOrderByWithRelationInput | apropos_generalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for apropos_generals.
     */
    cursor?: apropos_generalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` apropos_generals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` apropos_generals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of apropos_generals.
     */
    distinct?: Apropos_generalScalarFieldEnum | Apropos_generalScalarFieldEnum[]
  }

  /**
   * apropos_general findMany
   */
  export type apropos_generalFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the apropos_general
     */
    select?: apropos_generalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the apropos_general
     */
    omit?: apropos_generalOmit<ExtArgs> | null
    /**
     * Filter, which apropos_generals to fetch.
     */
    where?: apropos_generalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of apropos_generals to fetch.
     */
    orderBy?: apropos_generalOrderByWithRelationInput | apropos_generalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing apropos_generals.
     */
    cursor?: apropos_generalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` apropos_generals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` apropos_generals.
     */
    skip?: number
    distinct?: Apropos_generalScalarFieldEnum | Apropos_generalScalarFieldEnum[]
  }

  /**
   * apropos_general create
   */
  export type apropos_generalCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the apropos_general
     */
    select?: apropos_generalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the apropos_general
     */
    omit?: apropos_generalOmit<ExtArgs> | null
    /**
     * The data needed to create a apropos_general.
     */
    data: XOR<apropos_generalCreateInput, apropos_generalUncheckedCreateInput>
  }

  /**
   * apropos_general createMany
   */
  export type apropos_generalCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many apropos_generals.
     */
    data: apropos_generalCreateManyInput | apropos_generalCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * apropos_general update
   */
  export type apropos_generalUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the apropos_general
     */
    select?: apropos_generalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the apropos_general
     */
    omit?: apropos_generalOmit<ExtArgs> | null
    /**
     * The data needed to update a apropos_general.
     */
    data: XOR<apropos_generalUpdateInput, apropos_generalUncheckedUpdateInput>
    /**
     * Choose, which apropos_general to update.
     */
    where: apropos_generalWhereUniqueInput
  }

  /**
   * apropos_general updateMany
   */
  export type apropos_generalUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update apropos_generals.
     */
    data: XOR<apropos_generalUpdateManyMutationInput, apropos_generalUncheckedUpdateManyInput>
    /**
     * Filter which apropos_generals to update
     */
    where?: apropos_generalWhereInput
    /**
     * Limit how many apropos_generals to update.
     */
    limit?: number
  }

  /**
   * apropos_general upsert
   */
  export type apropos_generalUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the apropos_general
     */
    select?: apropos_generalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the apropos_general
     */
    omit?: apropos_generalOmit<ExtArgs> | null
    /**
     * The filter to search for the apropos_general to update in case it exists.
     */
    where: apropos_generalWhereUniqueInput
    /**
     * In case the apropos_general found by the `where` argument doesn't exist, create a new apropos_general with this data.
     */
    create: XOR<apropos_generalCreateInput, apropos_generalUncheckedCreateInput>
    /**
     * In case the apropos_general was found with the provided `where` argument, update it with this data.
     */
    update: XOR<apropos_generalUpdateInput, apropos_generalUncheckedUpdateInput>
  }

  /**
   * apropos_general delete
   */
  export type apropos_generalDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the apropos_general
     */
    select?: apropos_generalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the apropos_general
     */
    omit?: apropos_generalOmit<ExtArgs> | null
    /**
     * Filter which apropos_general to delete.
     */
    where: apropos_generalWhereUniqueInput
  }

  /**
   * apropos_general deleteMany
   */
  export type apropos_generalDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which apropos_generals to delete
     */
    where?: apropos_generalWhereInput
    /**
     * Limit how many apropos_generals to delete.
     */
    limit?: number
  }

  /**
   * apropos_general without action
   */
  export type apropos_generalDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the apropos_general
     */
    select?: apropos_generalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the apropos_general
     */
    omit?: apropos_generalOmit<ExtArgs> | null
  }


  /**
   * Model apropos_outils
   */

  export type AggregateApropos_outils = {
    _count: Apropos_outilsCountAggregateOutputType | null
    _avg: Apropos_outilsAvgAggregateOutputType | null
    _sum: Apropos_outilsSumAggregateOutputType | null
    _min: Apropos_outilsMinAggregateOutputType | null
    _max: Apropos_outilsMaxAggregateOutputType | null
  }

  export type Apropos_outilsAvgAggregateOutputType = {
    id_outil: number | null
    ordre: number | null
  }

  export type Apropos_outilsSumAggregateOutputType = {
    id_outil: number | null
    ordre: number | null
  }

  export type Apropos_outilsMinAggregateOutputType = {
    id_outil: number | null
    type_outil: string | null
    titre: string | null
    description: string | null
    icone: string | null
    icone_alt: string | null
    icone_rounded: boolean | null
    lien: string | null
    couleur_fond: string | null
    couleur_titre: string | null
    couleur_description: string | null
    ordre: number | null
    afficher: boolean | null
  }

  export type Apropos_outilsMaxAggregateOutputType = {
    id_outil: number | null
    type_outil: string | null
    titre: string | null
    description: string | null
    icone: string | null
    icone_alt: string | null
    icone_rounded: boolean | null
    lien: string | null
    couleur_fond: string | null
    couleur_titre: string | null
    couleur_description: string | null
    ordre: number | null
    afficher: boolean | null
  }

  export type Apropos_outilsCountAggregateOutputType = {
    id_outil: number
    type_outil: number
    titre: number
    description: number
    icone: number
    icone_alt: number
    icone_rounded: number
    lien: number
    couleur_fond: number
    couleur_titre: number
    couleur_description: number
    ordre: number
    afficher: number
    _all: number
  }


  export type Apropos_outilsAvgAggregateInputType = {
    id_outil?: true
    ordre?: true
  }

  export type Apropos_outilsSumAggregateInputType = {
    id_outil?: true
    ordre?: true
  }

  export type Apropos_outilsMinAggregateInputType = {
    id_outil?: true
    type_outil?: true
    titre?: true
    description?: true
    icone?: true
    icone_alt?: true
    icone_rounded?: true
    lien?: true
    couleur_fond?: true
    couleur_titre?: true
    couleur_description?: true
    ordre?: true
    afficher?: true
  }

  export type Apropos_outilsMaxAggregateInputType = {
    id_outil?: true
    type_outil?: true
    titre?: true
    description?: true
    icone?: true
    icone_alt?: true
    icone_rounded?: true
    lien?: true
    couleur_fond?: true
    couleur_titre?: true
    couleur_description?: true
    ordre?: true
    afficher?: true
  }

  export type Apropos_outilsCountAggregateInputType = {
    id_outil?: true
    type_outil?: true
    titre?: true
    description?: true
    icone?: true
    icone_alt?: true
    icone_rounded?: true
    lien?: true
    couleur_fond?: true
    couleur_titre?: true
    couleur_description?: true
    ordre?: true
    afficher?: true
    _all?: true
  }

  export type Apropos_outilsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which apropos_outils to aggregate.
     */
    where?: apropos_outilsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of apropos_outils to fetch.
     */
    orderBy?: apropos_outilsOrderByWithRelationInput | apropos_outilsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: apropos_outilsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` apropos_outils from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` apropos_outils.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned apropos_outils
    **/
    _count?: true | Apropos_outilsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Apropos_outilsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Apropos_outilsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Apropos_outilsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Apropos_outilsMaxAggregateInputType
  }

  export type GetApropos_outilsAggregateType<T extends Apropos_outilsAggregateArgs> = {
        [P in keyof T & keyof AggregateApropos_outils]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateApropos_outils[P]>
      : GetScalarType<T[P], AggregateApropos_outils[P]>
  }




  export type apropos_outilsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: apropos_outilsWhereInput
    orderBy?: apropos_outilsOrderByWithAggregationInput | apropos_outilsOrderByWithAggregationInput[]
    by: Apropos_outilsScalarFieldEnum[] | Apropos_outilsScalarFieldEnum
    having?: apropos_outilsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Apropos_outilsCountAggregateInputType | true
    _avg?: Apropos_outilsAvgAggregateInputType
    _sum?: Apropos_outilsSumAggregateInputType
    _min?: Apropos_outilsMinAggregateInputType
    _max?: Apropos_outilsMaxAggregateInputType
  }

  export type Apropos_outilsGroupByOutputType = {
    id_outil: number
    type_outil: string
    titre: string
    description: string
    icone: string
    icone_alt: string
    icone_rounded: boolean
    lien: string
    couleur_fond: string
    couleur_titre: string
    couleur_description: string
    ordre: number
    afficher: boolean
    _count: Apropos_outilsCountAggregateOutputType | null
    _avg: Apropos_outilsAvgAggregateOutputType | null
    _sum: Apropos_outilsSumAggregateOutputType | null
    _min: Apropos_outilsMinAggregateOutputType | null
    _max: Apropos_outilsMaxAggregateOutputType | null
  }

  type GetApropos_outilsGroupByPayload<T extends apropos_outilsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Apropos_outilsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Apropos_outilsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Apropos_outilsGroupByOutputType[P]>
            : GetScalarType<T[P], Apropos_outilsGroupByOutputType[P]>
        }
      >
    >


  export type apropos_outilsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_outil?: boolean
    type_outil?: boolean
    titre?: boolean
    description?: boolean
    icone?: boolean
    icone_alt?: boolean
    icone_rounded?: boolean
    lien?: boolean
    couleur_fond?: boolean
    couleur_titre?: boolean
    couleur_description?: boolean
    ordre?: boolean
    afficher?: boolean
  }, ExtArgs["result"]["apropos_outils"]>



  export type apropos_outilsSelectScalar = {
    id_outil?: boolean
    type_outil?: boolean
    titre?: boolean
    description?: boolean
    icone?: boolean
    icone_alt?: boolean
    icone_rounded?: boolean
    lien?: boolean
    couleur_fond?: boolean
    couleur_titre?: boolean
    couleur_description?: boolean
    ordre?: boolean
    afficher?: boolean
  }

  export type apropos_outilsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id_outil" | "type_outil" | "titre" | "description" | "icone" | "icone_alt" | "icone_rounded" | "lien" | "couleur_fond" | "couleur_titre" | "couleur_description" | "ordre" | "afficher", ExtArgs["result"]["apropos_outils"]>

  export type $apropos_outilsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "apropos_outils"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id_outil: number
      type_outil: string
      titre: string
      description: string
      icone: string
      icone_alt: string
      icone_rounded: boolean
      lien: string
      couleur_fond: string
      couleur_titre: string
      couleur_description: string
      ordre: number
      afficher: boolean
    }, ExtArgs["result"]["apropos_outils"]>
    composites: {}
  }

  type apropos_outilsGetPayload<S extends boolean | null | undefined | apropos_outilsDefaultArgs> = $Result.GetResult<Prisma.$apropos_outilsPayload, S>

  type apropos_outilsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<apropos_outilsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Apropos_outilsCountAggregateInputType | true
    }

  export interface apropos_outilsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['apropos_outils'], meta: { name: 'apropos_outils' } }
    /**
     * Find zero or one Apropos_outils that matches the filter.
     * @param {apropos_outilsFindUniqueArgs} args - Arguments to find a Apropos_outils
     * @example
     * // Get one Apropos_outils
     * const apropos_outils = await prisma.apropos_outils.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends apropos_outilsFindUniqueArgs>(args: SelectSubset<T, apropos_outilsFindUniqueArgs<ExtArgs>>): Prisma__apropos_outilsClient<$Result.GetResult<Prisma.$apropos_outilsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Apropos_outils that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {apropos_outilsFindUniqueOrThrowArgs} args - Arguments to find a Apropos_outils
     * @example
     * // Get one Apropos_outils
     * const apropos_outils = await prisma.apropos_outils.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends apropos_outilsFindUniqueOrThrowArgs>(args: SelectSubset<T, apropos_outilsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__apropos_outilsClient<$Result.GetResult<Prisma.$apropos_outilsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Apropos_outils that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {apropos_outilsFindFirstArgs} args - Arguments to find a Apropos_outils
     * @example
     * // Get one Apropos_outils
     * const apropos_outils = await prisma.apropos_outils.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends apropos_outilsFindFirstArgs>(args?: SelectSubset<T, apropos_outilsFindFirstArgs<ExtArgs>>): Prisma__apropos_outilsClient<$Result.GetResult<Prisma.$apropos_outilsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Apropos_outils that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {apropos_outilsFindFirstOrThrowArgs} args - Arguments to find a Apropos_outils
     * @example
     * // Get one Apropos_outils
     * const apropos_outils = await prisma.apropos_outils.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends apropos_outilsFindFirstOrThrowArgs>(args?: SelectSubset<T, apropos_outilsFindFirstOrThrowArgs<ExtArgs>>): Prisma__apropos_outilsClient<$Result.GetResult<Prisma.$apropos_outilsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Apropos_outils that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {apropos_outilsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Apropos_outils
     * const apropos_outils = await prisma.apropos_outils.findMany()
     * 
     * // Get first 10 Apropos_outils
     * const apropos_outils = await prisma.apropos_outils.findMany({ take: 10 })
     * 
     * // Only select the `id_outil`
     * const apropos_outilsWithId_outilOnly = await prisma.apropos_outils.findMany({ select: { id_outil: true } })
     * 
     */
    findMany<T extends apropos_outilsFindManyArgs>(args?: SelectSubset<T, apropos_outilsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$apropos_outilsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Apropos_outils.
     * @param {apropos_outilsCreateArgs} args - Arguments to create a Apropos_outils.
     * @example
     * // Create one Apropos_outils
     * const Apropos_outils = await prisma.apropos_outils.create({
     *   data: {
     *     // ... data to create a Apropos_outils
     *   }
     * })
     * 
     */
    create<T extends apropos_outilsCreateArgs>(args: SelectSubset<T, apropos_outilsCreateArgs<ExtArgs>>): Prisma__apropos_outilsClient<$Result.GetResult<Prisma.$apropos_outilsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Apropos_outils.
     * @param {apropos_outilsCreateManyArgs} args - Arguments to create many Apropos_outils.
     * @example
     * // Create many Apropos_outils
     * const apropos_outils = await prisma.apropos_outils.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends apropos_outilsCreateManyArgs>(args?: SelectSubset<T, apropos_outilsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Apropos_outils.
     * @param {apropos_outilsDeleteArgs} args - Arguments to delete one Apropos_outils.
     * @example
     * // Delete one Apropos_outils
     * const Apropos_outils = await prisma.apropos_outils.delete({
     *   where: {
     *     // ... filter to delete one Apropos_outils
     *   }
     * })
     * 
     */
    delete<T extends apropos_outilsDeleteArgs>(args: SelectSubset<T, apropos_outilsDeleteArgs<ExtArgs>>): Prisma__apropos_outilsClient<$Result.GetResult<Prisma.$apropos_outilsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Apropos_outils.
     * @param {apropos_outilsUpdateArgs} args - Arguments to update one Apropos_outils.
     * @example
     * // Update one Apropos_outils
     * const apropos_outils = await prisma.apropos_outils.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends apropos_outilsUpdateArgs>(args: SelectSubset<T, apropos_outilsUpdateArgs<ExtArgs>>): Prisma__apropos_outilsClient<$Result.GetResult<Prisma.$apropos_outilsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Apropos_outils.
     * @param {apropos_outilsDeleteManyArgs} args - Arguments to filter Apropos_outils to delete.
     * @example
     * // Delete a few Apropos_outils
     * const { count } = await prisma.apropos_outils.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends apropos_outilsDeleteManyArgs>(args?: SelectSubset<T, apropos_outilsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Apropos_outils.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {apropos_outilsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Apropos_outils
     * const apropos_outils = await prisma.apropos_outils.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends apropos_outilsUpdateManyArgs>(args: SelectSubset<T, apropos_outilsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Apropos_outils.
     * @param {apropos_outilsUpsertArgs} args - Arguments to update or create a Apropos_outils.
     * @example
     * // Update or create a Apropos_outils
     * const apropos_outils = await prisma.apropos_outils.upsert({
     *   create: {
     *     // ... data to create a Apropos_outils
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Apropos_outils we want to update
     *   }
     * })
     */
    upsert<T extends apropos_outilsUpsertArgs>(args: SelectSubset<T, apropos_outilsUpsertArgs<ExtArgs>>): Prisma__apropos_outilsClient<$Result.GetResult<Prisma.$apropos_outilsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Apropos_outils.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {apropos_outilsCountArgs} args - Arguments to filter Apropos_outils to count.
     * @example
     * // Count the number of Apropos_outils
     * const count = await prisma.apropos_outils.count({
     *   where: {
     *     // ... the filter for the Apropos_outils we want to count
     *   }
     * })
    **/
    count<T extends apropos_outilsCountArgs>(
      args?: Subset<T, apropos_outilsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Apropos_outilsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Apropos_outils.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Apropos_outilsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Apropos_outilsAggregateArgs>(args: Subset<T, Apropos_outilsAggregateArgs>): Prisma.PrismaPromise<GetApropos_outilsAggregateType<T>>

    /**
     * Group by Apropos_outils.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {apropos_outilsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends apropos_outilsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: apropos_outilsGroupByArgs['orderBy'] }
        : { orderBy?: apropos_outilsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, apropos_outilsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetApropos_outilsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the apropos_outils model
   */
  readonly fields: apropos_outilsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for apropos_outils.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__apropos_outilsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the apropos_outils model
   */
  interface apropos_outilsFieldRefs {
    readonly id_outil: FieldRef<"apropos_outils", 'Int'>
    readonly type_outil: FieldRef<"apropos_outils", 'String'>
    readonly titre: FieldRef<"apropos_outils", 'String'>
    readonly description: FieldRef<"apropos_outils", 'String'>
    readonly icone: FieldRef<"apropos_outils", 'String'>
    readonly icone_alt: FieldRef<"apropos_outils", 'String'>
    readonly icone_rounded: FieldRef<"apropos_outils", 'Boolean'>
    readonly lien: FieldRef<"apropos_outils", 'String'>
    readonly couleur_fond: FieldRef<"apropos_outils", 'String'>
    readonly couleur_titre: FieldRef<"apropos_outils", 'String'>
    readonly couleur_description: FieldRef<"apropos_outils", 'String'>
    readonly ordre: FieldRef<"apropos_outils", 'Int'>
    readonly afficher: FieldRef<"apropos_outils", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * apropos_outils findUnique
   */
  export type apropos_outilsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the apropos_outils
     */
    select?: apropos_outilsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the apropos_outils
     */
    omit?: apropos_outilsOmit<ExtArgs> | null
    /**
     * Filter, which apropos_outils to fetch.
     */
    where: apropos_outilsWhereUniqueInput
  }

  /**
   * apropos_outils findUniqueOrThrow
   */
  export type apropos_outilsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the apropos_outils
     */
    select?: apropos_outilsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the apropos_outils
     */
    omit?: apropos_outilsOmit<ExtArgs> | null
    /**
     * Filter, which apropos_outils to fetch.
     */
    where: apropos_outilsWhereUniqueInput
  }

  /**
   * apropos_outils findFirst
   */
  export type apropos_outilsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the apropos_outils
     */
    select?: apropos_outilsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the apropos_outils
     */
    omit?: apropos_outilsOmit<ExtArgs> | null
    /**
     * Filter, which apropos_outils to fetch.
     */
    where?: apropos_outilsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of apropos_outils to fetch.
     */
    orderBy?: apropos_outilsOrderByWithRelationInput | apropos_outilsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for apropos_outils.
     */
    cursor?: apropos_outilsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` apropos_outils from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` apropos_outils.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of apropos_outils.
     */
    distinct?: Apropos_outilsScalarFieldEnum | Apropos_outilsScalarFieldEnum[]
  }

  /**
   * apropos_outils findFirstOrThrow
   */
  export type apropos_outilsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the apropos_outils
     */
    select?: apropos_outilsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the apropos_outils
     */
    omit?: apropos_outilsOmit<ExtArgs> | null
    /**
     * Filter, which apropos_outils to fetch.
     */
    where?: apropos_outilsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of apropos_outils to fetch.
     */
    orderBy?: apropos_outilsOrderByWithRelationInput | apropos_outilsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for apropos_outils.
     */
    cursor?: apropos_outilsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` apropos_outils from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` apropos_outils.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of apropos_outils.
     */
    distinct?: Apropos_outilsScalarFieldEnum | Apropos_outilsScalarFieldEnum[]
  }

  /**
   * apropos_outils findMany
   */
  export type apropos_outilsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the apropos_outils
     */
    select?: apropos_outilsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the apropos_outils
     */
    omit?: apropos_outilsOmit<ExtArgs> | null
    /**
     * Filter, which apropos_outils to fetch.
     */
    where?: apropos_outilsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of apropos_outils to fetch.
     */
    orderBy?: apropos_outilsOrderByWithRelationInput | apropos_outilsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing apropos_outils.
     */
    cursor?: apropos_outilsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` apropos_outils from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` apropos_outils.
     */
    skip?: number
    distinct?: Apropos_outilsScalarFieldEnum | Apropos_outilsScalarFieldEnum[]
  }

  /**
   * apropos_outils create
   */
  export type apropos_outilsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the apropos_outils
     */
    select?: apropos_outilsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the apropos_outils
     */
    omit?: apropos_outilsOmit<ExtArgs> | null
    /**
     * The data needed to create a apropos_outils.
     */
    data: XOR<apropos_outilsCreateInput, apropos_outilsUncheckedCreateInput>
  }

  /**
   * apropos_outils createMany
   */
  export type apropos_outilsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many apropos_outils.
     */
    data: apropos_outilsCreateManyInput | apropos_outilsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * apropos_outils update
   */
  export type apropos_outilsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the apropos_outils
     */
    select?: apropos_outilsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the apropos_outils
     */
    omit?: apropos_outilsOmit<ExtArgs> | null
    /**
     * The data needed to update a apropos_outils.
     */
    data: XOR<apropos_outilsUpdateInput, apropos_outilsUncheckedUpdateInput>
    /**
     * Choose, which apropos_outils to update.
     */
    where: apropos_outilsWhereUniqueInput
  }

  /**
   * apropos_outils updateMany
   */
  export type apropos_outilsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update apropos_outils.
     */
    data: XOR<apropos_outilsUpdateManyMutationInput, apropos_outilsUncheckedUpdateManyInput>
    /**
     * Filter which apropos_outils to update
     */
    where?: apropos_outilsWhereInput
    /**
     * Limit how many apropos_outils to update.
     */
    limit?: number
  }

  /**
   * apropos_outils upsert
   */
  export type apropos_outilsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the apropos_outils
     */
    select?: apropos_outilsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the apropos_outils
     */
    omit?: apropos_outilsOmit<ExtArgs> | null
    /**
     * The filter to search for the apropos_outils to update in case it exists.
     */
    where: apropos_outilsWhereUniqueInput
    /**
     * In case the apropos_outils found by the `where` argument doesn't exist, create a new apropos_outils with this data.
     */
    create: XOR<apropos_outilsCreateInput, apropos_outilsUncheckedCreateInput>
    /**
     * In case the apropos_outils was found with the provided `where` argument, update it with this data.
     */
    update: XOR<apropos_outilsUpdateInput, apropos_outilsUncheckedUpdateInput>
  }

  /**
   * apropos_outils delete
   */
  export type apropos_outilsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the apropos_outils
     */
    select?: apropos_outilsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the apropos_outils
     */
    omit?: apropos_outilsOmit<ExtArgs> | null
    /**
     * Filter which apropos_outils to delete.
     */
    where: apropos_outilsWhereUniqueInput
  }

  /**
   * apropos_outils deleteMany
   */
  export type apropos_outilsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which apropos_outils to delete
     */
    where?: apropos_outilsWhereInput
    /**
     * Limit how many apropos_outils to delete.
     */
    limit?: number
  }

  /**
   * apropos_outils without action
   */
  export type apropos_outilsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the apropos_outils
     */
    select?: apropos_outilsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the apropos_outils
     */
    omit?: apropos_outilsOmit<ExtArgs> | null
  }


  /**
   * Model photos
   */

  export type AggregatePhotos = {
    _count: PhotosCountAggregateOutputType | null
    _avg: PhotosAvgAggregateOutputType | null
    _sum: PhotosSumAggregateOutputType | null
    _min: PhotosMinAggregateOutputType | null
    _max: PhotosMaxAggregateOutputType | null
  }

  export type PhotosAvgAggregateOutputType = {
    id_pho: number | null
    largeur: number | null
    hauteur: number | null
  }

  export type PhotosSumAggregateOutputType = {
    id_pho: number | null
    largeur: number | null
    hauteur: number | null
  }

  export type PhotosMinAggregateOutputType = {
    id_pho: number | null
    lien_high: string | null
    lien_low: string | null
    largeur: number | null
    hauteur: number | null
    alt: string | null
    date: Date | null
    afficher_carrousel_main: boolean | null
    afficher_carrousel_photos: boolean | null
    afficher: boolean | null
    derniere_modification: Date | null
  }

  export type PhotosMaxAggregateOutputType = {
    id_pho: number | null
    lien_high: string | null
    lien_low: string | null
    largeur: number | null
    hauteur: number | null
    alt: string | null
    date: Date | null
    afficher_carrousel_main: boolean | null
    afficher_carrousel_photos: boolean | null
    afficher: boolean | null
    derniere_modification: Date | null
  }

  export type PhotosCountAggregateOutputType = {
    id_pho: number
    lien_high: number
    lien_low: number
    largeur: number
    hauteur: number
    alt: number
    date: number
    afficher_carrousel_main: number
    afficher_carrousel_photos: number
    afficher: number
    derniere_modification: number
    _all: number
  }


  export type PhotosAvgAggregateInputType = {
    id_pho?: true
    largeur?: true
    hauteur?: true
  }

  export type PhotosSumAggregateInputType = {
    id_pho?: true
    largeur?: true
    hauteur?: true
  }

  export type PhotosMinAggregateInputType = {
    id_pho?: true
    lien_high?: true
    lien_low?: true
    largeur?: true
    hauteur?: true
    alt?: true
    date?: true
    afficher_carrousel_main?: true
    afficher_carrousel_photos?: true
    afficher?: true
    derniere_modification?: true
  }

  export type PhotosMaxAggregateInputType = {
    id_pho?: true
    lien_high?: true
    lien_low?: true
    largeur?: true
    hauteur?: true
    alt?: true
    date?: true
    afficher_carrousel_main?: true
    afficher_carrousel_photos?: true
    afficher?: true
    derniere_modification?: true
  }

  export type PhotosCountAggregateInputType = {
    id_pho?: true
    lien_high?: true
    lien_low?: true
    largeur?: true
    hauteur?: true
    alt?: true
    date?: true
    afficher_carrousel_main?: true
    afficher_carrousel_photos?: true
    afficher?: true
    derniere_modification?: true
    _all?: true
  }

  export type PhotosAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which photos to aggregate.
     */
    where?: photosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of photos to fetch.
     */
    orderBy?: photosOrderByWithRelationInput | photosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: photosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` photos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` photos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned photos
    **/
    _count?: true | PhotosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PhotosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PhotosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PhotosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PhotosMaxAggregateInputType
  }

  export type GetPhotosAggregateType<T extends PhotosAggregateArgs> = {
        [P in keyof T & keyof AggregatePhotos]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePhotos[P]>
      : GetScalarType<T[P], AggregatePhotos[P]>
  }




  export type photosGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: photosWhereInput
    orderBy?: photosOrderByWithAggregationInput | photosOrderByWithAggregationInput[]
    by: PhotosScalarFieldEnum[] | PhotosScalarFieldEnum
    having?: photosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PhotosCountAggregateInputType | true
    _avg?: PhotosAvgAggregateInputType
    _sum?: PhotosSumAggregateInputType
    _min?: PhotosMinAggregateInputType
    _max?: PhotosMaxAggregateInputType
  }

  export type PhotosGroupByOutputType = {
    id_pho: number
    lien_high: string
    lien_low: string
    largeur: number
    hauteur: number
    alt: string
    date: Date
    afficher_carrousel_main: boolean
    afficher_carrousel_photos: boolean
    afficher: boolean
    derniere_modification: Date
    _count: PhotosCountAggregateOutputType | null
    _avg: PhotosAvgAggregateOutputType | null
    _sum: PhotosSumAggregateOutputType | null
    _min: PhotosMinAggregateOutputType | null
    _max: PhotosMaxAggregateOutputType | null
  }

  type GetPhotosGroupByPayload<T extends photosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PhotosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PhotosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PhotosGroupByOutputType[P]>
            : GetScalarType<T[P], PhotosGroupByOutputType[P]>
        }
      >
    >


  export type photosSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_pho?: boolean
    lien_high?: boolean
    lien_low?: boolean
    largeur?: boolean
    hauteur?: boolean
    alt?: boolean
    date?: boolean
    afficher_carrousel_main?: boolean
    afficher_carrousel_photos?: boolean
    afficher?: boolean
    derniere_modification?: boolean
    photos_albums_link?: boolean | photos$photos_albums_linkArgs<ExtArgs>
    photos_tags_link?: boolean | photos$photos_tags_linkArgs<ExtArgs>
    photos_tags_recherche_link?: boolean | photos$photos_tags_recherche_linkArgs<ExtArgs>
    _count?: boolean | PhotosCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["photos"]>



  export type photosSelectScalar = {
    id_pho?: boolean
    lien_high?: boolean
    lien_low?: boolean
    largeur?: boolean
    hauteur?: boolean
    alt?: boolean
    date?: boolean
    afficher_carrousel_main?: boolean
    afficher_carrousel_photos?: boolean
    afficher?: boolean
    derniere_modification?: boolean
  }

  export type photosOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id_pho" | "lien_high" | "lien_low" | "largeur" | "hauteur" | "alt" | "date" | "afficher_carrousel_main" | "afficher_carrousel_photos" | "afficher" | "derniere_modification", ExtArgs["result"]["photos"]>
  export type photosInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    photos_albums_link?: boolean | photos$photos_albums_linkArgs<ExtArgs>
    photos_tags_link?: boolean | photos$photos_tags_linkArgs<ExtArgs>
    photos_tags_recherche_link?: boolean | photos$photos_tags_recherche_linkArgs<ExtArgs>
    _count?: boolean | PhotosCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $photosPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "photos"
    objects: {
      photos_albums_link: Prisma.$photos_albums_linkPayload<ExtArgs>[]
      photos_tags_link: Prisma.$photos_tags_linkPayload<ExtArgs>[]
      photos_tags_recherche_link: Prisma.$photos_tags_recherche_linkPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id_pho: number
      lien_high: string
      lien_low: string
      largeur: number
      hauteur: number
      alt: string
      date: Date
      afficher_carrousel_main: boolean
      afficher_carrousel_photos: boolean
      afficher: boolean
      derniere_modification: Date
    }, ExtArgs["result"]["photos"]>
    composites: {}
  }

  type photosGetPayload<S extends boolean | null | undefined | photosDefaultArgs> = $Result.GetResult<Prisma.$photosPayload, S>

  type photosCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<photosFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PhotosCountAggregateInputType | true
    }

  export interface photosDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['photos'], meta: { name: 'photos' } }
    /**
     * Find zero or one Photos that matches the filter.
     * @param {photosFindUniqueArgs} args - Arguments to find a Photos
     * @example
     * // Get one Photos
     * const photos = await prisma.photos.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends photosFindUniqueArgs>(args: SelectSubset<T, photosFindUniqueArgs<ExtArgs>>): Prisma__photosClient<$Result.GetResult<Prisma.$photosPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Photos that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {photosFindUniqueOrThrowArgs} args - Arguments to find a Photos
     * @example
     * // Get one Photos
     * const photos = await prisma.photos.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends photosFindUniqueOrThrowArgs>(args: SelectSubset<T, photosFindUniqueOrThrowArgs<ExtArgs>>): Prisma__photosClient<$Result.GetResult<Prisma.$photosPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Photos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {photosFindFirstArgs} args - Arguments to find a Photos
     * @example
     * // Get one Photos
     * const photos = await prisma.photos.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends photosFindFirstArgs>(args?: SelectSubset<T, photosFindFirstArgs<ExtArgs>>): Prisma__photosClient<$Result.GetResult<Prisma.$photosPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Photos that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {photosFindFirstOrThrowArgs} args - Arguments to find a Photos
     * @example
     * // Get one Photos
     * const photos = await prisma.photos.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends photosFindFirstOrThrowArgs>(args?: SelectSubset<T, photosFindFirstOrThrowArgs<ExtArgs>>): Prisma__photosClient<$Result.GetResult<Prisma.$photosPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Photos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {photosFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Photos
     * const photos = await prisma.photos.findMany()
     * 
     * // Get first 10 Photos
     * const photos = await prisma.photos.findMany({ take: 10 })
     * 
     * // Only select the `id_pho`
     * const photosWithId_phoOnly = await prisma.photos.findMany({ select: { id_pho: true } })
     * 
     */
    findMany<T extends photosFindManyArgs>(args?: SelectSubset<T, photosFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$photosPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Photos.
     * @param {photosCreateArgs} args - Arguments to create a Photos.
     * @example
     * // Create one Photos
     * const Photos = await prisma.photos.create({
     *   data: {
     *     // ... data to create a Photos
     *   }
     * })
     * 
     */
    create<T extends photosCreateArgs>(args: SelectSubset<T, photosCreateArgs<ExtArgs>>): Prisma__photosClient<$Result.GetResult<Prisma.$photosPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Photos.
     * @param {photosCreateManyArgs} args - Arguments to create many Photos.
     * @example
     * // Create many Photos
     * const photos = await prisma.photos.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends photosCreateManyArgs>(args?: SelectSubset<T, photosCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Photos.
     * @param {photosDeleteArgs} args - Arguments to delete one Photos.
     * @example
     * // Delete one Photos
     * const Photos = await prisma.photos.delete({
     *   where: {
     *     // ... filter to delete one Photos
     *   }
     * })
     * 
     */
    delete<T extends photosDeleteArgs>(args: SelectSubset<T, photosDeleteArgs<ExtArgs>>): Prisma__photosClient<$Result.GetResult<Prisma.$photosPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Photos.
     * @param {photosUpdateArgs} args - Arguments to update one Photos.
     * @example
     * // Update one Photos
     * const photos = await prisma.photos.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends photosUpdateArgs>(args: SelectSubset<T, photosUpdateArgs<ExtArgs>>): Prisma__photosClient<$Result.GetResult<Prisma.$photosPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Photos.
     * @param {photosDeleteManyArgs} args - Arguments to filter Photos to delete.
     * @example
     * // Delete a few Photos
     * const { count } = await prisma.photos.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends photosDeleteManyArgs>(args?: SelectSubset<T, photosDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Photos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {photosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Photos
     * const photos = await prisma.photos.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends photosUpdateManyArgs>(args: SelectSubset<T, photosUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Photos.
     * @param {photosUpsertArgs} args - Arguments to update or create a Photos.
     * @example
     * // Update or create a Photos
     * const photos = await prisma.photos.upsert({
     *   create: {
     *     // ... data to create a Photos
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Photos we want to update
     *   }
     * })
     */
    upsert<T extends photosUpsertArgs>(args: SelectSubset<T, photosUpsertArgs<ExtArgs>>): Prisma__photosClient<$Result.GetResult<Prisma.$photosPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Photos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {photosCountArgs} args - Arguments to filter Photos to count.
     * @example
     * // Count the number of Photos
     * const count = await prisma.photos.count({
     *   where: {
     *     // ... the filter for the Photos we want to count
     *   }
     * })
    **/
    count<T extends photosCountArgs>(
      args?: Subset<T, photosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PhotosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Photos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhotosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PhotosAggregateArgs>(args: Subset<T, PhotosAggregateArgs>): Prisma.PrismaPromise<GetPhotosAggregateType<T>>

    /**
     * Group by Photos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {photosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends photosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: photosGroupByArgs['orderBy'] }
        : { orderBy?: photosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, photosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPhotosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the photos model
   */
  readonly fields: photosFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for photos.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__photosClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    photos_albums_link<T extends photos$photos_albums_linkArgs<ExtArgs> = {}>(args?: Subset<T, photos$photos_albums_linkArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$photos_albums_linkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    photos_tags_link<T extends photos$photos_tags_linkArgs<ExtArgs> = {}>(args?: Subset<T, photos$photos_tags_linkArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$photos_tags_linkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    photos_tags_recherche_link<T extends photos$photos_tags_recherche_linkArgs<ExtArgs> = {}>(args?: Subset<T, photos$photos_tags_recherche_linkArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$photos_tags_recherche_linkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the photos model
   */
  interface photosFieldRefs {
    readonly id_pho: FieldRef<"photos", 'Int'>
    readonly lien_high: FieldRef<"photos", 'String'>
    readonly lien_low: FieldRef<"photos", 'String'>
    readonly largeur: FieldRef<"photos", 'Int'>
    readonly hauteur: FieldRef<"photos", 'Int'>
    readonly alt: FieldRef<"photos", 'String'>
    readonly date: FieldRef<"photos", 'DateTime'>
    readonly afficher_carrousel_main: FieldRef<"photos", 'Boolean'>
    readonly afficher_carrousel_photos: FieldRef<"photos", 'Boolean'>
    readonly afficher: FieldRef<"photos", 'Boolean'>
    readonly derniere_modification: FieldRef<"photos", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * photos findUnique
   */
  export type photosFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos
     */
    select?: photosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos
     */
    omit?: photosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photosInclude<ExtArgs> | null
    /**
     * Filter, which photos to fetch.
     */
    where: photosWhereUniqueInput
  }

  /**
   * photos findUniqueOrThrow
   */
  export type photosFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos
     */
    select?: photosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos
     */
    omit?: photosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photosInclude<ExtArgs> | null
    /**
     * Filter, which photos to fetch.
     */
    where: photosWhereUniqueInput
  }

  /**
   * photos findFirst
   */
  export type photosFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos
     */
    select?: photosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos
     */
    omit?: photosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photosInclude<ExtArgs> | null
    /**
     * Filter, which photos to fetch.
     */
    where?: photosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of photos to fetch.
     */
    orderBy?: photosOrderByWithRelationInput | photosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for photos.
     */
    cursor?: photosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` photos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` photos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of photos.
     */
    distinct?: PhotosScalarFieldEnum | PhotosScalarFieldEnum[]
  }

  /**
   * photos findFirstOrThrow
   */
  export type photosFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos
     */
    select?: photosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos
     */
    omit?: photosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photosInclude<ExtArgs> | null
    /**
     * Filter, which photos to fetch.
     */
    where?: photosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of photos to fetch.
     */
    orderBy?: photosOrderByWithRelationInput | photosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for photos.
     */
    cursor?: photosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` photos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` photos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of photos.
     */
    distinct?: PhotosScalarFieldEnum | PhotosScalarFieldEnum[]
  }

  /**
   * photos findMany
   */
  export type photosFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos
     */
    select?: photosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos
     */
    omit?: photosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photosInclude<ExtArgs> | null
    /**
     * Filter, which photos to fetch.
     */
    where?: photosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of photos to fetch.
     */
    orderBy?: photosOrderByWithRelationInput | photosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing photos.
     */
    cursor?: photosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` photos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` photos.
     */
    skip?: number
    distinct?: PhotosScalarFieldEnum | PhotosScalarFieldEnum[]
  }

  /**
   * photos create
   */
  export type photosCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos
     */
    select?: photosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos
     */
    omit?: photosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photosInclude<ExtArgs> | null
    /**
     * The data needed to create a photos.
     */
    data: XOR<photosCreateInput, photosUncheckedCreateInput>
  }

  /**
   * photos createMany
   */
  export type photosCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many photos.
     */
    data: photosCreateManyInput | photosCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * photos update
   */
  export type photosUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos
     */
    select?: photosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos
     */
    omit?: photosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photosInclude<ExtArgs> | null
    /**
     * The data needed to update a photos.
     */
    data: XOR<photosUpdateInput, photosUncheckedUpdateInput>
    /**
     * Choose, which photos to update.
     */
    where: photosWhereUniqueInput
  }

  /**
   * photos updateMany
   */
  export type photosUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update photos.
     */
    data: XOR<photosUpdateManyMutationInput, photosUncheckedUpdateManyInput>
    /**
     * Filter which photos to update
     */
    where?: photosWhereInput
    /**
     * Limit how many photos to update.
     */
    limit?: number
  }

  /**
   * photos upsert
   */
  export type photosUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos
     */
    select?: photosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos
     */
    omit?: photosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photosInclude<ExtArgs> | null
    /**
     * The filter to search for the photos to update in case it exists.
     */
    where: photosWhereUniqueInput
    /**
     * In case the photos found by the `where` argument doesn't exist, create a new photos with this data.
     */
    create: XOR<photosCreateInput, photosUncheckedCreateInput>
    /**
     * In case the photos was found with the provided `where` argument, update it with this data.
     */
    update: XOR<photosUpdateInput, photosUncheckedUpdateInput>
  }

  /**
   * photos delete
   */
  export type photosDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos
     */
    select?: photosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos
     */
    omit?: photosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photosInclude<ExtArgs> | null
    /**
     * Filter which photos to delete.
     */
    where: photosWhereUniqueInput
  }

  /**
   * photos deleteMany
   */
  export type photosDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which photos to delete
     */
    where?: photosWhereInput
    /**
     * Limit how many photos to delete.
     */
    limit?: number
  }

  /**
   * photos.photos_albums_link
   */
  export type photos$photos_albums_linkArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos_albums_link
     */
    select?: photos_albums_linkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos_albums_link
     */
    omit?: photos_albums_linkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photos_albums_linkInclude<ExtArgs> | null
    where?: photos_albums_linkWhereInput
    orderBy?: photos_albums_linkOrderByWithRelationInput | photos_albums_linkOrderByWithRelationInput[]
    cursor?: photos_albums_linkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Photos_albums_linkScalarFieldEnum | Photos_albums_linkScalarFieldEnum[]
  }

  /**
   * photos.photos_tags_link
   */
  export type photos$photos_tags_linkArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos_tags_link
     */
    select?: photos_tags_linkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos_tags_link
     */
    omit?: photos_tags_linkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photos_tags_linkInclude<ExtArgs> | null
    where?: photos_tags_linkWhereInput
    orderBy?: photos_tags_linkOrderByWithRelationInput | photos_tags_linkOrderByWithRelationInput[]
    cursor?: photos_tags_linkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Photos_tags_linkScalarFieldEnum | Photos_tags_linkScalarFieldEnum[]
  }

  /**
   * photos.photos_tags_recherche_link
   */
  export type photos$photos_tags_recherche_linkArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos_tags_recherche_link
     */
    select?: photos_tags_recherche_linkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos_tags_recherche_link
     */
    omit?: photos_tags_recherche_linkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photos_tags_recherche_linkInclude<ExtArgs> | null
    where?: photos_tags_recherche_linkWhereInput
    orderBy?: photos_tags_recherche_linkOrderByWithRelationInput | photos_tags_recherche_linkOrderByWithRelationInput[]
    cursor?: photos_tags_recherche_linkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Photos_tags_recherche_linkScalarFieldEnum | Photos_tags_recherche_linkScalarFieldEnum[]
  }

  /**
   * photos without action
   */
  export type photosDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos
     */
    select?: photosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos
     */
    omit?: photosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photosInclude<ExtArgs> | null
  }


  /**
   * Model photos_albums
   */

  export type AggregatePhotos_albums = {
    _count: Photos_albumsCountAggregateOutputType | null
    _avg: Photos_albumsAvgAggregateOutputType | null
    _sum: Photos_albumsSumAggregateOutputType | null
    _min: Photos_albumsMinAggregateOutputType | null
    _max: Photos_albumsMaxAggregateOutputType | null
  }

  export type Photos_albumsAvgAggregateOutputType = {
    id_alb: number | null
  }

  export type Photos_albumsSumAggregateOutputType = {
    id_alb: number | null
  }

  export type Photos_albumsMinAggregateOutputType = {
    id_alb: number | null
    titre: string | null
    lien_cover: string | null
    date: Date | null
    afficher: boolean | null
    derniere_modification: Date | null
  }

  export type Photos_albumsMaxAggregateOutputType = {
    id_alb: number | null
    titre: string | null
    lien_cover: string | null
    date: Date | null
    afficher: boolean | null
    derniere_modification: Date | null
  }

  export type Photos_albumsCountAggregateOutputType = {
    id_alb: number
    titre: number
    lien_cover: number
    date: number
    afficher: number
    derniere_modification: number
    _all: number
  }


  export type Photos_albumsAvgAggregateInputType = {
    id_alb?: true
  }

  export type Photos_albumsSumAggregateInputType = {
    id_alb?: true
  }

  export type Photos_albumsMinAggregateInputType = {
    id_alb?: true
    titre?: true
    lien_cover?: true
    date?: true
    afficher?: true
    derniere_modification?: true
  }

  export type Photos_albumsMaxAggregateInputType = {
    id_alb?: true
    titre?: true
    lien_cover?: true
    date?: true
    afficher?: true
    derniere_modification?: true
  }

  export type Photos_albumsCountAggregateInputType = {
    id_alb?: true
    titre?: true
    lien_cover?: true
    date?: true
    afficher?: true
    derniere_modification?: true
    _all?: true
  }

  export type Photos_albumsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which photos_albums to aggregate.
     */
    where?: photos_albumsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of photos_albums to fetch.
     */
    orderBy?: photos_albumsOrderByWithRelationInput | photos_albumsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: photos_albumsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` photos_albums from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` photos_albums.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned photos_albums
    **/
    _count?: true | Photos_albumsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Photos_albumsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Photos_albumsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Photos_albumsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Photos_albumsMaxAggregateInputType
  }

  export type GetPhotos_albumsAggregateType<T extends Photos_albumsAggregateArgs> = {
        [P in keyof T & keyof AggregatePhotos_albums]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePhotos_albums[P]>
      : GetScalarType<T[P], AggregatePhotos_albums[P]>
  }




  export type photos_albumsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: photos_albumsWhereInput
    orderBy?: photos_albumsOrderByWithAggregationInput | photos_albumsOrderByWithAggregationInput[]
    by: Photos_albumsScalarFieldEnum[] | Photos_albumsScalarFieldEnum
    having?: photos_albumsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Photos_albumsCountAggregateInputType | true
    _avg?: Photos_albumsAvgAggregateInputType
    _sum?: Photos_albumsSumAggregateInputType
    _min?: Photos_albumsMinAggregateInputType
    _max?: Photos_albumsMaxAggregateInputType
  }

  export type Photos_albumsGroupByOutputType = {
    id_alb: number
    titre: string
    lien_cover: string
    date: Date
    afficher: boolean
    derniere_modification: Date
    _count: Photos_albumsCountAggregateOutputType | null
    _avg: Photos_albumsAvgAggregateOutputType | null
    _sum: Photos_albumsSumAggregateOutputType | null
    _min: Photos_albumsMinAggregateOutputType | null
    _max: Photos_albumsMaxAggregateOutputType | null
  }

  type GetPhotos_albumsGroupByPayload<T extends photos_albumsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Photos_albumsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Photos_albumsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Photos_albumsGroupByOutputType[P]>
            : GetScalarType<T[P], Photos_albumsGroupByOutputType[P]>
        }
      >
    >


  export type photos_albumsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_alb?: boolean
    titre?: boolean
    lien_cover?: boolean
    date?: boolean
    afficher?: boolean
    derniere_modification?: boolean
    photos_albums_link?: boolean | photos_albums$photos_albums_linkArgs<ExtArgs>
    photos_albums_tags_link?: boolean | photos_albums$photos_albums_tags_linkArgs<ExtArgs>
    _count?: boolean | Photos_albumsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["photos_albums"]>



  export type photos_albumsSelectScalar = {
    id_alb?: boolean
    titre?: boolean
    lien_cover?: boolean
    date?: boolean
    afficher?: boolean
    derniere_modification?: boolean
  }

  export type photos_albumsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id_alb" | "titre" | "lien_cover" | "date" | "afficher" | "derniere_modification", ExtArgs["result"]["photos_albums"]>
  export type photos_albumsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    photos_albums_link?: boolean | photos_albums$photos_albums_linkArgs<ExtArgs>
    photos_albums_tags_link?: boolean | photos_albums$photos_albums_tags_linkArgs<ExtArgs>
    _count?: boolean | Photos_albumsCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $photos_albumsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "photos_albums"
    objects: {
      photos_albums_link: Prisma.$photos_albums_linkPayload<ExtArgs>[]
      photos_albums_tags_link: Prisma.$photos_albums_tags_linkPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id_alb: number
      titre: string
      lien_cover: string
      date: Date
      afficher: boolean
      derniere_modification: Date
    }, ExtArgs["result"]["photos_albums"]>
    composites: {}
  }

  type photos_albumsGetPayload<S extends boolean | null | undefined | photos_albumsDefaultArgs> = $Result.GetResult<Prisma.$photos_albumsPayload, S>

  type photos_albumsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<photos_albumsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Photos_albumsCountAggregateInputType | true
    }

  export interface photos_albumsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['photos_albums'], meta: { name: 'photos_albums' } }
    /**
     * Find zero or one Photos_albums that matches the filter.
     * @param {photos_albumsFindUniqueArgs} args - Arguments to find a Photos_albums
     * @example
     * // Get one Photos_albums
     * const photos_albums = await prisma.photos_albums.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends photos_albumsFindUniqueArgs>(args: SelectSubset<T, photos_albumsFindUniqueArgs<ExtArgs>>): Prisma__photos_albumsClient<$Result.GetResult<Prisma.$photos_albumsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Photos_albums that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {photos_albumsFindUniqueOrThrowArgs} args - Arguments to find a Photos_albums
     * @example
     * // Get one Photos_albums
     * const photos_albums = await prisma.photos_albums.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends photos_albumsFindUniqueOrThrowArgs>(args: SelectSubset<T, photos_albumsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__photos_albumsClient<$Result.GetResult<Prisma.$photos_albumsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Photos_albums that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {photos_albumsFindFirstArgs} args - Arguments to find a Photos_albums
     * @example
     * // Get one Photos_albums
     * const photos_albums = await prisma.photos_albums.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends photos_albumsFindFirstArgs>(args?: SelectSubset<T, photos_albumsFindFirstArgs<ExtArgs>>): Prisma__photos_albumsClient<$Result.GetResult<Prisma.$photos_albumsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Photos_albums that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {photos_albumsFindFirstOrThrowArgs} args - Arguments to find a Photos_albums
     * @example
     * // Get one Photos_albums
     * const photos_albums = await prisma.photos_albums.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends photos_albumsFindFirstOrThrowArgs>(args?: SelectSubset<T, photos_albumsFindFirstOrThrowArgs<ExtArgs>>): Prisma__photos_albumsClient<$Result.GetResult<Prisma.$photos_albumsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Photos_albums that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {photos_albumsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Photos_albums
     * const photos_albums = await prisma.photos_albums.findMany()
     * 
     * // Get first 10 Photos_albums
     * const photos_albums = await prisma.photos_albums.findMany({ take: 10 })
     * 
     * // Only select the `id_alb`
     * const photos_albumsWithId_albOnly = await prisma.photos_albums.findMany({ select: { id_alb: true } })
     * 
     */
    findMany<T extends photos_albumsFindManyArgs>(args?: SelectSubset<T, photos_albumsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$photos_albumsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Photos_albums.
     * @param {photos_albumsCreateArgs} args - Arguments to create a Photos_albums.
     * @example
     * // Create one Photos_albums
     * const Photos_albums = await prisma.photos_albums.create({
     *   data: {
     *     // ... data to create a Photos_albums
     *   }
     * })
     * 
     */
    create<T extends photos_albumsCreateArgs>(args: SelectSubset<T, photos_albumsCreateArgs<ExtArgs>>): Prisma__photos_albumsClient<$Result.GetResult<Prisma.$photos_albumsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Photos_albums.
     * @param {photos_albumsCreateManyArgs} args - Arguments to create many Photos_albums.
     * @example
     * // Create many Photos_albums
     * const photos_albums = await prisma.photos_albums.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends photos_albumsCreateManyArgs>(args?: SelectSubset<T, photos_albumsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Photos_albums.
     * @param {photos_albumsDeleteArgs} args - Arguments to delete one Photos_albums.
     * @example
     * // Delete one Photos_albums
     * const Photos_albums = await prisma.photos_albums.delete({
     *   where: {
     *     // ... filter to delete one Photos_albums
     *   }
     * })
     * 
     */
    delete<T extends photos_albumsDeleteArgs>(args: SelectSubset<T, photos_albumsDeleteArgs<ExtArgs>>): Prisma__photos_albumsClient<$Result.GetResult<Prisma.$photos_albumsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Photos_albums.
     * @param {photos_albumsUpdateArgs} args - Arguments to update one Photos_albums.
     * @example
     * // Update one Photos_albums
     * const photos_albums = await prisma.photos_albums.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends photos_albumsUpdateArgs>(args: SelectSubset<T, photos_albumsUpdateArgs<ExtArgs>>): Prisma__photos_albumsClient<$Result.GetResult<Prisma.$photos_albumsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Photos_albums.
     * @param {photos_albumsDeleteManyArgs} args - Arguments to filter Photos_albums to delete.
     * @example
     * // Delete a few Photos_albums
     * const { count } = await prisma.photos_albums.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends photos_albumsDeleteManyArgs>(args?: SelectSubset<T, photos_albumsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Photos_albums.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {photos_albumsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Photos_albums
     * const photos_albums = await prisma.photos_albums.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends photos_albumsUpdateManyArgs>(args: SelectSubset<T, photos_albumsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Photos_albums.
     * @param {photos_albumsUpsertArgs} args - Arguments to update or create a Photos_albums.
     * @example
     * // Update or create a Photos_albums
     * const photos_albums = await prisma.photos_albums.upsert({
     *   create: {
     *     // ... data to create a Photos_albums
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Photos_albums we want to update
     *   }
     * })
     */
    upsert<T extends photos_albumsUpsertArgs>(args: SelectSubset<T, photos_albumsUpsertArgs<ExtArgs>>): Prisma__photos_albumsClient<$Result.GetResult<Prisma.$photos_albumsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Photos_albums.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {photos_albumsCountArgs} args - Arguments to filter Photos_albums to count.
     * @example
     * // Count the number of Photos_albums
     * const count = await prisma.photos_albums.count({
     *   where: {
     *     // ... the filter for the Photos_albums we want to count
     *   }
     * })
    **/
    count<T extends photos_albumsCountArgs>(
      args?: Subset<T, photos_albumsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Photos_albumsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Photos_albums.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Photos_albumsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Photos_albumsAggregateArgs>(args: Subset<T, Photos_albumsAggregateArgs>): Prisma.PrismaPromise<GetPhotos_albumsAggregateType<T>>

    /**
     * Group by Photos_albums.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {photos_albumsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends photos_albumsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: photos_albumsGroupByArgs['orderBy'] }
        : { orderBy?: photos_albumsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, photos_albumsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPhotos_albumsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the photos_albums model
   */
  readonly fields: photos_albumsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for photos_albums.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__photos_albumsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    photos_albums_link<T extends photos_albums$photos_albums_linkArgs<ExtArgs> = {}>(args?: Subset<T, photos_albums$photos_albums_linkArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$photos_albums_linkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    photos_albums_tags_link<T extends photos_albums$photos_albums_tags_linkArgs<ExtArgs> = {}>(args?: Subset<T, photos_albums$photos_albums_tags_linkArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$photos_albums_tags_linkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the photos_albums model
   */
  interface photos_albumsFieldRefs {
    readonly id_alb: FieldRef<"photos_albums", 'Int'>
    readonly titre: FieldRef<"photos_albums", 'String'>
    readonly lien_cover: FieldRef<"photos_albums", 'String'>
    readonly date: FieldRef<"photos_albums", 'DateTime'>
    readonly afficher: FieldRef<"photos_albums", 'Boolean'>
    readonly derniere_modification: FieldRef<"photos_albums", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * photos_albums findUnique
   */
  export type photos_albumsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos_albums
     */
    select?: photos_albumsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos_albums
     */
    omit?: photos_albumsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photos_albumsInclude<ExtArgs> | null
    /**
     * Filter, which photos_albums to fetch.
     */
    where: photos_albumsWhereUniqueInput
  }

  /**
   * photos_albums findUniqueOrThrow
   */
  export type photos_albumsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos_albums
     */
    select?: photos_albumsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos_albums
     */
    omit?: photos_albumsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photos_albumsInclude<ExtArgs> | null
    /**
     * Filter, which photos_albums to fetch.
     */
    where: photos_albumsWhereUniqueInput
  }

  /**
   * photos_albums findFirst
   */
  export type photos_albumsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos_albums
     */
    select?: photos_albumsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos_albums
     */
    omit?: photos_albumsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photos_albumsInclude<ExtArgs> | null
    /**
     * Filter, which photos_albums to fetch.
     */
    where?: photos_albumsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of photos_albums to fetch.
     */
    orderBy?: photos_albumsOrderByWithRelationInput | photos_albumsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for photos_albums.
     */
    cursor?: photos_albumsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` photos_albums from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` photos_albums.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of photos_albums.
     */
    distinct?: Photos_albumsScalarFieldEnum | Photos_albumsScalarFieldEnum[]
  }

  /**
   * photos_albums findFirstOrThrow
   */
  export type photos_albumsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos_albums
     */
    select?: photos_albumsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos_albums
     */
    omit?: photos_albumsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photos_albumsInclude<ExtArgs> | null
    /**
     * Filter, which photos_albums to fetch.
     */
    where?: photos_albumsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of photos_albums to fetch.
     */
    orderBy?: photos_albumsOrderByWithRelationInput | photos_albumsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for photos_albums.
     */
    cursor?: photos_albumsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` photos_albums from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` photos_albums.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of photos_albums.
     */
    distinct?: Photos_albumsScalarFieldEnum | Photos_albumsScalarFieldEnum[]
  }

  /**
   * photos_albums findMany
   */
  export type photos_albumsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos_albums
     */
    select?: photos_albumsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos_albums
     */
    omit?: photos_albumsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photos_albumsInclude<ExtArgs> | null
    /**
     * Filter, which photos_albums to fetch.
     */
    where?: photos_albumsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of photos_albums to fetch.
     */
    orderBy?: photos_albumsOrderByWithRelationInput | photos_albumsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing photos_albums.
     */
    cursor?: photos_albumsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` photos_albums from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` photos_albums.
     */
    skip?: number
    distinct?: Photos_albumsScalarFieldEnum | Photos_albumsScalarFieldEnum[]
  }

  /**
   * photos_albums create
   */
  export type photos_albumsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos_albums
     */
    select?: photos_albumsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos_albums
     */
    omit?: photos_albumsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photos_albumsInclude<ExtArgs> | null
    /**
     * The data needed to create a photos_albums.
     */
    data: XOR<photos_albumsCreateInput, photos_albumsUncheckedCreateInput>
  }

  /**
   * photos_albums createMany
   */
  export type photos_albumsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many photos_albums.
     */
    data: photos_albumsCreateManyInput | photos_albumsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * photos_albums update
   */
  export type photos_albumsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos_albums
     */
    select?: photos_albumsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos_albums
     */
    omit?: photos_albumsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photos_albumsInclude<ExtArgs> | null
    /**
     * The data needed to update a photos_albums.
     */
    data: XOR<photos_albumsUpdateInput, photos_albumsUncheckedUpdateInput>
    /**
     * Choose, which photos_albums to update.
     */
    where: photos_albumsWhereUniqueInput
  }

  /**
   * photos_albums updateMany
   */
  export type photos_albumsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update photos_albums.
     */
    data: XOR<photos_albumsUpdateManyMutationInput, photos_albumsUncheckedUpdateManyInput>
    /**
     * Filter which photos_albums to update
     */
    where?: photos_albumsWhereInput
    /**
     * Limit how many photos_albums to update.
     */
    limit?: number
  }

  /**
   * photos_albums upsert
   */
  export type photos_albumsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos_albums
     */
    select?: photos_albumsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos_albums
     */
    omit?: photos_albumsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photos_albumsInclude<ExtArgs> | null
    /**
     * The filter to search for the photos_albums to update in case it exists.
     */
    where: photos_albumsWhereUniqueInput
    /**
     * In case the photos_albums found by the `where` argument doesn't exist, create a new photos_albums with this data.
     */
    create: XOR<photos_albumsCreateInput, photos_albumsUncheckedCreateInput>
    /**
     * In case the photos_albums was found with the provided `where` argument, update it with this data.
     */
    update: XOR<photos_albumsUpdateInput, photos_albumsUncheckedUpdateInput>
  }

  /**
   * photos_albums delete
   */
  export type photos_albumsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos_albums
     */
    select?: photos_albumsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos_albums
     */
    omit?: photos_albumsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photos_albumsInclude<ExtArgs> | null
    /**
     * Filter which photos_albums to delete.
     */
    where: photos_albumsWhereUniqueInput
  }

  /**
   * photos_albums deleteMany
   */
  export type photos_albumsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which photos_albums to delete
     */
    where?: photos_albumsWhereInput
    /**
     * Limit how many photos_albums to delete.
     */
    limit?: number
  }

  /**
   * photos_albums.photos_albums_link
   */
  export type photos_albums$photos_albums_linkArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos_albums_link
     */
    select?: photos_albums_linkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos_albums_link
     */
    omit?: photos_albums_linkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photos_albums_linkInclude<ExtArgs> | null
    where?: photos_albums_linkWhereInput
    orderBy?: photos_albums_linkOrderByWithRelationInput | photos_albums_linkOrderByWithRelationInput[]
    cursor?: photos_albums_linkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Photos_albums_linkScalarFieldEnum | Photos_albums_linkScalarFieldEnum[]
  }

  /**
   * photos_albums.photos_albums_tags_link
   */
  export type photos_albums$photos_albums_tags_linkArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos_albums_tags_link
     */
    select?: photos_albums_tags_linkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos_albums_tags_link
     */
    omit?: photos_albums_tags_linkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photos_albums_tags_linkInclude<ExtArgs> | null
    where?: photos_albums_tags_linkWhereInput
    orderBy?: photos_albums_tags_linkOrderByWithRelationInput | photos_albums_tags_linkOrderByWithRelationInput[]
    cursor?: photos_albums_tags_linkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Photos_albums_tags_linkScalarFieldEnum | Photos_albums_tags_linkScalarFieldEnum[]
  }

  /**
   * photos_albums without action
   */
  export type photos_albumsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos_albums
     */
    select?: photos_albumsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos_albums
     */
    omit?: photos_albumsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photos_albumsInclude<ExtArgs> | null
  }


  /**
   * Model photos_albums_link
   */

  export type AggregatePhotos_albums_link = {
    _count: Photos_albums_linkCountAggregateOutputType | null
    _avg: Photos_albums_linkAvgAggregateOutputType | null
    _sum: Photos_albums_linkSumAggregateOutputType | null
    _min: Photos_albums_linkMinAggregateOutputType | null
    _max: Photos_albums_linkMaxAggregateOutputType | null
  }

  export type Photos_albums_linkAvgAggregateOutputType = {
    id_pho: number | null
    id_alb: number | null
    position: number | null
  }

  export type Photos_albums_linkSumAggregateOutputType = {
    id_pho: number | null
    id_alb: number | null
    position: number | null
  }

  export type Photos_albums_linkMinAggregateOutputType = {
    id_pho: number | null
    id_alb: number | null
    position: number | null
  }

  export type Photos_albums_linkMaxAggregateOutputType = {
    id_pho: number | null
    id_alb: number | null
    position: number | null
  }

  export type Photos_albums_linkCountAggregateOutputType = {
    id_pho: number
    id_alb: number
    position: number
    _all: number
  }


  export type Photos_albums_linkAvgAggregateInputType = {
    id_pho?: true
    id_alb?: true
    position?: true
  }

  export type Photos_albums_linkSumAggregateInputType = {
    id_pho?: true
    id_alb?: true
    position?: true
  }

  export type Photos_albums_linkMinAggregateInputType = {
    id_pho?: true
    id_alb?: true
    position?: true
  }

  export type Photos_albums_linkMaxAggregateInputType = {
    id_pho?: true
    id_alb?: true
    position?: true
  }

  export type Photos_albums_linkCountAggregateInputType = {
    id_pho?: true
    id_alb?: true
    position?: true
    _all?: true
  }

  export type Photos_albums_linkAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which photos_albums_link to aggregate.
     */
    where?: photos_albums_linkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of photos_albums_links to fetch.
     */
    orderBy?: photos_albums_linkOrderByWithRelationInput | photos_albums_linkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: photos_albums_linkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` photos_albums_links from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` photos_albums_links.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned photos_albums_links
    **/
    _count?: true | Photos_albums_linkCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Photos_albums_linkAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Photos_albums_linkSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Photos_albums_linkMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Photos_albums_linkMaxAggregateInputType
  }

  export type GetPhotos_albums_linkAggregateType<T extends Photos_albums_linkAggregateArgs> = {
        [P in keyof T & keyof AggregatePhotos_albums_link]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePhotos_albums_link[P]>
      : GetScalarType<T[P], AggregatePhotos_albums_link[P]>
  }




  export type photos_albums_linkGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: photos_albums_linkWhereInput
    orderBy?: photos_albums_linkOrderByWithAggregationInput | photos_albums_linkOrderByWithAggregationInput[]
    by: Photos_albums_linkScalarFieldEnum[] | Photos_albums_linkScalarFieldEnum
    having?: photos_albums_linkScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Photos_albums_linkCountAggregateInputType | true
    _avg?: Photos_albums_linkAvgAggregateInputType
    _sum?: Photos_albums_linkSumAggregateInputType
    _min?: Photos_albums_linkMinAggregateInputType
    _max?: Photos_albums_linkMaxAggregateInputType
  }

  export type Photos_albums_linkGroupByOutputType = {
    id_pho: number
    id_alb: number
    position: number | null
    _count: Photos_albums_linkCountAggregateOutputType | null
    _avg: Photos_albums_linkAvgAggregateOutputType | null
    _sum: Photos_albums_linkSumAggregateOutputType | null
    _min: Photos_albums_linkMinAggregateOutputType | null
    _max: Photos_albums_linkMaxAggregateOutputType | null
  }

  type GetPhotos_albums_linkGroupByPayload<T extends photos_albums_linkGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Photos_albums_linkGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Photos_albums_linkGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Photos_albums_linkGroupByOutputType[P]>
            : GetScalarType<T[P], Photos_albums_linkGroupByOutputType[P]>
        }
      >
    >


  export type photos_albums_linkSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_pho?: boolean
    id_alb?: boolean
    position?: boolean
    photos?: boolean | photosDefaultArgs<ExtArgs>
    photos_albums?: boolean | photos_albumsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["photos_albums_link"]>



  export type photos_albums_linkSelectScalar = {
    id_pho?: boolean
    id_alb?: boolean
    position?: boolean
  }

  export type photos_albums_linkOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id_pho" | "id_alb" | "position", ExtArgs["result"]["photos_albums_link"]>
  export type photos_albums_linkInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    photos?: boolean | photosDefaultArgs<ExtArgs>
    photos_albums?: boolean | photos_albumsDefaultArgs<ExtArgs>
  }

  export type $photos_albums_linkPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "photos_albums_link"
    objects: {
      photos: Prisma.$photosPayload<ExtArgs>
      photos_albums: Prisma.$photos_albumsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id_pho: number
      id_alb: number
      position: number | null
    }, ExtArgs["result"]["photos_albums_link"]>
    composites: {}
  }

  type photos_albums_linkGetPayload<S extends boolean | null | undefined | photos_albums_linkDefaultArgs> = $Result.GetResult<Prisma.$photos_albums_linkPayload, S>

  type photos_albums_linkCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<photos_albums_linkFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Photos_albums_linkCountAggregateInputType | true
    }

  export interface photos_albums_linkDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['photos_albums_link'], meta: { name: 'photos_albums_link' } }
    /**
     * Find zero or one Photos_albums_link that matches the filter.
     * @param {photos_albums_linkFindUniqueArgs} args - Arguments to find a Photos_albums_link
     * @example
     * // Get one Photos_albums_link
     * const photos_albums_link = await prisma.photos_albums_link.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends photos_albums_linkFindUniqueArgs>(args: SelectSubset<T, photos_albums_linkFindUniqueArgs<ExtArgs>>): Prisma__photos_albums_linkClient<$Result.GetResult<Prisma.$photos_albums_linkPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Photos_albums_link that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {photos_albums_linkFindUniqueOrThrowArgs} args - Arguments to find a Photos_albums_link
     * @example
     * // Get one Photos_albums_link
     * const photos_albums_link = await prisma.photos_albums_link.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends photos_albums_linkFindUniqueOrThrowArgs>(args: SelectSubset<T, photos_albums_linkFindUniqueOrThrowArgs<ExtArgs>>): Prisma__photos_albums_linkClient<$Result.GetResult<Prisma.$photos_albums_linkPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Photos_albums_link that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {photos_albums_linkFindFirstArgs} args - Arguments to find a Photos_albums_link
     * @example
     * // Get one Photos_albums_link
     * const photos_albums_link = await prisma.photos_albums_link.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends photos_albums_linkFindFirstArgs>(args?: SelectSubset<T, photos_albums_linkFindFirstArgs<ExtArgs>>): Prisma__photos_albums_linkClient<$Result.GetResult<Prisma.$photos_albums_linkPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Photos_albums_link that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {photos_albums_linkFindFirstOrThrowArgs} args - Arguments to find a Photos_albums_link
     * @example
     * // Get one Photos_albums_link
     * const photos_albums_link = await prisma.photos_albums_link.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends photos_albums_linkFindFirstOrThrowArgs>(args?: SelectSubset<T, photos_albums_linkFindFirstOrThrowArgs<ExtArgs>>): Prisma__photos_albums_linkClient<$Result.GetResult<Prisma.$photos_albums_linkPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Photos_albums_links that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {photos_albums_linkFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Photos_albums_links
     * const photos_albums_links = await prisma.photos_albums_link.findMany()
     * 
     * // Get first 10 Photos_albums_links
     * const photos_albums_links = await prisma.photos_albums_link.findMany({ take: 10 })
     * 
     * // Only select the `id_pho`
     * const photos_albums_linkWithId_phoOnly = await prisma.photos_albums_link.findMany({ select: { id_pho: true } })
     * 
     */
    findMany<T extends photos_albums_linkFindManyArgs>(args?: SelectSubset<T, photos_albums_linkFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$photos_albums_linkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Photos_albums_link.
     * @param {photos_albums_linkCreateArgs} args - Arguments to create a Photos_albums_link.
     * @example
     * // Create one Photos_albums_link
     * const Photos_albums_link = await prisma.photos_albums_link.create({
     *   data: {
     *     // ... data to create a Photos_albums_link
     *   }
     * })
     * 
     */
    create<T extends photos_albums_linkCreateArgs>(args: SelectSubset<T, photos_albums_linkCreateArgs<ExtArgs>>): Prisma__photos_albums_linkClient<$Result.GetResult<Prisma.$photos_albums_linkPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Photos_albums_links.
     * @param {photos_albums_linkCreateManyArgs} args - Arguments to create many Photos_albums_links.
     * @example
     * // Create many Photos_albums_links
     * const photos_albums_link = await prisma.photos_albums_link.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends photos_albums_linkCreateManyArgs>(args?: SelectSubset<T, photos_albums_linkCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Photos_albums_link.
     * @param {photos_albums_linkDeleteArgs} args - Arguments to delete one Photos_albums_link.
     * @example
     * // Delete one Photos_albums_link
     * const Photos_albums_link = await prisma.photos_albums_link.delete({
     *   where: {
     *     // ... filter to delete one Photos_albums_link
     *   }
     * })
     * 
     */
    delete<T extends photos_albums_linkDeleteArgs>(args: SelectSubset<T, photos_albums_linkDeleteArgs<ExtArgs>>): Prisma__photos_albums_linkClient<$Result.GetResult<Prisma.$photos_albums_linkPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Photos_albums_link.
     * @param {photos_albums_linkUpdateArgs} args - Arguments to update one Photos_albums_link.
     * @example
     * // Update one Photos_albums_link
     * const photos_albums_link = await prisma.photos_albums_link.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends photos_albums_linkUpdateArgs>(args: SelectSubset<T, photos_albums_linkUpdateArgs<ExtArgs>>): Prisma__photos_albums_linkClient<$Result.GetResult<Prisma.$photos_albums_linkPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Photos_albums_links.
     * @param {photos_albums_linkDeleteManyArgs} args - Arguments to filter Photos_albums_links to delete.
     * @example
     * // Delete a few Photos_albums_links
     * const { count } = await prisma.photos_albums_link.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends photos_albums_linkDeleteManyArgs>(args?: SelectSubset<T, photos_albums_linkDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Photos_albums_links.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {photos_albums_linkUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Photos_albums_links
     * const photos_albums_link = await prisma.photos_albums_link.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends photos_albums_linkUpdateManyArgs>(args: SelectSubset<T, photos_albums_linkUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Photos_albums_link.
     * @param {photos_albums_linkUpsertArgs} args - Arguments to update or create a Photos_albums_link.
     * @example
     * // Update or create a Photos_albums_link
     * const photos_albums_link = await prisma.photos_albums_link.upsert({
     *   create: {
     *     // ... data to create a Photos_albums_link
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Photos_albums_link we want to update
     *   }
     * })
     */
    upsert<T extends photos_albums_linkUpsertArgs>(args: SelectSubset<T, photos_albums_linkUpsertArgs<ExtArgs>>): Prisma__photos_albums_linkClient<$Result.GetResult<Prisma.$photos_albums_linkPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Photos_albums_links.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {photos_albums_linkCountArgs} args - Arguments to filter Photos_albums_links to count.
     * @example
     * // Count the number of Photos_albums_links
     * const count = await prisma.photos_albums_link.count({
     *   where: {
     *     // ... the filter for the Photos_albums_links we want to count
     *   }
     * })
    **/
    count<T extends photos_albums_linkCountArgs>(
      args?: Subset<T, photos_albums_linkCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Photos_albums_linkCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Photos_albums_link.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Photos_albums_linkAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Photos_albums_linkAggregateArgs>(args: Subset<T, Photos_albums_linkAggregateArgs>): Prisma.PrismaPromise<GetPhotos_albums_linkAggregateType<T>>

    /**
     * Group by Photos_albums_link.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {photos_albums_linkGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends photos_albums_linkGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: photos_albums_linkGroupByArgs['orderBy'] }
        : { orderBy?: photos_albums_linkGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, photos_albums_linkGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPhotos_albums_linkGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the photos_albums_link model
   */
  readonly fields: photos_albums_linkFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for photos_albums_link.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__photos_albums_linkClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    photos<T extends photosDefaultArgs<ExtArgs> = {}>(args?: Subset<T, photosDefaultArgs<ExtArgs>>): Prisma__photosClient<$Result.GetResult<Prisma.$photosPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    photos_albums<T extends photos_albumsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, photos_albumsDefaultArgs<ExtArgs>>): Prisma__photos_albumsClient<$Result.GetResult<Prisma.$photos_albumsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the photos_albums_link model
   */
  interface photos_albums_linkFieldRefs {
    readonly id_pho: FieldRef<"photos_albums_link", 'Int'>
    readonly id_alb: FieldRef<"photos_albums_link", 'Int'>
    readonly position: FieldRef<"photos_albums_link", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * photos_albums_link findUnique
   */
  export type photos_albums_linkFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos_albums_link
     */
    select?: photos_albums_linkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos_albums_link
     */
    omit?: photos_albums_linkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photos_albums_linkInclude<ExtArgs> | null
    /**
     * Filter, which photos_albums_link to fetch.
     */
    where: photos_albums_linkWhereUniqueInput
  }

  /**
   * photos_albums_link findUniqueOrThrow
   */
  export type photos_albums_linkFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos_albums_link
     */
    select?: photos_albums_linkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos_albums_link
     */
    omit?: photos_albums_linkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photos_albums_linkInclude<ExtArgs> | null
    /**
     * Filter, which photos_albums_link to fetch.
     */
    where: photos_albums_linkWhereUniqueInput
  }

  /**
   * photos_albums_link findFirst
   */
  export type photos_albums_linkFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos_albums_link
     */
    select?: photos_albums_linkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos_albums_link
     */
    omit?: photos_albums_linkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photos_albums_linkInclude<ExtArgs> | null
    /**
     * Filter, which photos_albums_link to fetch.
     */
    where?: photos_albums_linkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of photos_albums_links to fetch.
     */
    orderBy?: photos_albums_linkOrderByWithRelationInput | photos_albums_linkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for photos_albums_links.
     */
    cursor?: photos_albums_linkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` photos_albums_links from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` photos_albums_links.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of photos_albums_links.
     */
    distinct?: Photos_albums_linkScalarFieldEnum | Photos_albums_linkScalarFieldEnum[]
  }

  /**
   * photos_albums_link findFirstOrThrow
   */
  export type photos_albums_linkFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos_albums_link
     */
    select?: photos_albums_linkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos_albums_link
     */
    omit?: photos_albums_linkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photos_albums_linkInclude<ExtArgs> | null
    /**
     * Filter, which photos_albums_link to fetch.
     */
    where?: photos_albums_linkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of photos_albums_links to fetch.
     */
    orderBy?: photos_albums_linkOrderByWithRelationInput | photos_albums_linkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for photos_albums_links.
     */
    cursor?: photos_albums_linkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` photos_albums_links from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` photos_albums_links.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of photos_albums_links.
     */
    distinct?: Photos_albums_linkScalarFieldEnum | Photos_albums_linkScalarFieldEnum[]
  }

  /**
   * photos_albums_link findMany
   */
  export type photos_albums_linkFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos_albums_link
     */
    select?: photos_albums_linkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos_albums_link
     */
    omit?: photos_albums_linkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photos_albums_linkInclude<ExtArgs> | null
    /**
     * Filter, which photos_albums_links to fetch.
     */
    where?: photos_albums_linkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of photos_albums_links to fetch.
     */
    orderBy?: photos_albums_linkOrderByWithRelationInput | photos_albums_linkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing photos_albums_links.
     */
    cursor?: photos_albums_linkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` photos_albums_links from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` photos_albums_links.
     */
    skip?: number
    distinct?: Photos_albums_linkScalarFieldEnum | Photos_albums_linkScalarFieldEnum[]
  }

  /**
   * photos_albums_link create
   */
  export type photos_albums_linkCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos_albums_link
     */
    select?: photos_albums_linkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos_albums_link
     */
    omit?: photos_albums_linkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photos_albums_linkInclude<ExtArgs> | null
    /**
     * The data needed to create a photos_albums_link.
     */
    data: XOR<photos_albums_linkCreateInput, photos_albums_linkUncheckedCreateInput>
  }

  /**
   * photos_albums_link createMany
   */
  export type photos_albums_linkCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many photos_albums_links.
     */
    data: photos_albums_linkCreateManyInput | photos_albums_linkCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * photos_albums_link update
   */
  export type photos_albums_linkUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos_albums_link
     */
    select?: photos_albums_linkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos_albums_link
     */
    omit?: photos_albums_linkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photos_albums_linkInclude<ExtArgs> | null
    /**
     * The data needed to update a photos_albums_link.
     */
    data: XOR<photos_albums_linkUpdateInput, photos_albums_linkUncheckedUpdateInput>
    /**
     * Choose, which photos_albums_link to update.
     */
    where: photos_albums_linkWhereUniqueInput
  }

  /**
   * photos_albums_link updateMany
   */
  export type photos_albums_linkUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update photos_albums_links.
     */
    data: XOR<photos_albums_linkUpdateManyMutationInput, photos_albums_linkUncheckedUpdateManyInput>
    /**
     * Filter which photos_albums_links to update
     */
    where?: photos_albums_linkWhereInput
    /**
     * Limit how many photos_albums_links to update.
     */
    limit?: number
  }

  /**
   * photos_albums_link upsert
   */
  export type photos_albums_linkUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos_albums_link
     */
    select?: photos_albums_linkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos_albums_link
     */
    omit?: photos_albums_linkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photos_albums_linkInclude<ExtArgs> | null
    /**
     * The filter to search for the photos_albums_link to update in case it exists.
     */
    where: photos_albums_linkWhereUniqueInput
    /**
     * In case the photos_albums_link found by the `where` argument doesn't exist, create a new photos_albums_link with this data.
     */
    create: XOR<photos_albums_linkCreateInput, photos_albums_linkUncheckedCreateInput>
    /**
     * In case the photos_albums_link was found with the provided `where` argument, update it with this data.
     */
    update: XOR<photos_albums_linkUpdateInput, photos_albums_linkUncheckedUpdateInput>
  }

  /**
   * photos_albums_link delete
   */
  export type photos_albums_linkDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos_albums_link
     */
    select?: photos_albums_linkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos_albums_link
     */
    omit?: photos_albums_linkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photos_albums_linkInclude<ExtArgs> | null
    /**
     * Filter which photos_albums_link to delete.
     */
    where: photos_albums_linkWhereUniqueInput
  }

  /**
   * photos_albums_link deleteMany
   */
  export type photos_albums_linkDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which photos_albums_links to delete
     */
    where?: photos_albums_linkWhereInput
    /**
     * Limit how many photos_albums_links to delete.
     */
    limit?: number
  }

  /**
   * photos_albums_link without action
   */
  export type photos_albums_linkDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos_albums_link
     */
    select?: photos_albums_linkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos_albums_link
     */
    omit?: photos_albums_linkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photos_albums_linkInclude<ExtArgs> | null
  }


  /**
   * Model photos_albums_tags_link
   */

  export type AggregatePhotos_albums_tags_link = {
    _count: Photos_albums_tags_linkCountAggregateOutputType | null
    _avg: Photos_albums_tags_linkAvgAggregateOutputType | null
    _sum: Photos_albums_tags_linkSumAggregateOutputType | null
    _min: Photos_albums_tags_linkMinAggregateOutputType | null
    _max: Photos_albums_tags_linkMaxAggregateOutputType | null
  }

  export type Photos_albums_tags_linkAvgAggregateOutputType = {
    id_alb: number | null
    id_tags: number | null
  }

  export type Photos_albums_tags_linkSumAggregateOutputType = {
    id_alb: number | null
    id_tags: number | null
  }

  export type Photos_albums_tags_linkMinAggregateOutputType = {
    id_alb: number | null
    id_tags: number | null
  }

  export type Photos_albums_tags_linkMaxAggregateOutputType = {
    id_alb: number | null
    id_tags: number | null
  }

  export type Photos_albums_tags_linkCountAggregateOutputType = {
    id_alb: number
    id_tags: number
    _all: number
  }


  export type Photos_albums_tags_linkAvgAggregateInputType = {
    id_alb?: true
    id_tags?: true
  }

  export type Photos_albums_tags_linkSumAggregateInputType = {
    id_alb?: true
    id_tags?: true
  }

  export type Photos_albums_tags_linkMinAggregateInputType = {
    id_alb?: true
    id_tags?: true
  }

  export type Photos_albums_tags_linkMaxAggregateInputType = {
    id_alb?: true
    id_tags?: true
  }

  export type Photos_albums_tags_linkCountAggregateInputType = {
    id_alb?: true
    id_tags?: true
    _all?: true
  }

  export type Photos_albums_tags_linkAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which photos_albums_tags_link to aggregate.
     */
    where?: photos_albums_tags_linkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of photos_albums_tags_links to fetch.
     */
    orderBy?: photos_albums_tags_linkOrderByWithRelationInput | photos_albums_tags_linkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: photos_albums_tags_linkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` photos_albums_tags_links from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` photos_albums_tags_links.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned photos_albums_tags_links
    **/
    _count?: true | Photos_albums_tags_linkCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Photos_albums_tags_linkAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Photos_albums_tags_linkSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Photos_albums_tags_linkMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Photos_albums_tags_linkMaxAggregateInputType
  }

  export type GetPhotos_albums_tags_linkAggregateType<T extends Photos_albums_tags_linkAggregateArgs> = {
        [P in keyof T & keyof AggregatePhotos_albums_tags_link]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePhotos_albums_tags_link[P]>
      : GetScalarType<T[P], AggregatePhotos_albums_tags_link[P]>
  }




  export type photos_albums_tags_linkGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: photos_albums_tags_linkWhereInput
    orderBy?: photos_albums_tags_linkOrderByWithAggregationInput | photos_albums_tags_linkOrderByWithAggregationInput[]
    by: Photos_albums_tags_linkScalarFieldEnum[] | Photos_albums_tags_linkScalarFieldEnum
    having?: photos_albums_tags_linkScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Photos_albums_tags_linkCountAggregateInputType | true
    _avg?: Photos_albums_tags_linkAvgAggregateInputType
    _sum?: Photos_albums_tags_linkSumAggregateInputType
    _min?: Photos_albums_tags_linkMinAggregateInputType
    _max?: Photos_albums_tags_linkMaxAggregateInputType
  }

  export type Photos_albums_tags_linkGroupByOutputType = {
    id_alb: number
    id_tags: number
    _count: Photos_albums_tags_linkCountAggregateOutputType | null
    _avg: Photos_albums_tags_linkAvgAggregateOutputType | null
    _sum: Photos_albums_tags_linkSumAggregateOutputType | null
    _min: Photos_albums_tags_linkMinAggregateOutputType | null
    _max: Photos_albums_tags_linkMaxAggregateOutputType | null
  }

  type GetPhotos_albums_tags_linkGroupByPayload<T extends photos_albums_tags_linkGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Photos_albums_tags_linkGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Photos_albums_tags_linkGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Photos_albums_tags_linkGroupByOutputType[P]>
            : GetScalarType<T[P], Photos_albums_tags_linkGroupByOutputType[P]>
        }
      >
    >


  export type photos_albums_tags_linkSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_alb?: boolean
    id_tags?: boolean
    photos_albums?: boolean | photos_albumsDefaultArgs<ExtArgs>
    photos_tags?: boolean | photos_tagsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["photos_albums_tags_link"]>



  export type photos_albums_tags_linkSelectScalar = {
    id_alb?: boolean
    id_tags?: boolean
  }

  export type photos_albums_tags_linkOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id_alb" | "id_tags", ExtArgs["result"]["photos_albums_tags_link"]>
  export type photos_albums_tags_linkInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    photos_albums?: boolean | photos_albumsDefaultArgs<ExtArgs>
    photos_tags?: boolean | photos_tagsDefaultArgs<ExtArgs>
  }

  export type $photos_albums_tags_linkPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "photos_albums_tags_link"
    objects: {
      photos_albums: Prisma.$photos_albumsPayload<ExtArgs>
      photos_tags: Prisma.$photos_tagsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id_alb: number
      id_tags: number
    }, ExtArgs["result"]["photos_albums_tags_link"]>
    composites: {}
  }

  type photos_albums_tags_linkGetPayload<S extends boolean | null | undefined | photos_albums_tags_linkDefaultArgs> = $Result.GetResult<Prisma.$photos_albums_tags_linkPayload, S>

  type photos_albums_tags_linkCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<photos_albums_tags_linkFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Photos_albums_tags_linkCountAggregateInputType | true
    }

  export interface photos_albums_tags_linkDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['photos_albums_tags_link'], meta: { name: 'photos_albums_tags_link' } }
    /**
     * Find zero or one Photos_albums_tags_link that matches the filter.
     * @param {photos_albums_tags_linkFindUniqueArgs} args - Arguments to find a Photos_albums_tags_link
     * @example
     * // Get one Photos_albums_tags_link
     * const photos_albums_tags_link = await prisma.photos_albums_tags_link.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends photos_albums_tags_linkFindUniqueArgs>(args: SelectSubset<T, photos_albums_tags_linkFindUniqueArgs<ExtArgs>>): Prisma__photos_albums_tags_linkClient<$Result.GetResult<Prisma.$photos_albums_tags_linkPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Photos_albums_tags_link that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {photos_albums_tags_linkFindUniqueOrThrowArgs} args - Arguments to find a Photos_albums_tags_link
     * @example
     * // Get one Photos_albums_tags_link
     * const photos_albums_tags_link = await prisma.photos_albums_tags_link.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends photos_albums_tags_linkFindUniqueOrThrowArgs>(args: SelectSubset<T, photos_albums_tags_linkFindUniqueOrThrowArgs<ExtArgs>>): Prisma__photos_albums_tags_linkClient<$Result.GetResult<Prisma.$photos_albums_tags_linkPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Photos_albums_tags_link that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {photos_albums_tags_linkFindFirstArgs} args - Arguments to find a Photos_albums_tags_link
     * @example
     * // Get one Photos_albums_tags_link
     * const photos_albums_tags_link = await prisma.photos_albums_tags_link.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends photos_albums_tags_linkFindFirstArgs>(args?: SelectSubset<T, photos_albums_tags_linkFindFirstArgs<ExtArgs>>): Prisma__photos_albums_tags_linkClient<$Result.GetResult<Prisma.$photos_albums_tags_linkPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Photos_albums_tags_link that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {photos_albums_tags_linkFindFirstOrThrowArgs} args - Arguments to find a Photos_albums_tags_link
     * @example
     * // Get one Photos_albums_tags_link
     * const photos_albums_tags_link = await prisma.photos_albums_tags_link.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends photos_albums_tags_linkFindFirstOrThrowArgs>(args?: SelectSubset<T, photos_albums_tags_linkFindFirstOrThrowArgs<ExtArgs>>): Prisma__photos_albums_tags_linkClient<$Result.GetResult<Prisma.$photos_albums_tags_linkPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Photos_albums_tags_links that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {photos_albums_tags_linkFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Photos_albums_tags_links
     * const photos_albums_tags_links = await prisma.photos_albums_tags_link.findMany()
     * 
     * // Get first 10 Photos_albums_tags_links
     * const photos_albums_tags_links = await prisma.photos_albums_tags_link.findMany({ take: 10 })
     * 
     * // Only select the `id_alb`
     * const photos_albums_tags_linkWithId_albOnly = await prisma.photos_albums_tags_link.findMany({ select: { id_alb: true } })
     * 
     */
    findMany<T extends photos_albums_tags_linkFindManyArgs>(args?: SelectSubset<T, photos_albums_tags_linkFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$photos_albums_tags_linkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Photos_albums_tags_link.
     * @param {photos_albums_tags_linkCreateArgs} args - Arguments to create a Photos_albums_tags_link.
     * @example
     * // Create one Photos_albums_tags_link
     * const Photos_albums_tags_link = await prisma.photos_albums_tags_link.create({
     *   data: {
     *     // ... data to create a Photos_albums_tags_link
     *   }
     * })
     * 
     */
    create<T extends photos_albums_tags_linkCreateArgs>(args: SelectSubset<T, photos_albums_tags_linkCreateArgs<ExtArgs>>): Prisma__photos_albums_tags_linkClient<$Result.GetResult<Prisma.$photos_albums_tags_linkPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Photos_albums_tags_links.
     * @param {photos_albums_tags_linkCreateManyArgs} args - Arguments to create many Photos_albums_tags_links.
     * @example
     * // Create many Photos_albums_tags_links
     * const photos_albums_tags_link = await prisma.photos_albums_tags_link.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends photos_albums_tags_linkCreateManyArgs>(args?: SelectSubset<T, photos_albums_tags_linkCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Photos_albums_tags_link.
     * @param {photos_albums_tags_linkDeleteArgs} args - Arguments to delete one Photos_albums_tags_link.
     * @example
     * // Delete one Photos_albums_tags_link
     * const Photos_albums_tags_link = await prisma.photos_albums_tags_link.delete({
     *   where: {
     *     // ... filter to delete one Photos_albums_tags_link
     *   }
     * })
     * 
     */
    delete<T extends photos_albums_tags_linkDeleteArgs>(args: SelectSubset<T, photos_albums_tags_linkDeleteArgs<ExtArgs>>): Prisma__photos_albums_tags_linkClient<$Result.GetResult<Prisma.$photos_albums_tags_linkPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Photos_albums_tags_link.
     * @param {photos_albums_tags_linkUpdateArgs} args - Arguments to update one Photos_albums_tags_link.
     * @example
     * // Update one Photos_albums_tags_link
     * const photos_albums_tags_link = await prisma.photos_albums_tags_link.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends photos_albums_tags_linkUpdateArgs>(args: SelectSubset<T, photos_albums_tags_linkUpdateArgs<ExtArgs>>): Prisma__photos_albums_tags_linkClient<$Result.GetResult<Prisma.$photos_albums_tags_linkPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Photos_albums_tags_links.
     * @param {photos_albums_tags_linkDeleteManyArgs} args - Arguments to filter Photos_albums_tags_links to delete.
     * @example
     * // Delete a few Photos_albums_tags_links
     * const { count } = await prisma.photos_albums_tags_link.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends photos_albums_tags_linkDeleteManyArgs>(args?: SelectSubset<T, photos_albums_tags_linkDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Photos_albums_tags_links.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {photos_albums_tags_linkUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Photos_albums_tags_links
     * const photos_albums_tags_link = await prisma.photos_albums_tags_link.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends photos_albums_tags_linkUpdateManyArgs>(args: SelectSubset<T, photos_albums_tags_linkUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Photos_albums_tags_link.
     * @param {photos_albums_tags_linkUpsertArgs} args - Arguments to update or create a Photos_albums_tags_link.
     * @example
     * // Update or create a Photos_albums_tags_link
     * const photos_albums_tags_link = await prisma.photos_albums_tags_link.upsert({
     *   create: {
     *     // ... data to create a Photos_albums_tags_link
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Photos_albums_tags_link we want to update
     *   }
     * })
     */
    upsert<T extends photos_albums_tags_linkUpsertArgs>(args: SelectSubset<T, photos_albums_tags_linkUpsertArgs<ExtArgs>>): Prisma__photos_albums_tags_linkClient<$Result.GetResult<Prisma.$photos_albums_tags_linkPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Photos_albums_tags_links.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {photos_albums_tags_linkCountArgs} args - Arguments to filter Photos_albums_tags_links to count.
     * @example
     * // Count the number of Photos_albums_tags_links
     * const count = await prisma.photos_albums_tags_link.count({
     *   where: {
     *     // ... the filter for the Photos_albums_tags_links we want to count
     *   }
     * })
    **/
    count<T extends photos_albums_tags_linkCountArgs>(
      args?: Subset<T, photos_albums_tags_linkCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Photos_albums_tags_linkCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Photos_albums_tags_link.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Photos_albums_tags_linkAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Photos_albums_tags_linkAggregateArgs>(args: Subset<T, Photos_albums_tags_linkAggregateArgs>): Prisma.PrismaPromise<GetPhotos_albums_tags_linkAggregateType<T>>

    /**
     * Group by Photos_albums_tags_link.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {photos_albums_tags_linkGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends photos_albums_tags_linkGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: photos_albums_tags_linkGroupByArgs['orderBy'] }
        : { orderBy?: photos_albums_tags_linkGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, photos_albums_tags_linkGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPhotos_albums_tags_linkGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the photos_albums_tags_link model
   */
  readonly fields: photos_albums_tags_linkFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for photos_albums_tags_link.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__photos_albums_tags_linkClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    photos_albums<T extends photos_albumsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, photos_albumsDefaultArgs<ExtArgs>>): Prisma__photos_albumsClient<$Result.GetResult<Prisma.$photos_albumsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    photos_tags<T extends photos_tagsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, photos_tagsDefaultArgs<ExtArgs>>): Prisma__photos_tagsClient<$Result.GetResult<Prisma.$photos_tagsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the photos_albums_tags_link model
   */
  interface photos_albums_tags_linkFieldRefs {
    readonly id_alb: FieldRef<"photos_albums_tags_link", 'Int'>
    readonly id_tags: FieldRef<"photos_albums_tags_link", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * photos_albums_tags_link findUnique
   */
  export type photos_albums_tags_linkFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos_albums_tags_link
     */
    select?: photos_albums_tags_linkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos_albums_tags_link
     */
    omit?: photos_albums_tags_linkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photos_albums_tags_linkInclude<ExtArgs> | null
    /**
     * Filter, which photos_albums_tags_link to fetch.
     */
    where: photos_albums_tags_linkWhereUniqueInput
  }

  /**
   * photos_albums_tags_link findUniqueOrThrow
   */
  export type photos_albums_tags_linkFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos_albums_tags_link
     */
    select?: photos_albums_tags_linkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos_albums_tags_link
     */
    omit?: photos_albums_tags_linkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photos_albums_tags_linkInclude<ExtArgs> | null
    /**
     * Filter, which photos_albums_tags_link to fetch.
     */
    where: photos_albums_tags_linkWhereUniqueInput
  }

  /**
   * photos_albums_tags_link findFirst
   */
  export type photos_albums_tags_linkFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos_albums_tags_link
     */
    select?: photos_albums_tags_linkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos_albums_tags_link
     */
    omit?: photos_albums_tags_linkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photos_albums_tags_linkInclude<ExtArgs> | null
    /**
     * Filter, which photos_albums_tags_link to fetch.
     */
    where?: photos_albums_tags_linkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of photos_albums_tags_links to fetch.
     */
    orderBy?: photos_albums_tags_linkOrderByWithRelationInput | photos_albums_tags_linkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for photos_albums_tags_links.
     */
    cursor?: photos_albums_tags_linkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` photos_albums_tags_links from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` photos_albums_tags_links.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of photos_albums_tags_links.
     */
    distinct?: Photos_albums_tags_linkScalarFieldEnum | Photos_albums_tags_linkScalarFieldEnum[]
  }

  /**
   * photos_albums_tags_link findFirstOrThrow
   */
  export type photos_albums_tags_linkFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos_albums_tags_link
     */
    select?: photos_albums_tags_linkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos_albums_tags_link
     */
    omit?: photos_albums_tags_linkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photos_albums_tags_linkInclude<ExtArgs> | null
    /**
     * Filter, which photos_albums_tags_link to fetch.
     */
    where?: photos_albums_tags_linkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of photos_albums_tags_links to fetch.
     */
    orderBy?: photos_albums_tags_linkOrderByWithRelationInput | photos_albums_tags_linkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for photos_albums_tags_links.
     */
    cursor?: photos_albums_tags_linkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` photos_albums_tags_links from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` photos_albums_tags_links.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of photos_albums_tags_links.
     */
    distinct?: Photos_albums_tags_linkScalarFieldEnum | Photos_albums_tags_linkScalarFieldEnum[]
  }

  /**
   * photos_albums_tags_link findMany
   */
  export type photos_albums_tags_linkFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos_albums_tags_link
     */
    select?: photos_albums_tags_linkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos_albums_tags_link
     */
    omit?: photos_albums_tags_linkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photos_albums_tags_linkInclude<ExtArgs> | null
    /**
     * Filter, which photos_albums_tags_links to fetch.
     */
    where?: photos_albums_tags_linkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of photos_albums_tags_links to fetch.
     */
    orderBy?: photos_albums_tags_linkOrderByWithRelationInput | photos_albums_tags_linkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing photos_albums_tags_links.
     */
    cursor?: photos_albums_tags_linkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` photos_albums_tags_links from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` photos_albums_tags_links.
     */
    skip?: number
    distinct?: Photos_albums_tags_linkScalarFieldEnum | Photos_albums_tags_linkScalarFieldEnum[]
  }

  /**
   * photos_albums_tags_link create
   */
  export type photos_albums_tags_linkCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos_albums_tags_link
     */
    select?: photos_albums_tags_linkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos_albums_tags_link
     */
    omit?: photos_albums_tags_linkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photos_albums_tags_linkInclude<ExtArgs> | null
    /**
     * The data needed to create a photos_albums_tags_link.
     */
    data: XOR<photos_albums_tags_linkCreateInput, photos_albums_tags_linkUncheckedCreateInput>
  }

  /**
   * photos_albums_tags_link createMany
   */
  export type photos_albums_tags_linkCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many photos_albums_tags_links.
     */
    data: photos_albums_tags_linkCreateManyInput | photos_albums_tags_linkCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * photos_albums_tags_link update
   */
  export type photos_albums_tags_linkUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos_albums_tags_link
     */
    select?: photos_albums_tags_linkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos_albums_tags_link
     */
    omit?: photos_albums_tags_linkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photos_albums_tags_linkInclude<ExtArgs> | null
    /**
     * The data needed to update a photos_albums_tags_link.
     */
    data: XOR<photos_albums_tags_linkUpdateInput, photos_albums_tags_linkUncheckedUpdateInput>
    /**
     * Choose, which photos_albums_tags_link to update.
     */
    where: photos_albums_tags_linkWhereUniqueInput
  }

  /**
   * photos_albums_tags_link updateMany
   */
  export type photos_albums_tags_linkUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update photos_albums_tags_links.
     */
    data: XOR<photos_albums_tags_linkUpdateManyMutationInput, photos_albums_tags_linkUncheckedUpdateManyInput>
    /**
     * Filter which photos_albums_tags_links to update
     */
    where?: photos_albums_tags_linkWhereInput
    /**
     * Limit how many photos_albums_tags_links to update.
     */
    limit?: number
  }

  /**
   * photos_albums_tags_link upsert
   */
  export type photos_albums_tags_linkUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos_albums_tags_link
     */
    select?: photos_albums_tags_linkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos_albums_tags_link
     */
    omit?: photos_albums_tags_linkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photos_albums_tags_linkInclude<ExtArgs> | null
    /**
     * The filter to search for the photos_albums_tags_link to update in case it exists.
     */
    where: photos_albums_tags_linkWhereUniqueInput
    /**
     * In case the photos_albums_tags_link found by the `where` argument doesn't exist, create a new photos_albums_tags_link with this data.
     */
    create: XOR<photos_albums_tags_linkCreateInput, photos_albums_tags_linkUncheckedCreateInput>
    /**
     * In case the photos_albums_tags_link was found with the provided `where` argument, update it with this data.
     */
    update: XOR<photos_albums_tags_linkUpdateInput, photos_albums_tags_linkUncheckedUpdateInput>
  }

  /**
   * photos_albums_tags_link delete
   */
  export type photos_albums_tags_linkDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos_albums_tags_link
     */
    select?: photos_albums_tags_linkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos_albums_tags_link
     */
    omit?: photos_albums_tags_linkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photos_albums_tags_linkInclude<ExtArgs> | null
    /**
     * Filter which photos_albums_tags_link to delete.
     */
    where: photos_albums_tags_linkWhereUniqueInput
  }

  /**
   * photos_albums_tags_link deleteMany
   */
  export type photos_albums_tags_linkDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which photos_albums_tags_links to delete
     */
    where?: photos_albums_tags_linkWhereInput
    /**
     * Limit how many photos_albums_tags_links to delete.
     */
    limit?: number
  }

  /**
   * photos_albums_tags_link without action
   */
  export type photos_albums_tags_linkDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos_albums_tags_link
     */
    select?: photos_albums_tags_linkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos_albums_tags_link
     */
    omit?: photos_albums_tags_linkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photos_albums_tags_linkInclude<ExtArgs> | null
  }


  /**
   * Model photos_tags
   */

  export type AggregatePhotos_tags = {
    _count: Photos_tagsCountAggregateOutputType | null
    _avg: Photos_tagsAvgAggregateOutputType | null
    _sum: Photos_tagsSumAggregateOutputType | null
    _min: Photos_tagsMinAggregateOutputType | null
    _max: Photos_tagsMaxAggregateOutputType | null
  }

  export type Photos_tagsAvgAggregateOutputType = {
    id_tags: number | null
  }

  export type Photos_tagsSumAggregateOutputType = {
    id_tags: number | null
  }

  export type Photos_tagsMinAggregateOutputType = {
    id_tags: number | null
    titre: string | null
    important: boolean | null
  }

  export type Photos_tagsMaxAggregateOutputType = {
    id_tags: number | null
    titre: string | null
    important: boolean | null
  }

  export type Photos_tagsCountAggregateOutputType = {
    id_tags: number
    titre: number
    important: number
    _all: number
  }


  export type Photos_tagsAvgAggregateInputType = {
    id_tags?: true
  }

  export type Photos_tagsSumAggregateInputType = {
    id_tags?: true
  }

  export type Photos_tagsMinAggregateInputType = {
    id_tags?: true
    titre?: true
    important?: true
  }

  export type Photos_tagsMaxAggregateInputType = {
    id_tags?: true
    titre?: true
    important?: true
  }

  export type Photos_tagsCountAggregateInputType = {
    id_tags?: true
    titre?: true
    important?: true
    _all?: true
  }

  export type Photos_tagsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which photos_tags to aggregate.
     */
    where?: photos_tagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of photos_tags to fetch.
     */
    orderBy?: photos_tagsOrderByWithRelationInput | photos_tagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: photos_tagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` photos_tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` photos_tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned photos_tags
    **/
    _count?: true | Photos_tagsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Photos_tagsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Photos_tagsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Photos_tagsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Photos_tagsMaxAggregateInputType
  }

  export type GetPhotos_tagsAggregateType<T extends Photos_tagsAggregateArgs> = {
        [P in keyof T & keyof AggregatePhotos_tags]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePhotos_tags[P]>
      : GetScalarType<T[P], AggregatePhotos_tags[P]>
  }




  export type photos_tagsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: photos_tagsWhereInput
    orderBy?: photos_tagsOrderByWithAggregationInput | photos_tagsOrderByWithAggregationInput[]
    by: Photos_tagsScalarFieldEnum[] | Photos_tagsScalarFieldEnum
    having?: photos_tagsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Photos_tagsCountAggregateInputType | true
    _avg?: Photos_tagsAvgAggregateInputType
    _sum?: Photos_tagsSumAggregateInputType
    _min?: Photos_tagsMinAggregateInputType
    _max?: Photos_tagsMaxAggregateInputType
  }

  export type Photos_tagsGroupByOutputType = {
    id_tags: number
    titre: string
    important: boolean
    _count: Photos_tagsCountAggregateOutputType | null
    _avg: Photos_tagsAvgAggregateOutputType | null
    _sum: Photos_tagsSumAggregateOutputType | null
    _min: Photos_tagsMinAggregateOutputType | null
    _max: Photos_tagsMaxAggregateOutputType | null
  }

  type GetPhotos_tagsGroupByPayload<T extends photos_tagsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Photos_tagsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Photos_tagsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Photos_tagsGroupByOutputType[P]>
            : GetScalarType<T[P], Photos_tagsGroupByOutputType[P]>
        }
      >
    >


  export type photos_tagsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_tags?: boolean
    titre?: boolean
    important?: boolean
    photos_albums_tags_link?: boolean | photos_tags$photos_albums_tags_linkArgs<ExtArgs>
    photos_tags_link?: boolean | photos_tags$photos_tags_linkArgs<ExtArgs>
    _count?: boolean | Photos_tagsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["photos_tags"]>



  export type photos_tagsSelectScalar = {
    id_tags?: boolean
    titre?: boolean
    important?: boolean
  }

  export type photos_tagsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id_tags" | "titre" | "important", ExtArgs["result"]["photos_tags"]>
  export type photos_tagsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    photos_albums_tags_link?: boolean | photos_tags$photos_albums_tags_linkArgs<ExtArgs>
    photos_tags_link?: boolean | photos_tags$photos_tags_linkArgs<ExtArgs>
    _count?: boolean | Photos_tagsCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $photos_tagsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "photos_tags"
    objects: {
      photos_albums_tags_link: Prisma.$photos_albums_tags_linkPayload<ExtArgs>[]
      photos_tags_link: Prisma.$photos_tags_linkPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id_tags: number
      titre: string
      important: boolean
    }, ExtArgs["result"]["photos_tags"]>
    composites: {}
  }

  type photos_tagsGetPayload<S extends boolean | null | undefined | photos_tagsDefaultArgs> = $Result.GetResult<Prisma.$photos_tagsPayload, S>

  type photos_tagsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<photos_tagsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Photos_tagsCountAggregateInputType | true
    }

  export interface photos_tagsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['photos_tags'], meta: { name: 'photos_tags' } }
    /**
     * Find zero or one Photos_tags that matches the filter.
     * @param {photos_tagsFindUniqueArgs} args - Arguments to find a Photos_tags
     * @example
     * // Get one Photos_tags
     * const photos_tags = await prisma.photos_tags.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends photos_tagsFindUniqueArgs>(args: SelectSubset<T, photos_tagsFindUniqueArgs<ExtArgs>>): Prisma__photos_tagsClient<$Result.GetResult<Prisma.$photos_tagsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Photos_tags that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {photos_tagsFindUniqueOrThrowArgs} args - Arguments to find a Photos_tags
     * @example
     * // Get one Photos_tags
     * const photos_tags = await prisma.photos_tags.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends photos_tagsFindUniqueOrThrowArgs>(args: SelectSubset<T, photos_tagsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__photos_tagsClient<$Result.GetResult<Prisma.$photos_tagsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Photos_tags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {photos_tagsFindFirstArgs} args - Arguments to find a Photos_tags
     * @example
     * // Get one Photos_tags
     * const photos_tags = await prisma.photos_tags.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends photos_tagsFindFirstArgs>(args?: SelectSubset<T, photos_tagsFindFirstArgs<ExtArgs>>): Prisma__photos_tagsClient<$Result.GetResult<Prisma.$photos_tagsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Photos_tags that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {photos_tagsFindFirstOrThrowArgs} args - Arguments to find a Photos_tags
     * @example
     * // Get one Photos_tags
     * const photos_tags = await prisma.photos_tags.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends photos_tagsFindFirstOrThrowArgs>(args?: SelectSubset<T, photos_tagsFindFirstOrThrowArgs<ExtArgs>>): Prisma__photos_tagsClient<$Result.GetResult<Prisma.$photos_tagsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Photos_tags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {photos_tagsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Photos_tags
     * const photos_tags = await prisma.photos_tags.findMany()
     * 
     * // Get first 10 Photos_tags
     * const photos_tags = await prisma.photos_tags.findMany({ take: 10 })
     * 
     * // Only select the `id_tags`
     * const photos_tagsWithId_tagsOnly = await prisma.photos_tags.findMany({ select: { id_tags: true } })
     * 
     */
    findMany<T extends photos_tagsFindManyArgs>(args?: SelectSubset<T, photos_tagsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$photos_tagsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Photos_tags.
     * @param {photos_tagsCreateArgs} args - Arguments to create a Photos_tags.
     * @example
     * // Create one Photos_tags
     * const Photos_tags = await prisma.photos_tags.create({
     *   data: {
     *     // ... data to create a Photos_tags
     *   }
     * })
     * 
     */
    create<T extends photos_tagsCreateArgs>(args: SelectSubset<T, photos_tagsCreateArgs<ExtArgs>>): Prisma__photos_tagsClient<$Result.GetResult<Prisma.$photos_tagsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Photos_tags.
     * @param {photos_tagsCreateManyArgs} args - Arguments to create many Photos_tags.
     * @example
     * // Create many Photos_tags
     * const photos_tags = await prisma.photos_tags.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends photos_tagsCreateManyArgs>(args?: SelectSubset<T, photos_tagsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Photos_tags.
     * @param {photos_tagsDeleteArgs} args - Arguments to delete one Photos_tags.
     * @example
     * // Delete one Photos_tags
     * const Photos_tags = await prisma.photos_tags.delete({
     *   where: {
     *     // ... filter to delete one Photos_tags
     *   }
     * })
     * 
     */
    delete<T extends photos_tagsDeleteArgs>(args: SelectSubset<T, photos_tagsDeleteArgs<ExtArgs>>): Prisma__photos_tagsClient<$Result.GetResult<Prisma.$photos_tagsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Photos_tags.
     * @param {photos_tagsUpdateArgs} args - Arguments to update one Photos_tags.
     * @example
     * // Update one Photos_tags
     * const photos_tags = await prisma.photos_tags.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends photos_tagsUpdateArgs>(args: SelectSubset<T, photos_tagsUpdateArgs<ExtArgs>>): Prisma__photos_tagsClient<$Result.GetResult<Prisma.$photos_tagsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Photos_tags.
     * @param {photos_tagsDeleteManyArgs} args - Arguments to filter Photos_tags to delete.
     * @example
     * // Delete a few Photos_tags
     * const { count } = await prisma.photos_tags.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends photos_tagsDeleteManyArgs>(args?: SelectSubset<T, photos_tagsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Photos_tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {photos_tagsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Photos_tags
     * const photos_tags = await prisma.photos_tags.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends photos_tagsUpdateManyArgs>(args: SelectSubset<T, photos_tagsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Photos_tags.
     * @param {photos_tagsUpsertArgs} args - Arguments to update or create a Photos_tags.
     * @example
     * // Update or create a Photos_tags
     * const photos_tags = await prisma.photos_tags.upsert({
     *   create: {
     *     // ... data to create a Photos_tags
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Photos_tags we want to update
     *   }
     * })
     */
    upsert<T extends photos_tagsUpsertArgs>(args: SelectSubset<T, photos_tagsUpsertArgs<ExtArgs>>): Prisma__photos_tagsClient<$Result.GetResult<Prisma.$photos_tagsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Photos_tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {photos_tagsCountArgs} args - Arguments to filter Photos_tags to count.
     * @example
     * // Count the number of Photos_tags
     * const count = await prisma.photos_tags.count({
     *   where: {
     *     // ... the filter for the Photos_tags we want to count
     *   }
     * })
    **/
    count<T extends photos_tagsCountArgs>(
      args?: Subset<T, photos_tagsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Photos_tagsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Photos_tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Photos_tagsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Photos_tagsAggregateArgs>(args: Subset<T, Photos_tagsAggregateArgs>): Prisma.PrismaPromise<GetPhotos_tagsAggregateType<T>>

    /**
     * Group by Photos_tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {photos_tagsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends photos_tagsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: photos_tagsGroupByArgs['orderBy'] }
        : { orderBy?: photos_tagsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, photos_tagsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPhotos_tagsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the photos_tags model
   */
  readonly fields: photos_tagsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for photos_tags.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__photos_tagsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    photos_albums_tags_link<T extends photos_tags$photos_albums_tags_linkArgs<ExtArgs> = {}>(args?: Subset<T, photos_tags$photos_albums_tags_linkArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$photos_albums_tags_linkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    photos_tags_link<T extends photos_tags$photos_tags_linkArgs<ExtArgs> = {}>(args?: Subset<T, photos_tags$photos_tags_linkArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$photos_tags_linkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the photos_tags model
   */
  interface photos_tagsFieldRefs {
    readonly id_tags: FieldRef<"photos_tags", 'Int'>
    readonly titre: FieldRef<"photos_tags", 'String'>
    readonly important: FieldRef<"photos_tags", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * photos_tags findUnique
   */
  export type photos_tagsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos_tags
     */
    select?: photos_tagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos_tags
     */
    omit?: photos_tagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photos_tagsInclude<ExtArgs> | null
    /**
     * Filter, which photos_tags to fetch.
     */
    where: photos_tagsWhereUniqueInput
  }

  /**
   * photos_tags findUniqueOrThrow
   */
  export type photos_tagsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos_tags
     */
    select?: photos_tagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos_tags
     */
    omit?: photos_tagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photos_tagsInclude<ExtArgs> | null
    /**
     * Filter, which photos_tags to fetch.
     */
    where: photos_tagsWhereUniqueInput
  }

  /**
   * photos_tags findFirst
   */
  export type photos_tagsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos_tags
     */
    select?: photos_tagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos_tags
     */
    omit?: photos_tagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photos_tagsInclude<ExtArgs> | null
    /**
     * Filter, which photos_tags to fetch.
     */
    where?: photos_tagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of photos_tags to fetch.
     */
    orderBy?: photos_tagsOrderByWithRelationInput | photos_tagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for photos_tags.
     */
    cursor?: photos_tagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` photos_tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` photos_tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of photos_tags.
     */
    distinct?: Photos_tagsScalarFieldEnum | Photos_tagsScalarFieldEnum[]
  }

  /**
   * photos_tags findFirstOrThrow
   */
  export type photos_tagsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos_tags
     */
    select?: photos_tagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos_tags
     */
    omit?: photos_tagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photos_tagsInclude<ExtArgs> | null
    /**
     * Filter, which photos_tags to fetch.
     */
    where?: photos_tagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of photos_tags to fetch.
     */
    orderBy?: photos_tagsOrderByWithRelationInput | photos_tagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for photos_tags.
     */
    cursor?: photos_tagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` photos_tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` photos_tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of photos_tags.
     */
    distinct?: Photos_tagsScalarFieldEnum | Photos_tagsScalarFieldEnum[]
  }

  /**
   * photos_tags findMany
   */
  export type photos_tagsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos_tags
     */
    select?: photos_tagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos_tags
     */
    omit?: photos_tagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photos_tagsInclude<ExtArgs> | null
    /**
     * Filter, which photos_tags to fetch.
     */
    where?: photos_tagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of photos_tags to fetch.
     */
    orderBy?: photos_tagsOrderByWithRelationInput | photos_tagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing photos_tags.
     */
    cursor?: photos_tagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` photos_tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` photos_tags.
     */
    skip?: number
    distinct?: Photos_tagsScalarFieldEnum | Photos_tagsScalarFieldEnum[]
  }

  /**
   * photos_tags create
   */
  export type photos_tagsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos_tags
     */
    select?: photos_tagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos_tags
     */
    omit?: photos_tagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photos_tagsInclude<ExtArgs> | null
    /**
     * The data needed to create a photos_tags.
     */
    data: XOR<photos_tagsCreateInput, photos_tagsUncheckedCreateInput>
  }

  /**
   * photos_tags createMany
   */
  export type photos_tagsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many photos_tags.
     */
    data: photos_tagsCreateManyInput | photos_tagsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * photos_tags update
   */
  export type photos_tagsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos_tags
     */
    select?: photos_tagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos_tags
     */
    omit?: photos_tagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photos_tagsInclude<ExtArgs> | null
    /**
     * The data needed to update a photos_tags.
     */
    data: XOR<photos_tagsUpdateInput, photos_tagsUncheckedUpdateInput>
    /**
     * Choose, which photos_tags to update.
     */
    where: photos_tagsWhereUniqueInput
  }

  /**
   * photos_tags updateMany
   */
  export type photos_tagsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update photos_tags.
     */
    data: XOR<photos_tagsUpdateManyMutationInput, photos_tagsUncheckedUpdateManyInput>
    /**
     * Filter which photos_tags to update
     */
    where?: photos_tagsWhereInput
    /**
     * Limit how many photos_tags to update.
     */
    limit?: number
  }

  /**
   * photos_tags upsert
   */
  export type photos_tagsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos_tags
     */
    select?: photos_tagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos_tags
     */
    omit?: photos_tagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photos_tagsInclude<ExtArgs> | null
    /**
     * The filter to search for the photos_tags to update in case it exists.
     */
    where: photos_tagsWhereUniqueInput
    /**
     * In case the photos_tags found by the `where` argument doesn't exist, create a new photos_tags with this data.
     */
    create: XOR<photos_tagsCreateInput, photos_tagsUncheckedCreateInput>
    /**
     * In case the photos_tags was found with the provided `where` argument, update it with this data.
     */
    update: XOR<photos_tagsUpdateInput, photos_tagsUncheckedUpdateInput>
  }

  /**
   * photos_tags delete
   */
  export type photos_tagsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos_tags
     */
    select?: photos_tagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos_tags
     */
    omit?: photos_tagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photos_tagsInclude<ExtArgs> | null
    /**
     * Filter which photos_tags to delete.
     */
    where: photos_tagsWhereUniqueInput
  }

  /**
   * photos_tags deleteMany
   */
  export type photos_tagsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which photos_tags to delete
     */
    where?: photos_tagsWhereInput
    /**
     * Limit how many photos_tags to delete.
     */
    limit?: number
  }

  /**
   * photos_tags.photos_albums_tags_link
   */
  export type photos_tags$photos_albums_tags_linkArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos_albums_tags_link
     */
    select?: photos_albums_tags_linkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos_albums_tags_link
     */
    omit?: photos_albums_tags_linkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photos_albums_tags_linkInclude<ExtArgs> | null
    where?: photos_albums_tags_linkWhereInput
    orderBy?: photos_albums_tags_linkOrderByWithRelationInput | photos_albums_tags_linkOrderByWithRelationInput[]
    cursor?: photos_albums_tags_linkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Photos_albums_tags_linkScalarFieldEnum | Photos_albums_tags_linkScalarFieldEnum[]
  }

  /**
   * photos_tags.photos_tags_link
   */
  export type photos_tags$photos_tags_linkArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos_tags_link
     */
    select?: photos_tags_linkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos_tags_link
     */
    omit?: photos_tags_linkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photos_tags_linkInclude<ExtArgs> | null
    where?: photos_tags_linkWhereInput
    orderBy?: photos_tags_linkOrderByWithRelationInput | photos_tags_linkOrderByWithRelationInput[]
    cursor?: photos_tags_linkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Photos_tags_linkScalarFieldEnum | Photos_tags_linkScalarFieldEnum[]
  }

  /**
   * photos_tags without action
   */
  export type photos_tagsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos_tags
     */
    select?: photos_tagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos_tags
     */
    omit?: photos_tagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photos_tagsInclude<ExtArgs> | null
  }


  /**
   * Model photos_tags_link
   */

  export type AggregatePhotos_tags_link = {
    _count: Photos_tags_linkCountAggregateOutputType | null
    _avg: Photos_tags_linkAvgAggregateOutputType | null
    _sum: Photos_tags_linkSumAggregateOutputType | null
    _min: Photos_tags_linkMinAggregateOutputType | null
    _max: Photos_tags_linkMaxAggregateOutputType | null
  }

  export type Photos_tags_linkAvgAggregateOutputType = {
    id_pho: number | null
    id_tags: number | null
  }

  export type Photos_tags_linkSumAggregateOutputType = {
    id_pho: number | null
    id_tags: number | null
  }

  export type Photos_tags_linkMinAggregateOutputType = {
    id_pho: number | null
    id_tags: number | null
  }

  export type Photos_tags_linkMaxAggregateOutputType = {
    id_pho: number | null
    id_tags: number | null
  }

  export type Photos_tags_linkCountAggregateOutputType = {
    id_pho: number
    id_tags: number
    _all: number
  }


  export type Photos_tags_linkAvgAggregateInputType = {
    id_pho?: true
    id_tags?: true
  }

  export type Photos_tags_linkSumAggregateInputType = {
    id_pho?: true
    id_tags?: true
  }

  export type Photos_tags_linkMinAggregateInputType = {
    id_pho?: true
    id_tags?: true
  }

  export type Photos_tags_linkMaxAggregateInputType = {
    id_pho?: true
    id_tags?: true
  }

  export type Photos_tags_linkCountAggregateInputType = {
    id_pho?: true
    id_tags?: true
    _all?: true
  }

  export type Photos_tags_linkAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which photos_tags_link to aggregate.
     */
    where?: photos_tags_linkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of photos_tags_links to fetch.
     */
    orderBy?: photos_tags_linkOrderByWithRelationInput | photos_tags_linkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: photos_tags_linkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` photos_tags_links from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` photos_tags_links.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned photos_tags_links
    **/
    _count?: true | Photos_tags_linkCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Photos_tags_linkAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Photos_tags_linkSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Photos_tags_linkMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Photos_tags_linkMaxAggregateInputType
  }

  export type GetPhotos_tags_linkAggregateType<T extends Photos_tags_linkAggregateArgs> = {
        [P in keyof T & keyof AggregatePhotos_tags_link]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePhotos_tags_link[P]>
      : GetScalarType<T[P], AggregatePhotos_tags_link[P]>
  }




  export type photos_tags_linkGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: photos_tags_linkWhereInput
    orderBy?: photos_tags_linkOrderByWithAggregationInput | photos_tags_linkOrderByWithAggregationInput[]
    by: Photos_tags_linkScalarFieldEnum[] | Photos_tags_linkScalarFieldEnum
    having?: photos_tags_linkScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Photos_tags_linkCountAggregateInputType | true
    _avg?: Photos_tags_linkAvgAggregateInputType
    _sum?: Photos_tags_linkSumAggregateInputType
    _min?: Photos_tags_linkMinAggregateInputType
    _max?: Photos_tags_linkMaxAggregateInputType
  }

  export type Photos_tags_linkGroupByOutputType = {
    id_pho: number
    id_tags: number
    _count: Photos_tags_linkCountAggregateOutputType | null
    _avg: Photos_tags_linkAvgAggregateOutputType | null
    _sum: Photos_tags_linkSumAggregateOutputType | null
    _min: Photos_tags_linkMinAggregateOutputType | null
    _max: Photos_tags_linkMaxAggregateOutputType | null
  }

  type GetPhotos_tags_linkGroupByPayload<T extends photos_tags_linkGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Photos_tags_linkGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Photos_tags_linkGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Photos_tags_linkGroupByOutputType[P]>
            : GetScalarType<T[P], Photos_tags_linkGroupByOutputType[P]>
        }
      >
    >


  export type photos_tags_linkSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_pho?: boolean
    id_tags?: boolean
    photos?: boolean | photosDefaultArgs<ExtArgs>
    photos_tags?: boolean | photos_tagsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["photos_tags_link"]>



  export type photos_tags_linkSelectScalar = {
    id_pho?: boolean
    id_tags?: boolean
  }

  export type photos_tags_linkOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id_pho" | "id_tags", ExtArgs["result"]["photos_tags_link"]>
  export type photos_tags_linkInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    photos?: boolean | photosDefaultArgs<ExtArgs>
    photos_tags?: boolean | photos_tagsDefaultArgs<ExtArgs>
  }

  export type $photos_tags_linkPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "photos_tags_link"
    objects: {
      photos: Prisma.$photosPayload<ExtArgs>
      photos_tags: Prisma.$photos_tagsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id_pho: number
      id_tags: number
    }, ExtArgs["result"]["photos_tags_link"]>
    composites: {}
  }

  type photos_tags_linkGetPayload<S extends boolean | null | undefined | photos_tags_linkDefaultArgs> = $Result.GetResult<Prisma.$photos_tags_linkPayload, S>

  type photos_tags_linkCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<photos_tags_linkFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Photos_tags_linkCountAggregateInputType | true
    }

  export interface photos_tags_linkDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['photos_tags_link'], meta: { name: 'photos_tags_link' } }
    /**
     * Find zero or one Photos_tags_link that matches the filter.
     * @param {photos_tags_linkFindUniqueArgs} args - Arguments to find a Photos_tags_link
     * @example
     * // Get one Photos_tags_link
     * const photos_tags_link = await prisma.photos_tags_link.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends photos_tags_linkFindUniqueArgs>(args: SelectSubset<T, photos_tags_linkFindUniqueArgs<ExtArgs>>): Prisma__photos_tags_linkClient<$Result.GetResult<Prisma.$photos_tags_linkPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Photos_tags_link that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {photos_tags_linkFindUniqueOrThrowArgs} args - Arguments to find a Photos_tags_link
     * @example
     * // Get one Photos_tags_link
     * const photos_tags_link = await prisma.photos_tags_link.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends photos_tags_linkFindUniqueOrThrowArgs>(args: SelectSubset<T, photos_tags_linkFindUniqueOrThrowArgs<ExtArgs>>): Prisma__photos_tags_linkClient<$Result.GetResult<Prisma.$photos_tags_linkPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Photos_tags_link that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {photos_tags_linkFindFirstArgs} args - Arguments to find a Photos_tags_link
     * @example
     * // Get one Photos_tags_link
     * const photos_tags_link = await prisma.photos_tags_link.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends photos_tags_linkFindFirstArgs>(args?: SelectSubset<T, photos_tags_linkFindFirstArgs<ExtArgs>>): Prisma__photos_tags_linkClient<$Result.GetResult<Prisma.$photos_tags_linkPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Photos_tags_link that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {photos_tags_linkFindFirstOrThrowArgs} args - Arguments to find a Photos_tags_link
     * @example
     * // Get one Photos_tags_link
     * const photos_tags_link = await prisma.photos_tags_link.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends photos_tags_linkFindFirstOrThrowArgs>(args?: SelectSubset<T, photos_tags_linkFindFirstOrThrowArgs<ExtArgs>>): Prisma__photos_tags_linkClient<$Result.GetResult<Prisma.$photos_tags_linkPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Photos_tags_links that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {photos_tags_linkFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Photos_tags_links
     * const photos_tags_links = await prisma.photos_tags_link.findMany()
     * 
     * // Get first 10 Photos_tags_links
     * const photos_tags_links = await prisma.photos_tags_link.findMany({ take: 10 })
     * 
     * // Only select the `id_pho`
     * const photos_tags_linkWithId_phoOnly = await prisma.photos_tags_link.findMany({ select: { id_pho: true } })
     * 
     */
    findMany<T extends photos_tags_linkFindManyArgs>(args?: SelectSubset<T, photos_tags_linkFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$photos_tags_linkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Photos_tags_link.
     * @param {photos_tags_linkCreateArgs} args - Arguments to create a Photos_tags_link.
     * @example
     * // Create one Photos_tags_link
     * const Photos_tags_link = await prisma.photos_tags_link.create({
     *   data: {
     *     // ... data to create a Photos_tags_link
     *   }
     * })
     * 
     */
    create<T extends photos_tags_linkCreateArgs>(args: SelectSubset<T, photos_tags_linkCreateArgs<ExtArgs>>): Prisma__photos_tags_linkClient<$Result.GetResult<Prisma.$photos_tags_linkPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Photos_tags_links.
     * @param {photos_tags_linkCreateManyArgs} args - Arguments to create many Photos_tags_links.
     * @example
     * // Create many Photos_tags_links
     * const photos_tags_link = await prisma.photos_tags_link.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends photos_tags_linkCreateManyArgs>(args?: SelectSubset<T, photos_tags_linkCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Photos_tags_link.
     * @param {photos_tags_linkDeleteArgs} args - Arguments to delete one Photos_tags_link.
     * @example
     * // Delete one Photos_tags_link
     * const Photos_tags_link = await prisma.photos_tags_link.delete({
     *   where: {
     *     // ... filter to delete one Photos_tags_link
     *   }
     * })
     * 
     */
    delete<T extends photos_tags_linkDeleteArgs>(args: SelectSubset<T, photos_tags_linkDeleteArgs<ExtArgs>>): Prisma__photos_tags_linkClient<$Result.GetResult<Prisma.$photos_tags_linkPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Photos_tags_link.
     * @param {photos_tags_linkUpdateArgs} args - Arguments to update one Photos_tags_link.
     * @example
     * // Update one Photos_tags_link
     * const photos_tags_link = await prisma.photos_tags_link.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends photos_tags_linkUpdateArgs>(args: SelectSubset<T, photos_tags_linkUpdateArgs<ExtArgs>>): Prisma__photos_tags_linkClient<$Result.GetResult<Prisma.$photos_tags_linkPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Photos_tags_links.
     * @param {photos_tags_linkDeleteManyArgs} args - Arguments to filter Photos_tags_links to delete.
     * @example
     * // Delete a few Photos_tags_links
     * const { count } = await prisma.photos_tags_link.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends photos_tags_linkDeleteManyArgs>(args?: SelectSubset<T, photos_tags_linkDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Photos_tags_links.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {photos_tags_linkUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Photos_tags_links
     * const photos_tags_link = await prisma.photos_tags_link.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends photos_tags_linkUpdateManyArgs>(args: SelectSubset<T, photos_tags_linkUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Photos_tags_link.
     * @param {photos_tags_linkUpsertArgs} args - Arguments to update or create a Photos_tags_link.
     * @example
     * // Update or create a Photos_tags_link
     * const photos_tags_link = await prisma.photos_tags_link.upsert({
     *   create: {
     *     // ... data to create a Photos_tags_link
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Photos_tags_link we want to update
     *   }
     * })
     */
    upsert<T extends photos_tags_linkUpsertArgs>(args: SelectSubset<T, photos_tags_linkUpsertArgs<ExtArgs>>): Prisma__photos_tags_linkClient<$Result.GetResult<Prisma.$photos_tags_linkPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Photos_tags_links.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {photos_tags_linkCountArgs} args - Arguments to filter Photos_tags_links to count.
     * @example
     * // Count the number of Photos_tags_links
     * const count = await prisma.photos_tags_link.count({
     *   where: {
     *     // ... the filter for the Photos_tags_links we want to count
     *   }
     * })
    **/
    count<T extends photos_tags_linkCountArgs>(
      args?: Subset<T, photos_tags_linkCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Photos_tags_linkCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Photos_tags_link.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Photos_tags_linkAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Photos_tags_linkAggregateArgs>(args: Subset<T, Photos_tags_linkAggregateArgs>): Prisma.PrismaPromise<GetPhotos_tags_linkAggregateType<T>>

    /**
     * Group by Photos_tags_link.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {photos_tags_linkGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends photos_tags_linkGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: photos_tags_linkGroupByArgs['orderBy'] }
        : { orderBy?: photos_tags_linkGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, photos_tags_linkGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPhotos_tags_linkGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the photos_tags_link model
   */
  readonly fields: photos_tags_linkFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for photos_tags_link.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__photos_tags_linkClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    photos<T extends photosDefaultArgs<ExtArgs> = {}>(args?: Subset<T, photosDefaultArgs<ExtArgs>>): Prisma__photosClient<$Result.GetResult<Prisma.$photosPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    photos_tags<T extends photos_tagsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, photos_tagsDefaultArgs<ExtArgs>>): Prisma__photos_tagsClient<$Result.GetResult<Prisma.$photos_tagsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the photos_tags_link model
   */
  interface photos_tags_linkFieldRefs {
    readonly id_pho: FieldRef<"photos_tags_link", 'Int'>
    readonly id_tags: FieldRef<"photos_tags_link", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * photos_tags_link findUnique
   */
  export type photos_tags_linkFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos_tags_link
     */
    select?: photos_tags_linkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos_tags_link
     */
    omit?: photos_tags_linkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photos_tags_linkInclude<ExtArgs> | null
    /**
     * Filter, which photos_tags_link to fetch.
     */
    where: photos_tags_linkWhereUniqueInput
  }

  /**
   * photos_tags_link findUniqueOrThrow
   */
  export type photos_tags_linkFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos_tags_link
     */
    select?: photos_tags_linkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos_tags_link
     */
    omit?: photos_tags_linkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photos_tags_linkInclude<ExtArgs> | null
    /**
     * Filter, which photos_tags_link to fetch.
     */
    where: photos_tags_linkWhereUniqueInput
  }

  /**
   * photos_tags_link findFirst
   */
  export type photos_tags_linkFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos_tags_link
     */
    select?: photos_tags_linkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos_tags_link
     */
    omit?: photos_tags_linkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photos_tags_linkInclude<ExtArgs> | null
    /**
     * Filter, which photos_tags_link to fetch.
     */
    where?: photos_tags_linkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of photos_tags_links to fetch.
     */
    orderBy?: photos_tags_linkOrderByWithRelationInput | photos_tags_linkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for photos_tags_links.
     */
    cursor?: photos_tags_linkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` photos_tags_links from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` photos_tags_links.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of photos_tags_links.
     */
    distinct?: Photos_tags_linkScalarFieldEnum | Photos_tags_linkScalarFieldEnum[]
  }

  /**
   * photos_tags_link findFirstOrThrow
   */
  export type photos_tags_linkFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos_tags_link
     */
    select?: photos_tags_linkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos_tags_link
     */
    omit?: photos_tags_linkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photos_tags_linkInclude<ExtArgs> | null
    /**
     * Filter, which photos_tags_link to fetch.
     */
    where?: photos_tags_linkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of photos_tags_links to fetch.
     */
    orderBy?: photos_tags_linkOrderByWithRelationInput | photos_tags_linkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for photos_tags_links.
     */
    cursor?: photos_tags_linkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` photos_tags_links from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` photos_tags_links.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of photos_tags_links.
     */
    distinct?: Photos_tags_linkScalarFieldEnum | Photos_tags_linkScalarFieldEnum[]
  }

  /**
   * photos_tags_link findMany
   */
  export type photos_tags_linkFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos_tags_link
     */
    select?: photos_tags_linkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos_tags_link
     */
    omit?: photos_tags_linkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photos_tags_linkInclude<ExtArgs> | null
    /**
     * Filter, which photos_tags_links to fetch.
     */
    where?: photos_tags_linkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of photos_tags_links to fetch.
     */
    orderBy?: photos_tags_linkOrderByWithRelationInput | photos_tags_linkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing photos_tags_links.
     */
    cursor?: photos_tags_linkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` photos_tags_links from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` photos_tags_links.
     */
    skip?: number
    distinct?: Photos_tags_linkScalarFieldEnum | Photos_tags_linkScalarFieldEnum[]
  }

  /**
   * photos_tags_link create
   */
  export type photos_tags_linkCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos_tags_link
     */
    select?: photos_tags_linkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos_tags_link
     */
    omit?: photos_tags_linkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photos_tags_linkInclude<ExtArgs> | null
    /**
     * The data needed to create a photos_tags_link.
     */
    data: XOR<photos_tags_linkCreateInput, photos_tags_linkUncheckedCreateInput>
  }

  /**
   * photos_tags_link createMany
   */
  export type photos_tags_linkCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many photos_tags_links.
     */
    data: photos_tags_linkCreateManyInput | photos_tags_linkCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * photos_tags_link update
   */
  export type photos_tags_linkUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos_tags_link
     */
    select?: photos_tags_linkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos_tags_link
     */
    omit?: photos_tags_linkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photos_tags_linkInclude<ExtArgs> | null
    /**
     * The data needed to update a photos_tags_link.
     */
    data: XOR<photos_tags_linkUpdateInput, photos_tags_linkUncheckedUpdateInput>
    /**
     * Choose, which photos_tags_link to update.
     */
    where: photos_tags_linkWhereUniqueInput
  }

  /**
   * photos_tags_link updateMany
   */
  export type photos_tags_linkUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update photos_tags_links.
     */
    data: XOR<photos_tags_linkUpdateManyMutationInput, photos_tags_linkUncheckedUpdateManyInput>
    /**
     * Filter which photos_tags_links to update
     */
    where?: photos_tags_linkWhereInput
    /**
     * Limit how many photos_tags_links to update.
     */
    limit?: number
  }

  /**
   * photos_tags_link upsert
   */
  export type photos_tags_linkUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos_tags_link
     */
    select?: photos_tags_linkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos_tags_link
     */
    omit?: photos_tags_linkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photos_tags_linkInclude<ExtArgs> | null
    /**
     * The filter to search for the photos_tags_link to update in case it exists.
     */
    where: photos_tags_linkWhereUniqueInput
    /**
     * In case the photos_tags_link found by the `where` argument doesn't exist, create a new photos_tags_link with this data.
     */
    create: XOR<photos_tags_linkCreateInput, photos_tags_linkUncheckedCreateInput>
    /**
     * In case the photos_tags_link was found with the provided `where` argument, update it with this data.
     */
    update: XOR<photos_tags_linkUpdateInput, photos_tags_linkUncheckedUpdateInput>
  }

  /**
   * photos_tags_link delete
   */
  export type photos_tags_linkDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos_tags_link
     */
    select?: photos_tags_linkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos_tags_link
     */
    omit?: photos_tags_linkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photos_tags_linkInclude<ExtArgs> | null
    /**
     * Filter which photos_tags_link to delete.
     */
    where: photos_tags_linkWhereUniqueInput
  }

  /**
   * photos_tags_link deleteMany
   */
  export type photos_tags_linkDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which photos_tags_links to delete
     */
    where?: photos_tags_linkWhereInput
    /**
     * Limit how many photos_tags_links to delete.
     */
    limit?: number
  }

  /**
   * photos_tags_link without action
   */
  export type photos_tags_linkDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos_tags_link
     */
    select?: photos_tags_linkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos_tags_link
     */
    omit?: photos_tags_linkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photos_tags_linkInclude<ExtArgs> | null
  }


  /**
   * Model photos_tags_recherche
   */

  export type AggregatePhotos_tags_recherche = {
    _count: Photos_tags_rechercheCountAggregateOutputType | null
    _avg: Photos_tags_rechercheAvgAggregateOutputType | null
    _sum: Photos_tags_rechercheSumAggregateOutputType | null
    _min: Photos_tags_rechercheMinAggregateOutputType | null
    _max: Photos_tags_rechercheMaxAggregateOutputType | null
  }

  export type Photos_tags_rechercheAvgAggregateOutputType = {
    id_tags: number | null
  }

  export type Photos_tags_rechercheSumAggregateOutputType = {
    id_tags: number | null
  }

  export type Photos_tags_rechercheMinAggregateOutputType = {
    id_tags: number | null
    titre: string | null
    important: boolean | null
  }

  export type Photos_tags_rechercheMaxAggregateOutputType = {
    id_tags: number | null
    titre: string | null
    important: boolean | null
  }

  export type Photos_tags_rechercheCountAggregateOutputType = {
    id_tags: number
    titre: number
    important: number
    _all: number
  }


  export type Photos_tags_rechercheAvgAggregateInputType = {
    id_tags?: true
  }

  export type Photos_tags_rechercheSumAggregateInputType = {
    id_tags?: true
  }

  export type Photos_tags_rechercheMinAggregateInputType = {
    id_tags?: true
    titre?: true
    important?: true
  }

  export type Photos_tags_rechercheMaxAggregateInputType = {
    id_tags?: true
    titre?: true
    important?: true
  }

  export type Photos_tags_rechercheCountAggregateInputType = {
    id_tags?: true
    titre?: true
    important?: true
    _all?: true
  }

  export type Photos_tags_rechercheAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which photos_tags_recherche to aggregate.
     */
    where?: photos_tags_rechercheWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of photos_tags_recherches to fetch.
     */
    orderBy?: photos_tags_rechercheOrderByWithRelationInput | photos_tags_rechercheOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: photos_tags_rechercheWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` photos_tags_recherches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` photos_tags_recherches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned photos_tags_recherches
    **/
    _count?: true | Photos_tags_rechercheCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Photos_tags_rechercheAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Photos_tags_rechercheSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Photos_tags_rechercheMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Photos_tags_rechercheMaxAggregateInputType
  }

  export type GetPhotos_tags_rechercheAggregateType<T extends Photos_tags_rechercheAggregateArgs> = {
        [P in keyof T & keyof AggregatePhotos_tags_recherche]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePhotos_tags_recherche[P]>
      : GetScalarType<T[P], AggregatePhotos_tags_recherche[P]>
  }




  export type photos_tags_rechercheGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: photos_tags_rechercheWhereInput
    orderBy?: photos_tags_rechercheOrderByWithAggregationInput | photos_tags_rechercheOrderByWithAggregationInput[]
    by: Photos_tags_rechercheScalarFieldEnum[] | Photos_tags_rechercheScalarFieldEnum
    having?: photos_tags_rechercheScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Photos_tags_rechercheCountAggregateInputType | true
    _avg?: Photos_tags_rechercheAvgAggregateInputType
    _sum?: Photos_tags_rechercheSumAggregateInputType
    _min?: Photos_tags_rechercheMinAggregateInputType
    _max?: Photos_tags_rechercheMaxAggregateInputType
  }

  export type Photos_tags_rechercheGroupByOutputType = {
    id_tags: number
    titre: string
    important: boolean
    _count: Photos_tags_rechercheCountAggregateOutputType | null
    _avg: Photos_tags_rechercheAvgAggregateOutputType | null
    _sum: Photos_tags_rechercheSumAggregateOutputType | null
    _min: Photos_tags_rechercheMinAggregateOutputType | null
    _max: Photos_tags_rechercheMaxAggregateOutputType | null
  }

  type GetPhotos_tags_rechercheGroupByPayload<T extends photos_tags_rechercheGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Photos_tags_rechercheGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Photos_tags_rechercheGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Photos_tags_rechercheGroupByOutputType[P]>
            : GetScalarType<T[P], Photos_tags_rechercheGroupByOutputType[P]>
        }
      >
    >


  export type photos_tags_rechercheSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_tags?: boolean
    titre?: boolean
    important?: boolean
    photos_tags_recherche_link?: boolean | photos_tags_recherche$photos_tags_recherche_linkArgs<ExtArgs>
    _count?: boolean | Photos_tags_rechercheCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["photos_tags_recherche"]>



  export type photos_tags_rechercheSelectScalar = {
    id_tags?: boolean
    titre?: boolean
    important?: boolean
  }

  export type photos_tags_rechercheOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id_tags" | "titre" | "important", ExtArgs["result"]["photos_tags_recherche"]>
  export type photos_tags_rechercheInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    photos_tags_recherche_link?: boolean | photos_tags_recherche$photos_tags_recherche_linkArgs<ExtArgs>
    _count?: boolean | Photos_tags_rechercheCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $photos_tags_recherchePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "photos_tags_recherche"
    objects: {
      photos_tags_recherche_link: Prisma.$photos_tags_recherche_linkPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id_tags: number
      titre: string
      important: boolean
    }, ExtArgs["result"]["photos_tags_recherche"]>
    composites: {}
  }

  type photos_tags_rechercheGetPayload<S extends boolean | null | undefined | photos_tags_rechercheDefaultArgs> = $Result.GetResult<Prisma.$photos_tags_recherchePayload, S>

  type photos_tags_rechercheCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<photos_tags_rechercheFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Photos_tags_rechercheCountAggregateInputType | true
    }

  export interface photos_tags_rechercheDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['photos_tags_recherche'], meta: { name: 'photos_tags_recherche' } }
    /**
     * Find zero or one Photos_tags_recherche that matches the filter.
     * @param {photos_tags_rechercheFindUniqueArgs} args - Arguments to find a Photos_tags_recherche
     * @example
     * // Get one Photos_tags_recherche
     * const photos_tags_recherche = await prisma.photos_tags_recherche.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends photos_tags_rechercheFindUniqueArgs>(args: SelectSubset<T, photos_tags_rechercheFindUniqueArgs<ExtArgs>>): Prisma__photos_tags_rechercheClient<$Result.GetResult<Prisma.$photos_tags_recherchePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Photos_tags_recherche that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {photos_tags_rechercheFindUniqueOrThrowArgs} args - Arguments to find a Photos_tags_recherche
     * @example
     * // Get one Photos_tags_recherche
     * const photos_tags_recherche = await prisma.photos_tags_recherche.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends photos_tags_rechercheFindUniqueOrThrowArgs>(args: SelectSubset<T, photos_tags_rechercheFindUniqueOrThrowArgs<ExtArgs>>): Prisma__photos_tags_rechercheClient<$Result.GetResult<Prisma.$photos_tags_recherchePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Photos_tags_recherche that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {photos_tags_rechercheFindFirstArgs} args - Arguments to find a Photos_tags_recherche
     * @example
     * // Get one Photos_tags_recherche
     * const photos_tags_recherche = await prisma.photos_tags_recherche.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends photos_tags_rechercheFindFirstArgs>(args?: SelectSubset<T, photos_tags_rechercheFindFirstArgs<ExtArgs>>): Prisma__photos_tags_rechercheClient<$Result.GetResult<Prisma.$photos_tags_recherchePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Photos_tags_recherche that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {photos_tags_rechercheFindFirstOrThrowArgs} args - Arguments to find a Photos_tags_recherche
     * @example
     * // Get one Photos_tags_recherche
     * const photos_tags_recherche = await prisma.photos_tags_recherche.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends photos_tags_rechercheFindFirstOrThrowArgs>(args?: SelectSubset<T, photos_tags_rechercheFindFirstOrThrowArgs<ExtArgs>>): Prisma__photos_tags_rechercheClient<$Result.GetResult<Prisma.$photos_tags_recherchePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Photos_tags_recherches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {photos_tags_rechercheFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Photos_tags_recherches
     * const photos_tags_recherches = await prisma.photos_tags_recherche.findMany()
     * 
     * // Get first 10 Photos_tags_recherches
     * const photos_tags_recherches = await prisma.photos_tags_recherche.findMany({ take: 10 })
     * 
     * // Only select the `id_tags`
     * const photos_tags_rechercheWithId_tagsOnly = await prisma.photos_tags_recherche.findMany({ select: { id_tags: true } })
     * 
     */
    findMany<T extends photos_tags_rechercheFindManyArgs>(args?: SelectSubset<T, photos_tags_rechercheFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$photos_tags_recherchePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Photos_tags_recherche.
     * @param {photos_tags_rechercheCreateArgs} args - Arguments to create a Photos_tags_recherche.
     * @example
     * // Create one Photos_tags_recherche
     * const Photos_tags_recherche = await prisma.photos_tags_recherche.create({
     *   data: {
     *     // ... data to create a Photos_tags_recherche
     *   }
     * })
     * 
     */
    create<T extends photos_tags_rechercheCreateArgs>(args: SelectSubset<T, photos_tags_rechercheCreateArgs<ExtArgs>>): Prisma__photos_tags_rechercheClient<$Result.GetResult<Prisma.$photos_tags_recherchePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Photos_tags_recherches.
     * @param {photos_tags_rechercheCreateManyArgs} args - Arguments to create many Photos_tags_recherches.
     * @example
     * // Create many Photos_tags_recherches
     * const photos_tags_recherche = await prisma.photos_tags_recherche.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends photos_tags_rechercheCreateManyArgs>(args?: SelectSubset<T, photos_tags_rechercheCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Photos_tags_recherche.
     * @param {photos_tags_rechercheDeleteArgs} args - Arguments to delete one Photos_tags_recherche.
     * @example
     * // Delete one Photos_tags_recherche
     * const Photos_tags_recherche = await prisma.photos_tags_recherche.delete({
     *   where: {
     *     // ... filter to delete one Photos_tags_recherche
     *   }
     * })
     * 
     */
    delete<T extends photos_tags_rechercheDeleteArgs>(args: SelectSubset<T, photos_tags_rechercheDeleteArgs<ExtArgs>>): Prisma__photos_tags_rechercheClient<$Result.GetResult<Prisma.$photos_tags_recherchePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Photos_tags_recherche.
     * @param {photos_tags_rechercheUpdateArgs} args - Arguments to update one Photos_tags_recherche.
     * @example
     * // Update one Photos_tags_recherche
     * const photos_tags_recherche = await prisma.photos_tags_recherche.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends photos_tags_rechercheUpdateArgs>(args: SelectSubset<T, photos_tags_rechercheUpdateArgs<ExtArgs>>): Prisma__photos_tags_rechercheClient<$Result.GetResult<Prisma.$photos_tags_recherchePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Photos_tags_recherches.
     * @param {photos_tags_rechercheDeleteManyArgs} args - Arguments to filter Photos_tags_recherches to delete.
     * @example
     * // Delete a few Photos_tags_recherches
     * const { count } = await prisma.photos_tags_recherche.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends photos_tags_rechercheDeleteManyArgs>(args?: SelectSubset<T, photos_tags_rechercheDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Photos_tags_recherches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {photos_tags_rechercheUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Photos_tags_recherches
     * const photos_tags_recherche = await prisma.photos_tags_recherche.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends photos_tags_rechercheUpdateManyArgs>(args: SelectSubset<T, photos_tags_rechercheUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Photos_tags_recherche.
     * @param {photos_tags_rechercheUpsertArgs} args - Arguments to update or create a Photos_tags_recherche.
     * @example
     * // Update or create a Photos_tags_recherche
     * const photos_tags_recherche = await prisma.photos_tags_recherche.upsert({
     *   create: {
     *     // ... data to create a Photos_tags_recherche
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Photos_tags_recherche we want to update
     *   }
     * })
     */
    upsert<T extends photos_tags_rechercheUpsertArgs>(args: SelectSubset<T, photos_tags_rechercheUpsertArgs<ExtArgs>>): Prisma__photos_tags_rechercheClient<$Result.GetResult<Prisma.$photos_tags_recherchePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Photos_tags_recherches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {photos_tags_rechercheCountArgs} args - Arguments to filter Photos_tags_recherches to count.
     * @example
     * // Count the number of Photos_tags_recherches
     * const count = await prisma.photos_tags_recherche.count({
     *   where: {
     *     // ... the filter for the Photos_tags_recherches we want to count
     *   }
     * })
    **/
    count<T extends photos_tags_rechercheCountArgs>(
      args?: Subset<T, photos_tags_rechercheCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Photos_tags_rechercheCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Photos_tags_recherche.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Photos_tags_rechercheAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Photos_tags_rechercheAggregateArgs>(args: Subset<T, Photos_tags_rechercheAggregateArgs>): Prisma.PrismaPromise<GetPhotos_tags_rechercheAggregateType<T>>

    /**
     * Group by Photos_tags_recherche.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {photos_tags_rechercheGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends photos_tags_rechercheGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: photos_tags_rechercheGroupByArgs['orderBy'] }
        : { orderBy?: photos_tags_rechercheGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, photos_tags_rechercheGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPhotos_tags_rechercheGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the photos_tags_recherche model
   */
  readonly fields: photos_tags_rechercheFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for photos_tags_recherche.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__photos_tags_rechercheClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    photos_tags_recherche_link<T extends photos_tags_recherche$photos_tags_recherche_linkArgs<ExtArgs> = {}>(args?: Subset<T, photos_tags_recherche$photos_tags_recherche_linkArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$photos_tags_recherche_linkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the photos_tags_recherche model
   */
  interface photos_tags_rechercheFieldRefs {
    readonly id_tags: FieldRef<"photos_tags_recherche", 'Int'>
    readonly titre: FieldRef<"photos_tags_recherche", 'String'>
    readonly important: FieldRef<"photos_tags_recherche", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * photos_tags_recherche findUnique
   */
  export type photos_tags_rechercheFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos_tags_recherche
     */
    select?: photos_tags_rechercheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos_tags_recherche
     */
    omit?: photos_tags_rechercheOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photos_tags_rechercheInclude<ExtArgs> | null
    /**
     * Filter, which photos_tags_recherche to fetch.
     */
    where: photos_tags_rechercheWhereUniqueInput
  }

  /**
   * photos_tags_recherche findUniqueOrThrow
   */
  export type photos_tags_rechercheFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos_tags_recherche
     */
    select?: photos_tags_rechercheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos_tags_recherche
     */
    omit?: photos_tags_rechercheOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photos_tags_rechercheInclude<ExtArgs> | null
    /**
     * Filter, which photos_tags_recherche to fetch.
     */
    where: photos_tags_rechercheWhereUniqueInput
  }

  /**
   * photos_tags_recherche findFirst
   */
  export type photos_tags_rechercheFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos_tags_recherche
     */
    select?: photos_tags_rechercheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos_tags_recherche
     */
    omit?: photos_tags_rechercheOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photos_tags_rechercheInclude<ExtArgs> | null
    /**
     * Filter, which photos_tags_recherche to fetch.
     */
    where?: photos_tags_rechercheWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of photos_tags_recherches to fetch.
     */
    orderBy?: photos_tags_rechercheOrderByWithRelationInput | photos_tags_rechercheOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for photos_tags_recherches.
     */
    cursor?: photos_tags_rechercheWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` photos_tags_recherches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` photos_tags_recherches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of photos_tags_recherches.
     */
    distinct?: Photos_tags_rechercheScalarFieldEnum | Photos_tags_rechercheScalarFieldEnum[]
  }

  /**
   * photos_tags_recherche findFirstOrThrow
   */
  export type photos_tags_rechercheFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos_tags_recherche
     */
    select?: photos_tags_rechercheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos_tags_recherche
     */
    omit?: photos_tags_rechercheOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photos_tags_rechercheInclude<ExtArgs> | null
    /**
     * Filter, which photos_tags_recherche to fetch.
     */
    where?: photos_tags_rechercheWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of photos_tags_recherches to fetch.
     */
    orderBy?: photos_tags_rechercheOrderByWithRelationInput | photos_tags_rechercheOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for photos_tags_recherches.
     */
    cursor?: photos_tags_rechercheWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` photos_tags_recherches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` photos_tags_recherches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of photos_tags_recherches.
     */
    distinct?: Photos_tags_rechercheScalarFieldEnum | Photos_tags_rechercheScalarFieldEnum[]
  }

  /**
   * photos_tags_recherche findMany
   */
  export type photos_tags_rechercheFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos_tags_recherche
     */
    select?: photos_tags_rechercheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos_tags_recherche
     */
    omit?: photos_tags_rechercheOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photos_tags_rechercheInclude<ExtArgs> | null
    /**
     * Filter, which photos_tags_recherches to fetch.
     */
    where?: photos_tags_rechercheWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of photos_tags_recherches to fetch.
     */
    orderBy?: photos_tags_rechercheOrderByWithRelationInput | photos_tags_rechercheOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing photos_tags_recherches.
     */
    cursor?: photos_tags_rechercheWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` photos_tags_recherches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` photos_tags_recherches.
     */
    skip?: number
    distinct?: Photos_tags_rechercheScalarFieldEnum | Photos_tags_rechercheScalarFieldEnum[]
  }

  /**
   * photos_tags_recherche create
   */
  export type photos_tags_rechercheCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos_tags_recherche
     */
    select?: photos_tags_rechercheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos_tags_recherche
     */
    omit?: photos_tags_rechercheOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photos_tags_rechercheInclude<ExtArgs> | null
    /**
     * The data needed to create a photos_tags_recherche.
     */
    data: XOR<photos_tags_rechercheCreateInput, photos_tags_rechercheUncheckedCreateInput>
  }

  /**
   * photos_tags_recherche createMany
   */
  export type photos_tags_rechercheCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many photos_tags_recherches.
     */
    data: photos_tags_rechercheCreateManyInput | photos_tags_rechercheCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * photos_tags_recherche update
   */
  export type photos_tags_rechercheUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos_tags_recherche
     */
    select?: photos_tags_rechercheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos_tags_recherche
     */
    omit?: photos_tags_rechercheOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photos_tags_rechercheInclude<ExtArgs> | null
    /**
     * The data needed to update a photos_tags_recherche.
     */
    data: XOR<photos_tags_rechercheUpdateInput, photos_tags_rechercheUncheckedUpdateInput>
    /**
     * Choose, which photos_tags_recherche to update.
     */
    where: photos_tags_rechercheWhereUniqueInput
  }

  /**
   * photos_tags_recherche updateMany
   */
  export type photos_tags_rechercheUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update photos_tags_recherches.
     */
    data: XOR<photos_tags_rechercheUpdateManyMutationInput, photos_tags_rechercheUncheckedUpdateManyInput>
    /**
     * Filter which photos_tags_recherches to update
     */
    where?: photos_tags_rechercheWhereInput
    /**
     * Limit how many photos_tags_recherches to update.
     */
    limit?: number
  }

  /**
   * photos_tags_recherche upsert
   */
  export type photos_tags_rechercheUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos_tags_recherche
     */
    select?: photos_tags_rechercheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos_tags_recherche
     */
    omit?: photos_tags_rechercheOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photos_tags_rechercheInclude<ExtArgs> | null
    /**
     * The filter to search for the photos_tags_recherche to update in case it exists.
     */
    where: photos_tags_rechercheWhereUniqueInput
    /**
     * In case the photos_tags_recherche found by the `where` argument doesn't exist, create a new photos_tags_recherche with this data.
     */
    create: XOR<photos_tags_rechercheCreateInput, photos_tags_rechercheUncheckedCreateInput>
    /**
     * In case the photos_tags_recherche was found with the provided `where` argument, update it with this data.
     */
    update: XOR<photos_tags_rechercheUpdateInput, photos_tags_rechercheUncheckedUpdateInput>
  }

  /**
   * photos_tags_recherche delete
   */
  export type photos_tags_rechercheDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos_tags_recherche
     */
    select?: photos_tags_rechercheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos_tags_recherche
     */
    omit?: photos_tags_rechercheOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photos_tags_rechercheInclude<ExtArgs> | null
    /**
     * Filter which photos_tags_recherche to delete.
     */
    where: photos_tags_rechercheWhereUniqueInput
  }

  /**
   * photos_tags_recherche deleteMany
   */
  export type photos_tags_rechercheDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which photos_tags_recherches to delete
     */
    where?: photos_tags_rechercheWhereInput
    /**
     * Limit how many photos_tags_recherches to delete.
     */
    limit?: number
  }

  /**
   * photos_tags_recherche.photos_tags_recherche_link
   */
  export type photos_tags_recherche$photos_tags_recherche_linkArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos_tags_recherche_link
     */
    select?: photos_tags_recherche_linkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos_tags_recherche_link
     */
    omit?: photos_tags_recherche_linkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photos_tags_recherche_linkInclude<ExtArgs> | null
    where?: photos_tags_recherche_linkWhereInput
    orderBy?: photos_tags_recherche_linkOrderByWithRelationInput | photos_tags_recherche_linkOrderByWithRelationInput[]
    cursor?: photos_tags_recherche_linkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Photos_tags_recherche_linkScalarFieldEnum | Photos_tags_recherche_linkScalarFieldEnum[]
  }

  /**
   * photos_tags_recherche without action
   */
  export type photos_tags_rechercheDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos_tags_recherche
     */
    select?: photos_tags_rechercheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos_tags_recherche
     */
    omit?: photos_tags_rechercheOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photos_tags_rechercheInclude<ExtArgs> | null
  }


  /**
   * Model photos_tags_recherche_link
   */

  export type AggregatePhotos_tags_recherche_link = {
    _count: Photos_tags_recherche_linkCountAggregateOutputType | null
    _avg: Photos_tags_recherche_linkAvgAggregateOutputType | null
    _sum: Photos_tags_recherche_linkSumAggregateOutputType | null
    _min: Photos_tags_recherche_linkMinAggregateOutputType | null
    _max: Photos_tags_recherche_linkMaxAggregateOutputType | null
  }

  export type Photos_tags_recherche_linkAvgAggregateOutputType = {
    id_pho: number | null
    id_tags: number | null
  }

  export type Photos_tags_recherche_linkSumAggregateOutputType = {
    id_pho: number | null
    id_tags: number | null
  }

  export type Photos_tags_recherche_linkMinAggregateOutputType = {
    id_pho: number | null
    id_tags: number | null
  }

  export type Photos_tags_recherche_linkMaxAggregateOutputType = {
    id_pho: number | null
    id_tags: number | null
  }

  export type Photos_tags_recherche_linkCountAggregateOutputType = {
    id_pho: number
    id_tags: number
    _all: number
  }


  export type Photos_tags_recherche_linkAvgAggregateInputType = {
    id_pho?: true
    id_tags?: true
  }

  export type Photos_tags_recherche_linkSumAggregateInputType = {
    id_pho?: true
    id_tags?: true
  }

  export type Photos_tags_recherche_linkMinAggregateInputType = {
    id_pho?: true
    id_tags?: true
  }

  export type Photos_tags_recherche_linkMaxAggregateInputType = {
    id_pho?: true
    id_tags?: true
  }

  export type Photos_tags_recherche_linkCountAggregateInputType = {
    id_pho?: true
    id_tags?: true
    _all?: true
  }

  export type Photos_tags_recherche_linkAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which photos_tags_recherche_link to aggregate.
     */
    where?: photos_tags_recherche_linkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of photos_tags_recherche_links to fetch.
     */
    orderBy?: photos_tags_recherche_linkOrderByWithRelationInput | photos_tags_recherche_linkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: photos_tags_recherche_linkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` photos_tags_recherche_links from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` photos_tags_recherche_links.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned photos_tags_recherche_links
    **/
    _count?: true | Photos_tags_recherche_linkCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Photos_tags_recherche_linkAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Photos_tags_recherche_linkSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Photos_tags_recherche_linkMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Photos_tags_recherche_linkMaxAggregateInputType
  }

  export type GetPhotos_tags_recherche_linkAggregateType<T extends Photos_tags_recherche_linkAggregateArgs> = {
        [P in keyof T & keyof AggregatePhotos_tags_recherche_link]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePhotos_tags_recherche_link[P]>
      : GetScalarType<T[P], AggregatePhotos_tags_recherche_link[P]>
  }




  export type photos_tags_recherche_linkGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: photos_tags_recherche_linkWhereInput
    orderBy?: photos_tags_recherche_linkOrderByWithAggregationInput | photos_tags_recherche_linkOrderByWithAggregationInput[]
    by: Photos_tags_recherche_linkScalarFieldEnum[] | Photos_tags_recherche_linkScalarFieldEnum
    having?: photos_tags_recherche_linkScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Photos_tags_recherche_linkCountAggregateInputType | true
    _avg?: Photos_tags_recherche_linkAvgAggregateInputType
    _sum?: Photos_tags_recherche_linkSumAggregateInputType
    _min?: Photos_tags_recherche_linkMinAggregateInputType
    _max?: Photos_tags_recherche_linkMaxAggregateInputType
  }

  export type Photos_tags_recherche_linkGroupByOutputType = {
    id_pho: number
    id_tags: number
    _count: Photos_tags_recherche_linkCountAggregateOutputType | null
    _avg: Photos_tags_recherche_linkAvgAggregateOutputType | null
    _sum: Photos_tags_recherche_linkSumAggregateOutputType | null
    _min: Photos_tags_recherche_linkMinAggregateOutputType | null
    _max: Photos_tags_recherche_linkMaxAggregateOutputType | null
  }

  type GetPhotos_tags_recherche_linkGroupByPayload<T extends photos_tags_recherche_linkGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Photos_tags_recherche_linkGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Photos_tags_recherche_linkGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Photos_tags_recherche_linkGroupByOutputType[P]>
            : GetScalarType<T[P], Photos_tags_recherche_linkGroupByOutputType[P]>
        }
      >
    >


  export type photos_tags_recherche_linkSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_pho?: boolean
    id_tags?: boolean
    photos?: boolean | photosDefaultArgs<ExtArgs>
    photos_tags_recherche?: boolean | photos_tags_rechercheDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["photos_tags_recherche_link"]>



  export type photos_tags_recherche_linkSelectScalar = {
    id_pho?: boolean
    id_tags?: boolean
  }

  export type photos_tags_recherche_linkOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id_pho" | "id_tags", ExtArgs["result"]["photos_tags_recherche_link"]>
  export type photos_tags_recherche_linkInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    photos?: boolean | photosDefaultArgs<ExtArgs>
    photos_tags_recherche?: boolean | photos_tags_rechercheDefaultArgs<ExtArgs>
  }

  export type $photos_tags_recherche_linkPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "photos_tags_recherche_link"
    objects: {
      photos: Prisma.$photosPayload<ExtArgs>
      photos_tags_recherche: Prisma.$photos_tags_recherchePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id_pho: number
      id_tags: number
    }, ExtArgs["result"]["photos_tags_recherche_link"]>
    composites: {}
  }

  type photos_tags_recherche_linkGetPayload<S extends boolean | null | undefined | photos_tags_recherche_linkDefaultArgs> = $Result.GetResult<Prisma.$photos_tags_recherche_linkPayload, S>

  type photos_tags_recherche_linkCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<photos_tags_recherche_linkFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Photos_tags_recherche_linkCountAggregateInputType | true
    }

  export interface photos_tags_recherche_linkDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['photos_tags_recherche_link'], meta: { name: 'photos_tags_recherche_link' } }
    /**
     * Find zero or one Photos_tags_recherche_link that matches the filter.
     * @param {photos_tags_recherche_linkFindUniqueArgs} args - Arguments to find a Photos_tags_recherche_link
     * @example
     * // Get one Photos_tags_recherche_link
     * const photos_tags_recherche_link = await prisma.photos_tags_recherche_link.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends photos_tags_recherche_linkFindUniqueArgs>(args: SelectSubset<T, photos_tags_recherche_linkFindUniqueArgs<ExtArgs>>): Prisma__photos_tags_recherche_linkClient<$Result.GetResult<Prisma.$photos_tags_recherche_linkPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Photos_tags_recherche_link that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {photos_tags_recherche_linkFindUniqueOrThrowArgs} args - Arguments to find a Photos_tags_recherche_link
     * @example
     * // Get one Photos_tags_recherche_link
     * const photos_tags_recherche_link = await prisma.photos_tags_recherche_link.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends photos_tags_recherche_linkFindUniqueOrThrowArgs>(args: SelectSubset<T, photos_tags_recherche_linkFindUniqueOrThrowArgs<ExtArgs>>): Prisma__photos_tags_recherche_linkClient<$Result.GetResult<Prisma.$photos_tags_recherche_linkPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Photos_tags_recherche_link that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {photos_tags_recherche_linkFindFirstArgs} args - Arguments to find a Photos_tags_recherche_link
     * @example
     * // Get one Photos_tags_recherche_link
     * const photos_tags_recherche_link = await prisma.photos_tags_recherche_link.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends photos_tags_recherche_linkFindFirstArgs>(args?: SelectSubset<T, photos_tags_recherche_linkFindFirstArgs<ExtArgs>>): Prisma__photos_tags_recherche_linkClient<$Result.GetResult<Prisma.$photos_tags_recherche_linkPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Photos_tags_recherche_link that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {photos_tags_recherche_linkFindFirstOrThrowArgs} args - Arguments to find a Photos_tags_recherche_link
     * @example
     * // Get one Photos_tags_recherche_link
     * const photos_tags_recherche_link = await prisma.photos_tags_recherche_link.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends photos_tags_recherche_linkFindFirstOrThrowArgs>(args?: SelectSubset<T, photos_tags_recherche_linkFindFirstOrThrowArgs<ExtArgs>>): Prisma__photos_tags_recherche_linkClient<$Result.GetResult<Prisma.$photos_tags_recherche_linkPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Photos_tags_recherche_links that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {photos_tags_recherche_linkFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Photos_tags_recherche_links
     * const photos_tags_recherche_links = await prisma.photos_tags_recherche_link.findMany()
     * 
     * // Get first 10 Photos_tags_recherche_links
     * const photos_tags_recherche_links = await prisma.photos_tags_recherche_link.findMany({ take: 10 })
     * 
     * // Only select the `id_pho`
     * const photos_tags_recherche_linkWithId_phoOnly = await prisma.photos_tags_recherche_link.findMany({ select: { id_pho: true } })
     * 
     */
    findMany<T extends photos_tags_recherche_linkFindManyArgs>(args?: SelectSubset<T, photos_tags_recherche_linkFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$photos_tags_recherche_linkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Photos_tags_recherche_link.
     * @param {photos_tags_recherche_linkCreateArgs} args - Arguments to create a Photos_tags_recherche_link.
     * @example
     * // Create one Photos_tags_recherche_link
     * const Photos_tags_recherche_link = await prisma.photos_tags_recherche_link.create({
     *   data: {
     *     // ... data to create a Photos_tags_recherche_link
     *   }
     * })
     * 
     */
    create<T extends photos_tags_recherche_linkCreateArgs>(args: SelectSubset<T, photos_tags_recherche_linkCreateArgs<ExtArgs>>): Prisma__photos_tags_recherche_linkClient<$Result.GetResult<Prisma.$photos_tags_recherche_linkPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Photos_tags_recherche_links.
     * @param {photos_tags_recherche_linkCreateManyArgs} args - Arguments to create many Photos_tags_recherche_links.
     * @example
     * // Create many Photos_tags_recherche_links
     * const photos_tags_recherche_link = await prisma.photos_tags_recherche_link.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends photos_tags_recherche_linkCreateManyArgs>(args?: SelectSubset<T, photos_tags_recherche_linkCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Photos_tags_recherche_link.
     * @param {photos_tags_recherche_linkDeleteArgs} args - Arguments to delete one Photos_tags_recherche_link.
     * @example
     * // Delete one Photos_tags_recherche_link
     * const Photos_tags_recherche_link = await prisma.photos_tags_recherche_link.delete({
     *   where: {
     *     // ... filter to delete one Photos_tags_recherche_link
     *   }
     * })
     * 
     */
    delete<T extends photos_tags_recherche_linkDeleteArgs>(args: SelectSubset<T, photos_tags_recherche_linkDeleteArgs<ExtArgs>>): Prisma__photos_tags_recherche_linkClient<$Result.GetResult<Prisma.$photos_tags_recherche_linkPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Photos_tags_recherche_link.
     * @param {photos_tags_recherche_linkUpdateArgs} args - Arguments to update one Photos_tags_recherche_link.
     * @example
     * // Update one Photos_tags_recherche_link
     * const photos_tags_recherche_link = await prisma.photos_tags_recherche_link.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends photos_tags_recherche_linkUpdateArgs>(args: SelectSubset<T, photos_tags_recherche_linkUpdateArgs<ExtArgs>>): Prisma__photos_tags_recherche_linkClient<$Result.GetResult<Prisma.$photos_tags_recherche_linkPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Photos_tags_recherche_links.
     * @param {photos_tags_recherche_linkDeleteManyArgs} args - Arguments to filter Photos_tags_recherche_links to delete.
     * @example
     * // Delete a few Photos_tags_recherche_links
     * const { count } = await prisma.photos_tags_recherche_link.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends photos_tags_recherche_linkDeleteManyArgs>(args?: SelectSubset<T, photos_tags_recherche_linkDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Photos_tags_recherche_links.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {photos_tags_recherche_linkUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Photos_tags_recherche_links
     * const photos_tags_recherche_link = await prisma.photos_tags_recherche_link.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends photos_tags_recherche_linkUpdateManyArgs>(args: SelectSubset<T, photos_tags_recherche_linkUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Photos_tags_recherche_link.
     * @param {photos_tags_recherche_linkUpsertArgs} args - Arguments to update or create a Photos_tags_recherche_link.
     * @example
     * // Update or create a Photos_tags_recherche_link
     * const photos_tags_recherche_link = await prisma.photos_tags_recherche_link.upsert({
     *   create: {
     *     // ... data to create a Photos_tags_recherche_link
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Photos_tags_recherche_link we want to update
     *   }
     * })
     */
    upsert<T extends photos_tags_recherche_linkUpsertArgs>(args: SelectSubset<T, photos_tags_recherche_linkUpsertArgs<ExtArgs>>): Prisma__photos_tags_recherche_linkClient<$Result.GetResult<Prisma.$photos_tags_recherche_linkPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Photos_tags_recherche_links.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {photos_tags_recherche_linkCountArgs} args - Arguments to filter Photos_tags_recherche_links to count.
     * @example
     * // Count the number of Photos_tags_recherche_links
     * const count = await prisma.photos_tags_recherche_link.count({
     *   where: {
     *     // ... the filter for the Photos_tags_recherche_links we want to count
     *   }
     * })
    **/
    count<T extends photos_tags_recherche_linkCountArgs>(
      args?: Subset<T, photos_tags_recherche_linkCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Photos_tags_recherche_linkCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Photos_tags_recherche_link.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Photos_tags_recherche_linkAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Photos_tags_recherche_linkAggregateArgs>(args: Subset<T, Photos_tags_recherche_linkAggregateArgs>): Prisma.PrismaPromise<GetPhotos_tags_recherche_linkAggregateType<T>>

    /**
     * Group by Photos_tags_recherche_link.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {photos_tags_recherche_linkGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends photos_tags_recherche_linkGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: photos_tags_recherche_linkGroupByArgs['orderBy'] }
        : { orderBy?: photos_tags_recherche_linkGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, photos_tags_recherche_linkGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPhotos_tags_recherche_linkGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the photos_tags_recherche_link model
   */
  readonly fields: photos_tags_recherche_linkFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for photos_tags_recherche_link.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__photos_tags_recherche_linkClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    photos<T extends photosDefaultArgs<ExtArgs> = {}>(args?: Subset<T, photosDefaultArgs<ExtArgs>>): Prisma__photosClient<$Result.GetResult<Prisma.$photosPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    photos_tags_recherche<T extends photos_tags_rechercheDefaultArgs<ExtArgs> = {}>(args?: Subset<T, photos_tags_rechercheDefaultArgs<ExtArgs>>): Prisma__photos_tags_rechercheClient<$Result.GetResult<Prisma.$photos_tags_recherchePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the photos_tags_recherche_link model
   */
  interface photos_tags_recherche_linkFieldRefs {
    readonly id_pho: FieldRef<"photos_tags_recherche_link", 'Int'>
    readonly id_tags: FieldRef<"photos_tags_recherche_link", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * photos_tags_recherche_link findUnique
   */
  export type photos_tags_recherche_linkFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos_tags_recherche_link
     */
    select?: photos_tags_recherche_linkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos_tags_recherche_link
     */
    omit?: photos_tags_recherche_linkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photos_tags_recherche_linkInclude<ExtArgs> | null
    /**
     * Filter, which photos_tags_recherche_link to fetch.
     */
    where: photos_tags_recherche_linkWhereUniqueInput
  }

  /**
   * photos_tags_recherche_link findUniqueOrThrow
   */
  export type photos_tags_recherche_linkFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos_tags_recherche_link
     */
    select?: photos_tags_recherche_linkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos_tags_recherche_link
     */
    omit?: photos_tags_recherche_linkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photos_tags_recherche_linkInclude<ExtArgs> | null
    /**
     * Filter, which photos_tags_recherche_link to fetch.
     */
    where: photos_tags_recherche_linkWhereUniqueInput
  }

  /**
   * photos_tags_recherche_link findFirst
   */
  export type photos_tags_recherche_linkFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos_tags_recherche_link
     */
    select?: photos_tags_recherche_linkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos_tags_recherche_link
     */
    omit?: photos_tags_recherche_linkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photos_tags_recherche_linkInclude<ExtArgs> | null
    /**
     * Filter, which photos_tags_recherche_link to fetch.
     */
    where?: photos_tags_recherche_linkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of photos_tags_recherche_links to fetch.
     */
    orderBy?: photos_tags_recherche_linkOrderByWithRelationInput | photos_tags_recherche_linkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for photos_tags_recherche_links.
     */
    cursor?: photos_tags_recherche_linkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` photos_tags_recherche_links from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` photos_tags_recherche_links.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of photos_tags_recherche_links.
     */
    distinct?: Photos_tags_recherche_linkScalarFieldEnum | Photos_tags_recherche_linkScalarFieldEnum[]
  }

  /**
   * photos_tags_recherche_link findFirstOrThrow
   */
  export type photos_tags_recherche_linkFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos_tags_recherche_link
     */
    select?: photos_tags_recherche_linkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos_tags_recherche_link
     */
    omit?: photos_tags_recherche_linkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photos_tags_recherche_linkInclude<ExtArgs> | null
    /**
     * Filter, which photos_tags_recherche_link to fetch.
     */
    where?: photos_tags_recherche_linkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of photos_tags_recherche_links to fetch.
     */
    orderBy?: photos_tags_recherche_linkOrderByWithRelationInput | photos_tags_recherche_linkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for photos_tags_recherche_links.
     */
    cursor?: photos_tags_recherche_linkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` photos_tags_recherche_links from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` photos_tags_recherche_links.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of photos_tags_recherche_links.
     */
    distinct?: Photos_tags_recherche_linkScalarFieldEnum | Photos_tags_recherche_linkScalarFieldEnum[]
  }

  /**
   * photos_tags_recherche_link findMany
   */
  export type photos_tags_recherche_linkFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos_tags_recherche_link
     */
    select?: photos_tags_recherche_linkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos_tags_recherche_link
     */
    omit?: photos_tags_recherche_linkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photos_tags_recherche_linkInclude<ExtArgs> | null
    /**
     * Filter, which photos_tags_recherche_links to fetch.
     */
    where?: photos_tags_recherche_linkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of photos_tags_recherche_links to fetch.
     */
    orderBy?: photos_tags_recherche_linkOrderByWithRelationInput | photos_tags_recherche_linkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing photos_tags_recherche_links.
     */
    cursor?: photos_tags_recherche_linkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` photos_tags_recherche_links from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` photos_tags_recherche_links.
     */
    skip?: number
    distinct?: Photos_tags_recherche_linkScalarFieldEnum | Photos_tags_recherche_linkScalarFieldEnum[]
  }

  /**
   * photos_tags_recherche_link create
   */
  export type photos_tags_recherche_linkCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos_tags_recherche_link
     */
    select?: photos_tags_recherche_linkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos_tags_recherche_link
     */
    omit?: photos_tags_recherche_linkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photos_tags_recherche_linkInclude<ExtArgs> | null
    /**
     * The data needed to create a photos_tags_recherche_link.
     */
    data: XOR<photos_tags_recherche_linkCreateInput, photos_tags_recherche_linkUncheckedCreateInput>
  }

  /**
   * photos_tags_recherche_link createMany
   */
  export type photos_tags_recherche_linkCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many photos_tags_recherche_links.
     */
    data: photos_tags_recherche_linkCreateManyInput | photos_tags_recherche_linkCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * photos_tags_recherche_link update
   */
  export type photos_tags_recherche_linkUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos_tags_recherche_link
     */
    select?: photos_tags_recherche_linkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos_tags_recherche_link
     */
    omit?: photos_tags_recherche_linkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photos_tags_recherche_linkInclude<ExtArgs> | null
    /**
     * The data needed to update a photos_tags_recherche_link.
     */
    data: XOR<photos_tags_recherche_linkUpdateInput, photos_tags_recherche_linkUncheckedUpdateInput>
    /**
     * Choose, which photos_tags_recherche_link to update.
     */
    where: photos_tags_recherche_linkWhereUniqueInput
  }

  /**
   * photos_tags_recherche_link updateMany
   */
  export type photos_tags_recherche_linkUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update photos_tags_recherche_links.
     */
    data: XOR<photos_tags_recherche_linkUpdateManyMutationInput, photos_tags_recherche_linkUncheckedUpdateManyInput>
    /**
     * Filter which photos_tags_recherche_links to update
     */
    where?: photos_tags_recherche_linkWhereInput
    /**
     * Limit how many photos_tags_recherche_links to update.
     */
    limit?: number
  }

  /**
   * photos_tags_recherche_link upsert
   */
  export type photos_tags_recherche_linkUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos_tags_recherche_link
     */
    select?: photos_tags_recherche_linkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos_tags_recherche_link
     */
    omit?: photos_tags_recherche_linkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photos_tags_recherche_linkInclude<ExtArgs> | null
    /**
     * The filter to search for the photos_tags_recherche_link to update in case it exists.
     */
    where: photos_tags_recherche_linkWhereUniqueInput
    /**
     * In case the photos_tags_recherche_link found by the `where` argument doesn't exist, create a new photos_tags_recherche_link with this data.
     */
    create: XOR<photos_tags_recherche_linkCreateInput, photos_tags_recherche_linkUncheckedCreateInput>
    /**
     * In case the photos_tags_recherche_link was found with the provided `where` argument, update it with this data.
     */
    update: XOR<photos_tags_recherche_linkUpdateInput, photos_tags_recherche_linkUncheckedUpdateInput>
  }

  /**
   * photos_tags_recherche_link delete
   */
  export type photos_tags_recherche_linkDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos_tags_recherche_link
     */
    select?: photos_tags_recherche_linkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos_tags_recherche_link
     */
    omit?: photos_tags_recherche_linkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photos_tags_recherche_linkInclude<ExtArgs> | null
    /**
     * Filter which photos_tags_recherche_link to delete.
     */
    where: photos_tags_recherche_linkWhereUniqueInput
  }

  /**
   * photos_tags_recherche_link deleteMany
   */
  export type photos_tags_recherche_linkDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which photos_tags_recherche_links to delete
     */
    where?: photos_tags_recherche_linkWhereInput
    /**
     * Limit how many photos_tags_recherche_links to delete.
     */
    limit?: number
  }

  /**
   * photos_tags_recherche_link without action
   */
  export type photos_tags_recherche_linkDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photos_tags_recherche_link
     */
    select?: photos_tags_recherche_linkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photos_tags_recherche_link
     */
    omit?: photos_tags_recherche_linkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photos_tags_recherche_linkInclude<ExtArgs> | null
  }


  /**
   * Model session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionMinAggregateOutputType = {
    id: string | null
    expiresAt: Date | null
    token: string | null
    createdAt: Date | null
    updatedAt: Date | null
    ipAddress: string | null
    userAgent: string | null
    userId: string | null
  }

  export type SessionMaxAggregateOutputType = {
    id: string | null
    expiresAt: Date | null
    token: string | null
    createdAt: Date | null
    updatedAt: Date | null
    ipAddress: string | null
    userAgent: string | null
    userId: string | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    expiresAt: number
    token: number
    createdAt: number
    updatedAt: number
    ipAddress: number
    userAgent: number
    userId: number
    _all: number
  }


  export type SessionMinAggregateInputType = {
    id?: true
    expiresAt?: true
    token?: true
    createdAt?: true
    updatedAt?: true
    ipAddress?: true
    userAgent?: true
    userId?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    expiresAt?: true
    token?: true
    createdAt?: true
    updatedAt?: true
    ipAddress?: true
    userAgent?: true
    userId?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    expiresAt?: true
    token?: true
    createdAt?: true
    updatedAt?: true
    ipAddress?: true
    userAgent?: true
    userId?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which session to aggregate.
     */
    where?: sessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sessions to fetch.
     */
    orderBy?: sessionOrderByWithRelationInput | sessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: sessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type sessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: sessionWhereInput
    orderBy?: sessionOrderByWithAggregationInput | sessionOrderByWithAggregationInput[]
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum
    having?: sessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }

  export type SessionGroupByOutputType = {
    id: string
    expiresAt: Date
    token: string
    createdAt: Date
    updatedAt: Date
    ipAddress: string | null
    userAgent: string | null
    userId: string
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends sessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type sessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    expiresAt?: boolean
    token?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    userId?: boolean
  }, ExtArgs["result"]["session"]>



  export type sessionSelectScalar = {
    id?: boolean
    expiresAt?: boolean
    token?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    userId?: boolean
  }

  export type sessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "expiresAt" | "token" | "createdAt" | "updatedAt" | "ipAddress" | "userAgent" | "userId", ExtArgs["result"]["session"]>

  export type $sessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "session"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      expiresAt: Date
      token: string
      createdAt: Date
      updatedAt: Date
      ipAddress: string | null
      userAgent: string | null
      userId: string
    }, ExtArgs["result"]["session"]>
    composites: {}
  }

  type sessionGetPayload<S extends boolean | null | undefined | sessionDefaultArgs> = $Result.GetResult<Prisma.$sessionPayload, S>

  type sessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<sessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface sessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['session'], meta: { name: 'session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {sessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends sessionFindUniqueArgs>(args: SelectSubset<T, sessionFindUniqueArgs<ExtArgs>>): Prisma__sessionClient<$Result.GetResult<Prisma.$sessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {sessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends sessionFindUniqueOrThrowArgs>(args: SelectSubset<T, sessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__sessionClient<$Result.GetResult<Prisma.$sessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends sessionFindFirstArgs>(args?: SelectSubset<T, sessionFindFirstArgs<ExtArgs>>): Prisma__sessionClient<$Result.GetResult<Prisma.$sessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends sessionFindFirstOrThrowArgs>(args?: SelectSubset<T, sessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__sessionClient<$Result.GetResult<Prisma.$sessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends sessionFindManyArgs>(args?: SelectSubset<T, sessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$sessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Session.
     * @param {sessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
     */
    create<T extends sessionCreateArgs>(args: SelectSubset<T, sessionCreateArgs<ExtArgs>>): Prisma__sessionClient<$Result.GetResult<Prisma.$sessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sessions.
     * @param {sessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends sessionCreateManyArgs>(args?: SelectSubset<T, sessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Session.
     * @param {sessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
     */
    delete<T extends sessionDeleteArgs>(args: SelectSubset<T, sessionDeleteArgs<ExtArgs>>): Prisma__sessionClient<$Result.GetResult<Prisma.$sessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Session.
     * @param {sessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends sessionUpdateArgs>(args: SelectSubset<T, sessionUpdateArgs<ExtArgs>>): Prisma__sessionClient<$Result.GetResult<Prisma.$sessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sessions.
     * @param {sessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends sessionDeleteManyArgs>(args?: SelectSubset<T, sessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends sessionUpdateManyArgs>(args: SelectSubset<T, sessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Session.
     * @param {sessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends sessionUpsertArgs>(args: SelectSubset<T, sessionUpsertArgs<ExtArgs>>): Prisma__sessionClient<$Result.GetResult<Prisma.$sessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends sessionCountArgs>(
      args?: Subset<T, sessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends sessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: sessionGroupByArgs['orderBy'] }
        : { orderBy?: sessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, sessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the session model
   */
  readonly fields: sessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__sessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the session model
   */
  interface sessionFieldRefs {
    readonly id: FieldRef<"session", 'String'>
    readonly expiresAt: FieldRef<"session", 'DateTime'>
    readonly token: FieldRef<"session", 'String'>
    readonly createdAt: FieldRef<"session", 'DateTime'>
    readonly updatedAt: FieldRef<"session", 'DateTime'>
    readonly ipAddress: FieldRef<"session", 'String'>
    readonly userAgent: FieldRef<"session", 'String'>
    readonly userId: FieldRef<"session", 'String'>
  }
    

  // Custom InputTypes
  /**
   * session findUnique
   */
  export type sessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session
     */
    select?: sessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the session
     */
    omit?: sessionOmit<ExtArgs> | null
    /**
     * Filter, which session to fetch.
     */
    where: sessionWhereUniqueInput
  }

  /**
   * session findUniqueOrThrow
   */
  export type sessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session
     */
    select?: sessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the session
     */
    omit?: sessionOmit<ExtArgs> | null
    /**
     * Filter, which session to fetch.
     */
    where: sessionWhereUniqueInput
  }

  /**
   * session findFirst
   */
  export type sessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session
     */
    select?: sessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the session
     */
    omit?: sessionOmit<ExtArgs> | null
    /**
     * Filter, which session to fetch.
     */
    where?: sessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sessions to fetch.
     */
    orderBy?: sessionOrderByWithRelationInput | sessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sessions.
     */
    cursor?: sessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * session findFirstOrThrow
   */
  export type sessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session
     */
    select?: sessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the session
     */
    omit?: sessionOmit<ExtArgs> | null
    /**
     * Filter, which session to fetch.
     */
    where?: sessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sessions to fetch.
     */
    orderBy?: sessionOrderByWithRelationInput | sessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sessions.
     */
    cursor?: sessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * session findMany
   */
  export type sessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session
     */
    select?: sessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the session
     */
    omit?: sessionOmit<ExtArgs> | null
    /**
     * Filter, which sessions to fetch.
     */
    where?: sessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sessions to fetch.
     */
    orderBy?: sessionOrderByWithRelationInput | sessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing sessions.
     */
    cursor?: sessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sessions.
     */
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * session create
   */
  export type sessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session
     */
    select?: sessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the session
     */
    omit?: sessionOmit<ExtArgs> | null
    /**
     * The data needed to create a session.
     */
    data: XOR<sessionCreateInput, sessionUncheckedCreateInput>
  }

  /**
   * session createMany
   */
  export type sessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many sessions.
     */
    data: sessionCreateManyInput | sessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * session update
   */
  export type sessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session
     */
    select?: sessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the session
     */
    omit?: sessionOmit<ExtArgs> | null
    /**
     * The data needed to update a session.
     */
    data: XOR<sessionUpdateInput, sessionUncheckedUpdateInput>
    /**
     * Choose, which session to update.
     */
    where: sessionWhereUniqueInput
  }

  /**
   * session updateMany
   */
  export type sessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update sessions.
     */
    data: XOR<sessionUpdateManyMutationInput, sessionUncheckedUpdateManyInput>
    /**
     * Filter which sessions to update
     */
    where?: sessionWhereInput
    /**
     * Limit how many sessions to update.
     */
    limit?: number
  }

  /**
   * session upsert
   */
  export type sessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session
     */
    select?: sessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the session
     */
    omit?: sessionOmit<ExtArgs> | null
    /**
     * The filter to search for the session to update in case it exists.
     */
    where: sessionWhereUniqueInput
    /**
     * In case the session found by the `where` argument doesn't exist, create a new session with this data.
     */
    create: XOR<sessionCreateInput, sessionUncheckedCreateInput>
    /**
     * In case the session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<sessionUpdateInput, sessionUncheckedUpdateInput>
  }

  /**
   * session delete
   */
  export type sessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session
     */
    select?: sessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the session
     */
    omit?: sessionOmit<ExtArgs> | null
    /**
     * Filter which session to delete.
     */
    where: sessionWhereUniqueInput
  }

  /**
   * session deleteMany
   */
  export type sessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which sessions to delete
     */
    where?: sessionWhereInput
    /**
     * Limit how many sessions to delete.
     */
    limit?: number
  }

  /**
   * session without action
   */
  export type sessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session
     */
    select?: sessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the session
     */
    omit?: sessionOmit<ExtArgs> | null
  }


  /**
   * Model user
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    emailVerified: boolean | null
    image: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    emailVerified: boolean | null
    image: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    name: number
    email: number
    emailVerified: number
    image: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    emailVerified?: true
    image?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    emailVerified?: true
    image?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    emailVerified?: true
    image?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which user to aggregate.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type userGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: userWhereInput
    orderBy?: userOrderByWithAggregationInput | userOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: userScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image: string | null
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends userGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type userSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>



  export type userSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type userOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "emailVerified" | "image" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>

  export type $userPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "user"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      email: string
      emailVerified: boolean
      image: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type userGetPayload<S extends boolean | null | undefined | userDefaultArgs> = $Result.GetResult<Prisma.$userPayload, S>

  type userCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<userFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface userDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['user'], meta: { name: 'user' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {userFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends userFindUniqueArgs>(args: SelectSubset<T, userFindUniqueArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {userFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends userFindUniqueOrThrowArgs>(args: SelectSubset<T, userFindUniqueOrThrowArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends userFindFirstArgs>(args?: SelectSubset<T, userFindFirstArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends userFindFirstOrThrowArgs>(args?: SelectSubset<T, userFindFirstOrThrowArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends userFindManyArgs>(args?: SelectSubset<T, userFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {userCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends userCreateArgs>(args: SelectSubset<T, userCreateArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {userCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends userCreateManyArgs>(args?: SelectSubset<T, userCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {userDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends userDeleteArgs>(args: SelectSubset<T, userDeleteArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {userUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends userUpdateArgs>(args: SelectSubset<T, userUpdateArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {userDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends userDeleteManyArgs>(args?: SelectSubset<T, userDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends userUpdateManyArgs>(args: SelectSubset<T, userUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {userUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends userUpsertArgs>(args: SelectSubset<T, userUpsertArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends userCountArgs>(
      args?: Subset<T, userCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends userGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: userGroupByArgs['orderBy'] }
        : { orderBy?: userGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, userGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the user model
   */
  readonly fields: userFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for user.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__userClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the user model
   */
  interface userFieldRefs {
    readonly id: FieldRef<"user", 'String'>
    readonly name: FieldRef<"user", 'String'>
    readonly email: FieldRef<"user", 'String'>
    readonly emailVerified: FieldRef<"user", 'Boolean'>
    readonly image: FieldRef<"user", 'String'>
    readonly createdAt: FieldRef<"user", 'DateTime'>
    readonly updatedAt: FieldRef<"user", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * user findUnique
   */
  export type userFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where: userWhereUniqueInput
  }

  /**
   * user findUniqueOrThrow
   */
  export type userFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where: userWhereUniqueInput
  }

  /**
   * user findFirst
   */
  export type userFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * user findFirstOrThrow
   */
  export type userFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * user findMany
   */
  export type userFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing users.
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * user create
   */
  export type userCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * The data needed to create a user.
     */
    data: XOR<userCreateInput, userUncheckedCreateInput>
  }

  /**
   * user createMany
   */
  export type userCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many users.
     */
    data: userCreateManyInput | userCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * user update
   */
  export type userUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * The data needed to update a user.
     */
    data: XOR<userUpdateInput, userUncheckedUpdateInput>
    /**
     * Choose, which user to update.
     */
    where: userWhereUniqueInput
  }

  /**
   * user updateMany
   */
  export type userUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update users.
     */
    data: XOR<userUpdateManyMutationInput, userUncheckedUpdateManyInput>
    /**
     * Filter which users to update
     */
    where?: userWhereInput
    /**
     * Limit how many users to update.
     */
    limit?: number
  }

  /**
   * user upsert
   */
  export type userUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * The filter to search for the user to update in case it exists.
     */
    where: userWhereUniqueInput
    /**
     * In case the user found by the `where` argument doesn't exist, create a new user with this data.
     */
    create: XOR<userCreateInput, userUncheckedCreateInput>
    /**
     * In case the user was found with the provided `where` argument, update it with this data.
     */
    update: XOR<userUpdateInput, userUncheckedUpdateInput>
  }

  /**
   * user delete
   */
  export type userDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Filter which user to delete.
     */
    where: userWhereUniqueInput
  }

  /**
   * user deleteMany
   */
  export type userDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to delete
     */
    where?: userWhereInput
    /**
     * Limit how many users to delete.
     */
    limit?: number
  }

  /**
   * user without action
   */
  export type userDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
  }


  /**
   * Model utilisateurs
   */

  export type AggregateUtilisateurs = {
    _count: UtilisateursCountAggregateOutputType | null
    _avg: UtilisateursAvgAggregateOutputType | null
    _sum: UtilisateursSumAggregateOutputType | null
    _min: UtilisateursMinAggregateOutputType | null
    _max: UtilisateursMaxAggregateOutputType | null
  }

  export type UtilisateursAvgAggregateOutputType = {
    id_user: number | null
  }

  export type UtilisateursSumAggregateOutputType = {
    id_user: number | null
  }

  export type UtilisateursMinAggregateOutputType = {
    id_user: number | null
    img: string | null
    email: string | null
    username: string | null
    password: string | null
    role: string | null
  }

  export type UtilisateursMaxAggregateOutputType = {
    id_user: number | null
    img: string | null
    email: string | null
    username: string | null
    password: string | null
    role: string | null
  }

  export type UtilisateursCountAggregateOutputType = {
    id_user: number
    img: number
    email: number
    username: number
    password: number
    role: number
    _all: number
  }


  export type UtilisateursAvgAggregateInputType = {
    id_user?: true
  }

  export type UtilisateursSumAggregateInputType = {
    id_user?: true
  }

  export type UtilisateursMinAggregateInputType = {
    id_user?: true
    img?: true
    email?: true
    username?: true
    password?: true
    role?: true
  }

  export type UtilisateursMaxAggregateInputType = {
    id_user?: true
    img?: true
    email?: true
    username?: true
    password?: true
    role?: true
  }

  export type UtilisateursCountAggregateInputType = {
    id_user?: true
    img?: true
    email?: true
    username?: true
    password?: true
    role?: true
    _all?: true
  }

  export type UtilisateursAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which utilisateurs to aggregate.
     */
    where?: utilisateursWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of utilisateurs to fetch.
     */
    orderBy?: utilisateursOrderByWithRelationInput | utilisateursOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: utilisateursWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` utilisateurs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` utilisateurs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned utilisateurs
    **/
    _count?: true | UtilisateursCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UtilisateursAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UtilisateursSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UtilisateursMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UtilisateursMaxAggregateInputType
  }

  export type GetUtilisateursAggregateType<T extends UtilisateursAggregateArgs> = {
        [P in keyof T & keyof AggregateUtilisateurs]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUtilisateurs[P]>
      : GetScalarType<T[P], AggregateUtilisateurs[P]>
  }




  export type utilisateursGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: utilisateursWhereInput
    orderBy?: utilisateursOrderByWithAggregationInput | utilisateursOrderByWithAggregationInput[]
    by: UtilisateursScalarFieldEnum[] | UtilisateursScalarFieldEnum
    having?: utilisateursScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UtilisateursCountAggregateInputType | true
    _avg?: UtilisateursAvgAggregateInputType
    _sum?: UtilisateursSumAggregateInputType
    _min?: UtilisateursMinAggregateInputType
    _max?: UtilisateursMaxAggregateInputType
  }

  export type UtilisateursGroupByOutputType = {
    id_user: number
    img: string
    email: string | null
    username: string
    password: string
    role: string
    _count: UtilisateursCountAggregateOutputType | null
    _avg: UtilisateursAvgAggregateOutputType | null
    _sum: UtilisateursSumAggregateOutputType | null
    _min: UtilisateursMinAggregateOutputType | null
    _max: UtilisateursMaxAggregateOutputType | null
  }

  type GetUtilisateursGroupByPayload<T extends utilisateursGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UtilisateursGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UtilisateursGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UtilisateursGroupByOutputType[P]>
            : GetScalarType<T[P], UtilisateursGroupByOutputType[P]>
        }
      >
    >


  export type utilisateursSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_user?: boolean
    img?: boolean
    email?: boolean
    username?: boolean
    password?: boolean
    role?: boolean
  }, ExtArgs["result"]["utilisateurs"]>



  export type utilisateursSelectScalar = {
    id_user?: boolean
    img?: boolean
    email?: boolean
    username?: boolean
    password?: boolean
    role?: boolean
  }

  export type utilisateursOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id_user" | "img" | "email" | "username" | "password" | "role", ExtArgs["result"]["utilisateurs"]>

  export type $utilisateursPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "utilisateurs"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id_user: number
      img: string
      email: string | null
      username: string
      password: string
      role: string
    }, ExtArgs["result"]["utilisateurs"]>
    composites: {}
  }

  type utilisateursGetPayload<S extends boolean | null | undefined | utilisateursDefaultArgs> = $Result.GetResult<Prisma.$utilisateursPayload, S>

  type utilisateursCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<utilisateursFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UtilisateursCountAggregateInputType | true
    }

  export interface utilisateursDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['utilisateurs'], meta: { name: 'utilisateurs' } }
    /**
     * Find zero or one Utilisateurs that matches the filter.
     * @param {utilisateursFindUniqueArgs} args - Arguments to find a Utilisateurs
     * @example
     * // Get one Utilisateurs
     * const utilisateurs = await prisma.utilisateurs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends utilisateursFindUniqueArgs>(args: SelectSubset<T, utilisateursFindUniqueArgs<ExtArgs>>): Prisma__utilisateursClient<$Result.GetResult<Prisma.$utilisateursPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Utilisateurs that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {utilisateursFindUniqueOrThrowArgs} args - Arguments to find a Utilisateurs
     * @example
     * // Get one Utilisateurs
     * const utilisateurs = await prisma.utilisateurs.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends utilisateursFindUniqueOrThrowArgs>(args: SelectSubset<T, utilisateursFindUniqueOrThrowArgs<ExtArgs>>): Prisma__utilisateursClient<$Result.GetResult<Prisma.$utilisateursPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Utilisateurs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {utilisateursFindFirstArgs} args - Arguments to find a Utilisateurs
     * @example
     * // Get one Utilisateurs
     * const utilisateurs = await prisma.utilisateurs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends utilisateursFindFirstArgs>(args?: SelectSubset<T, utilisateursFindFirstArgs<ExtArgs>>): Prisma__utilisateursClient<$Result.GetResult<Prisma.$utilisateursPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Utilisateurs that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {utilisateursFindFirstOrThrowArgs} args - Arguments to find a Utilisateurs
     * @example
     * // Get one Utilisateurs
     * const utilisateurs = await prisma.utilisateurs.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends utilisateursFindFirstOrThrowArgs>(args?: SelectSubset<T, utilisateursFindFirstOrThrowArgs<ExtArgs>>): Prisma__utilisateursClient<$Result.GetResult<Prisma.$utilisateursPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Utilisateurs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {utilisateursFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Utilisateurs
     * const utilisateurs = await prisma.utilisateurs.findMany()
     * 
     * // Get first 10 Utilisateurs
     * const utilisateurs = await prisma.utilisateurs.findMany({ take: 10 })
     * 
     * // Only select the `id_user`
     * const utilisateursWithId_userOnly = await prisma.utilisateurs.findMany({ select: { id_user: true } })
     * 
     */
    findMany<T extends utilisateursFindManyArgs>(args?: SelectSubset<T, utilisateursFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$utilisateursPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Utilisateurs.
     * @param {utilisateursCreateArgs} args - Arguments to create a Utilisateurs.
     * @example
     * // Create one Utilisateurs
     * const Utilisateurs = await prisma.utilisateurs.create({
     *   data: {
     *     // ... data to create a Utilisateurs
     *   }
     * })
     * 
     */
    create<T extends utilisateursCreateArgs>(args: SelectSubset<T, utilisateursCreateArgs<ExtArgs>>): Prisma__utilisateursClient<$Result.GetResult<Prisma.$utilisateursPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Utilisateurs.
     * @param {utilisateursCreateManyArgs} args - Arguments to create many Utilisateurs.
     * @example
     * // Create many Utilisateurs
     * const utilisateurs = await prisma.utilisateurs.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends utilisateursCreateManyArgs>(args?: SelectSubset<T, utilisateursCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Utilisateurs.
     * @param {utilisateursDeleteArgs} args - Arguments to delete one Utilisateurs.
     * @example
     * // Delete one Utilisateurs
     * const Utilisateurs = await prisma.utilisateurs.delete({
     *   where: {
     *     // ... filter to delete one Utilisateurs
     *   }
     * })
     * 
     */
    delete<T extends utilisateursDeleteArgs>(args: SelectSubset<T, utilisateursDeleteArgs<ExtArgs>>): Prisma__utilisateursClient<$Result.GetResult<Prisma.$utilisateursPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Utilisateurs.
     * @param {utilisateursUpdateArgs} args - Arguments to update one Utilisateurs.
     * @example
     * // Update one Utilisateurs
     * const utilisateurs = await prisma.utilisateurs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends utilisateursUpdateArgs>(args: SelectSubset<T, utilisateursUpdateArgs<ExtArgs>>): Prisma__utilisateursClient<$Result.GetResult<Prisma.$utilisateursPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Utilisateurs.
     * @param {utilisateursDeleteManyArgs} args - Arguments to filter Utilisateurs to delete.
     * @example
     * // Delete a few Utilisateurs
     * const { count } = await prisma.utilisateurs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends utilisateursDeleteManyArgs>(args?: SelectSubset<T, utilisateursDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Utilisateurs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {utilisateursUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Utilisateurs
     * const utilisateurs = await prisma.utilisateurs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends utilisateursUpdateManyArgs>(args: SelectSubset<T, utilisateursUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Utilisateurs.
     * @param {utilisateursUpsertArgs} args - Arguments to update or create a Utilisateurs.
     * @example
     * // Update or create a Utilisateurs
     * const utilisateurs = await prisma.utilisateurs.upsert({
     *   create: {
     *     // ... data to create a Utilisateurs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Utilisateurs we want to update
     *   }
     * })
     */
    upsert<T extends utilisateursUpsertArgs>(args: SelectSubset<T, utilisateursUpsertArgs<ExtArgs>>): Prisma__utilisateursClient<$Result.GetResult<Prisma.$utilisateursPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Utilisateurs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {utilisateursCountArgs} args - Arguments to filter Utilisateurs to count.
     * @example
     * // Count the number of Utilisateurs
     * const count = await prisma.utilisateurs.count({
     *   where: {
     *     // ... the filter for the Utilisateurs we want to count
     *   }
     * })
    **/
    count<T extends utilisateursCountArgs>(
      args?: Subset<T, utilisateursCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UtilisateursCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Utilisateurs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UtilisateursAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UtilisateursAggregateArgs>(args: Subset<T, UtilisateursAggregateArgs>): Prisma.PrismaPromise<GetUtilisateursAggregateType<T>>

    /**
     * Group by Utilisateurs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {utilisateursGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends utilisateursGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: utilisateursGroupByArgs['orderBy'] }
        : { orderBy?: utilisateursGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, utilisateursGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUtilisateursGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the utilisateurs model
   */
  readonly fields: utilisateursFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for utilisateurs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__utilisateursClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the utilisateurs model
   */
  interface utilisateursFieldRefs {
    readonly id_user: FieldRef<"utilisateurs", 'Int'>
    readonly img: FieldRef<"utilisateurs", 'String'>
    readonly email: FieldRef<"utilisateurs", 'String'>
    readonly username: FieldRef<"utilisateurs", 'String'>
    readonly password: FieldRef<"utilisateurs", 'String'>
    readonly role: FieldRef<"utilisateurs", 'String'>
  }
    

  // Custom InputTypes
  /**
   * utilisateurs findUnique
   */
  export type utilisateursFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the utilisateurs
     */
    select?: utilisateursSelect<ExtArgs> | null
    /**
     * Omit specific fields from the utilisateurs
     */
    omit?: utilisateursOmit<ExtArgs> | null
    /**
     * Filter, which utilisateurs to fetch.
     */
    where: utilisateursWhereUniqueInput
  }

  /**
   * utilisateurs findUniqueOrThrow
   */
  export type utilisateursFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the utilisateurs
     */
    select?: utilisateursSelect<ExtArgs> | null
    /**
     * Omit specific fields from the utilisateurs
     */
    omit?: utilisateursOmit<ExtArgs> | null
    /**
     * Filter, which utilisateurs to fetch.
     */
    where: utilisateursWhereUniqueInput
  }

  /**
   * utilisateurs findFirst
   */
  export type utilisateursFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the utilisateurs
     */
    select?: utilisateursSelect<ExtArgs> | null
    /**
     * Omit specific fields from the utilisateurs
     */
    omit?: utilisateursOmit<ExtArgs> | null
    /**
     * Filter, which utilisateurs to fetch.
     */
    where?: utilisateursWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of utilisateurs to fetch.
     */
    orderBy?: utilisateursOrderByWithRelationInput | utilisateursOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for utilisateurs.
     */
    cursor?: utilisateursWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` utilisateurs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` utilisateurs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of utilisateurs.
     */
    distinct?: UtilisateursScalarFieldEnum | UtilisateursScalarFieldEnum[]
  }

  /**
   * utilisateurs findFirstOrThrow
   */
  export type utilisateursFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the utilisateurs
     */
    select?: utilisateursSelect<ExtArgs> | null
    /**
     * Omit specific fields from the utilisateurs
     */
    omit?: utilisateursOmit<ExtArgs> | null
    /**
     * Filter, which utilisateurs to fetch.
     */
    where?: utilisateursWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of utilisateurs to fetch.
     */
    orderBy?: utilisateursOrderByWithRelationInput | utilisateursOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for utilisateurs.
     */
    cursor?: utilisateursWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` utilisateurs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` utilisateurs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of utilisateurs.
     */
    distinct?: UtilisateursScalarFieldEnum | UtilisateursScalarFieldEnum[]
  }

  /**
   * utilisateurs findMany
   */
  export type utilisateursFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the utilisateurs
     */
    select?: utilisateursSelect<ExtArgs> | null
    /**
     * Omit specific fields from the utilisateurs
     */
    omit?: utilisateursOmit<ExtArgs> | null
    /**
     * Filter, which utilisateurs to fetch.
     */
    where?: utilisateursWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of utilisateurs to fetch.
     */
    orderBy?: utilisateursOrderByWithRelationInput | utilisateursOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing utilisateurs.
     */
    cursor?: utilisateursWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` utilisateurs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` utilisateurs.
     */
    skip?: number
    distinct?: UtilisateursScalarFieldEnum | UtilisateursScalarFieldEnum[]
  }

  /**
   * utilisateurs create
   */
  export type utilisateursCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the utilisateurs
     */
    select?: utilisateursSelect<ExtArgs> | null
    /**
     * Omit specific fields from the utilisateurs
     */
    omit?: utilisateursOmit<ExtArgs> | null
    /**
     * The data needed to create a utilisateurs.
     */
    data: XOR<utilisateursCreateInput, utilisateursUncheckedCreateInput>
  }

  /**
   * utilisateurs createMany
   */
  export type utilisateursCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many utilisateurs.
     */
    data: utilisateursCreateManyInput | utilisateursCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * utilisateurs update
   */
  export type utilisateursUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the utilisateurs
     */
    select?: utilisateursSelect<ExtArgs> | null
    /**
     * Omit specific fields from the utilisateurs
     */
    omit?: utilisateursOmit<ExtArgs> | null
    /**
     * The data needed to update a utilisateurs.
     */
    data: XOR<utilisateursUpdateInput, utilisateursUncheckedUpdateInput>
    /**
     * Choose, which utilisateurs to update.
     */
    where: utilisateursWhereUniqueInput
  }

  /**
   * utilisateurs updateMany
   */
  export type utilisateursUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update utilisateurs.
     */
    data: XOR<utilisateursUpdateManyMutationInput, utilisateursUncheckedUpdateManyInput>
    /**
     * Filter which utilisateurs to update
     */
    where?: utilisateursWhereInput
    /**
     * Limit how many utilisateurs to update.
     */
    limit?: number
  }

  /**
   * utilisateurs upsert
   */
  export type utilisateursUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the utilisateurs
     */
    select?: utilisateursSelect<ExtArgs> | null
    /**
     * Omit specific fields from the utilisateurs
     */
    omit?: utilisateursOmit<ExtArgs> | null
    /**
     * The filter to search for the utilisateurs to update in case it exists.
     */
    where: utilisateursWhereUniqueInput
    /**
     * In case the utilisateurs found by the `where` argument doesn't exist, create a new utilisateurs with this data.
     */
    create: XOR<utilisateursCreateInput, utilisateursUncheckedCreateInput>
    /**
     * In case the utilisateurs was found with the provided `where` argument, update it with this data.
     */
    update: XOR<utilisateursUpdateInput, utilisateursUncheckedUpdateInput>
  }

  /**
   * utilisateurs delete
   */
  export type utilisateursDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the utilisateurs
     */
    select?: utilisateursSelect<ExtArgs> | null
    /**
     * Omit specific fields from the utilisateurs
     */
    omit?: utilisateursOmit<ExtArgs> | null
    /**
     * Filter which utilisateurs to delete.
     */
    where: utilisateursWhereUniqueInput
  }

  /**
   * utilisateurs deleteMany
   */
  export type utilisateursDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which utilisateurs to delete
     */
    where?: utilisateursWhereInput
    /**
     * Limit how many utilisateurs to delete.
     */
    limit?: number
  }

  /**
   * utilisateurs without action
   */
  export type utilisateursDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the utilisateurs
     */
    select?: utilisateursSelect<ExtArgs> | null
    /**
     * Omit specific fields from the utilisateurs
     */
    omit?: utilisateursOmit<ExtArgs> | null
  }


  /**
   * Model verification
   */

  export type AggregateVerification = {
    _count: VerificationCountAggregateOutputType | null
    _min: VerificationMinAggregateOutputType | null
    _max: VerificationMaxAggregateOutputType | null
  }

  export type VerificationMinAggregateOutputType = {
    id: string | null
    identifier: string | null
    value: string | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VerificationMaxAggregateOutputType = {
    id: string | null
    identifier: string | null
    value: string | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VerificationCountAggregateOutputType = {
    id: number
    identifier: number
    value: number
    expiresAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VerificationMinAggregateInputType = {
    id?: true
    identifier?: true
    value?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VerificationMaxAggregateInputType = {
    id?: true
    identifier?: true
    value?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VerificationCountAggregateInputType = {
    id?: true
    identifier?: true
    value?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VerificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which verification to aggregate.
     */
    where?: verificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of verifications to fetch.
     */
    orderBy?: verificationOrderByWithRelationInput | verificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: verificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` verifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` verifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned verifications
    **/
    _count?: true | VerificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VerificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VerificationMaxAggregateInputType
  }

  export type GetVerificationAggregateType<T extends VerificationAggregateArgs> = {
        [P in keyof T & keyof AggregateVerification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVerification[P]>
      : GetScalarType<T[P], AggregateVerification[P]>
  }




  export type verificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: verificationWhereInput
    orderBy?: verificationOrderByWithAggregationInput | verificationOrderByWithAggregationInput[]
    by: VerificationScalarFieldEnum[] | VerificationScalarFieldEnum
    having?: verificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VerificationCountAggregateInputType | true
    _min?: VerificationMinAggregateInputType
    _max?: VerificationMaxAggregateInputType
  }

  export type VerificationGroupByOutputType = {
    id: string
    identifier: string
    value: string
    expiresAt: Date
    createdAt: Date | null
    updatedAt: Date | null
    _count: VerificationCountAggregateOutputType | null
    _min: VerificationMinAggregateOutputType | null
    _max: VerificationMaxAggregateOutputType | null
  }

  type GetVerificationGroupByPayload<T extends verificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VerificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VerificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VerificationGroupByOutputType[P]>
            : GetScalarType<T[P], VerificationGroupByOutputType[P]>
        }
      >
    >


  export type verificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    identifier?: boolean
    value?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["verification"]>



  export type verificationSelectScalar = {
    id?: boolean
    identifier?: boolean
    value?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type verificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "identifier" | "value" | "expiresAt" | "createdAt" | "updatedAt", ExtArgs["result"]["verification"]>

  export type $verificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "verification"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      identifier: string
      value: string
      expiresAt: Date
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["verification"]>
    composites: {}
  }

  type verificationGetPayload<S extends boolean | null | undefined | verificationDefaultArgs> = $Result.GetResult<Prisma.$verificationPayload, S>

  type verificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<verificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VerificationCountAggregateInputType | true
    }

  export interface verificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['verification'], meta: { name: 'verification' } }
    /**
     * Find zero or one Verification that matches the filter.
     * @param {verificationFindUniqueArgs} args - Arguments to find a Verification
     * @example
     * // Get one Verification
     * const verification = await prisma.verification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends verificationFindUniqueArgs>(args: SelectSubset<T, verificationFindUniqueArgs<ExtArgs>>): Prisma__verificationClient<$Result.GetResult<Prisma.$verificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Verification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {verificationFindUniqueOrThrowArgs} args - Arguments to find a Verification
     * @example
     * // Get one Verification
     * const verification = await prisma.verification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends verificationFindUniqueOrThrowArgs>(args: SelectSubset<T, verificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__verificationClient<$Result.GetResult<Prisma.$verificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Verification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {verificationFindFirstArgs} args - Arguments to find a Verification
     * @example
     * // Get one Verification
     * const verification = await prisma.verification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends verificationFindFirstArgs>(args?: SelectSubset<T, verificationFindFirstArgs<ExtArgs>>): Prisma__verificationClient<$Result.GetResult<Prisma.$verificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Verification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {verificationFindFirstOrThrowArgs} args - Arguments to find a Verification
     * @example
     * // Get one Verification
     * const verification = await prisma.verification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends verificationFindFirstOrThrowArgs>(args?: SelectSubset<T, verificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__verificationClient<$Result.GetResult<Prisma.$verificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Verifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {verificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Verifications
     * const verifications = await prisma.verification.findMany()
     * 
     * // Get first 10 Verifications
     * const verifications = await prisma.verification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const verificationWithIdOnly = await prisma.verification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends verificationFindManyArgs>(args?: SelectSubset<T, verificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$verificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Verification.
     * @param {verificationCreateArgs} args - Arguments to create a Verification.
     * @example
     * // Create one Verification
     * const Verification = await prisma.verification.create({
     *   data: {
     *     // ... data to create a Verification
     *   }
     * })
     * 
     */
    create<T extends verificationCreateArgs>(args: SelectSubset<T, verificationCreateArgs<ExtArgs>>): Prisma__verificationClient<$Result.GetResult<Prisma.$verificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Verifications.
     * @param {verificationCreateManyArgs} args - Arguments to create many Verifications.
     * @example
     * // Create many Verifications
     * const verification = await prisma.verification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends verificationCreateManyArgs>(args?: SelectSubset<T, verificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Verification.
     * @param {verificationDeleteArgs} args - Arguments to delete one Verification.
     * @example
     * // Delete one Verification
     * const Verification = await prisma.verification.delete({
     *   where: {
     *     // ... filter to delete one Verification
     *   }
     * })
     * 
     */
    delete<T extends verificationDeleteArgs>(args: SelectSubset<T, verificationDeleteArgs<ExtArgs>>): Prisma__verificationClient<$Result.GetResult<Prisma.$verificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Verification.
     * @param {verificationUpdateArgs} args - Arguments to update one Verification.
     * @example
     * // Update one Verification
     * const verification = await prisma.verification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends verificationUpdateArgs>(args: SelectSubset<T, verificationUpdateArgs<ExtArgs>>): Prisma__verificationClient<$Result.GetResult<Prisma.$verificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Verifications.
     * @param {verificationDeleteManyArgs} args - Arguments to filter Verifications to delete.
     * @example
     * // Delete a few Verifications
     * const { count } = await prisma.verification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends verificationDeleteManyArgs>(args?: SelectSubset<T, verificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Verifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {verificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Verifications
     * const verification = await prisma.verification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends verificationUpdateManyArgs>(args: SelectSubset<T, verificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Verification.
     * @param {verificationUpsertArgs} args - Arguments to update or create a Verification.
     * @example
     * // Update or create a Verification
     * const verification = await prisma.verification.upsert({
     *   create: {
     *     // ... data to create a Verification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Verification we want to update
     *   }
     * })
     */
    upsert<T extends verificationUpsertArgs>(args: SelectSubset<T, verificationUpsertArgs<ExtArgs>>): Prisma__verificationClient<$Result.GetResult<Prisma.$verificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Verifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {verificationCountArgs} args - Arguments to filter Verifications to count.
     * @example
     * // Count the number of Verifications
     * const count = await prisma.verification.count({
     *   where: {
     *     // ... the filter for the Verifications we want to count
     *   }
     * })
    **/
    count<T extends verificationCountArgs>(
      args?: Subset<T, verificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VerificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Verification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VerificationAggregateArgs>(args: Subset<T, VerificationAggregateArgs>): Prisma.PrismaPromise<GetVerificationAggregateType<T>>

    /**
     * Group by Verification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {verificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends verificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: verificationGroupByArgs['orderBy'] }
        : { orderBy?: verificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, verificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVerificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the verification model
   */
  readonly fields: verificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for verification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__verificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the verification model
   */
  interface verificationFieldRefs {
    readonly id: FieldRef<"verification", 'String'>
    readonly identifier: FieldRef<"verification", 'String'>
    readonly value: FieldRef<"verification", 'String'>
    readonly expiresAt: FieldRef<"verification", 'DateTime'>
    readonly createdAt: FieldRef<"verification", 'DateTime'>
    readonly updatedAt: FieldRef<"verification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * verification findUnique
   */
  export type verificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the verification
     */
    select?: verificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the verification
     */
    omit?: verificationOmit<ExtArgs> | null
    /**
     * Filter, which verification to fetch.
     */
    where: verificationWhereUniqueInput
  }

  /**
   * verification findUniqueOrThrow
   */
  export type verificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the verification
     */
    select?: verificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the verification
     */
    omit?: verificationOmit<ExtArgs> | null
    /**
     * Filter, which verification to fetch.
     */
    where: verificationWhereUniqueInput
  }

  /**
   * verification findFirst
   */
  export type verificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the verification
     */
    select?: verificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the verification
     */
    omit?: verificationOmit<ExtArgs> | null
    /**
     * Filter, which verification to fetch.
     */
    where?: verificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of verifications to fetch.
     */
    orderBy?: verificationOrderByWithRelationInput | verificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for verifications.
     */
    cursor?: verificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` verifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` verifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of verifications.
     */
    distinct?: VerificationScalarFieldEnum | VerificationScalarFieldEnum[]
  }

  /**
   * verification findFirstOrThrow
   */
  export type verificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the verification
     */
    select?: verificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the verification
     */
    omit?: verificationOmit<ExtArgs> | null
    /**
     * Filter, which verification to fetch.
     */
    where?: verificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of verifications to fetch.
     */
    orderBy?: verificationOrderByWithRelationInput | verificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for verifications.
     */
    cursor?: verificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` verifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` verifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of verifications.
     */
    distinct?: VerificationScalarFieldEnum | VerificationScalarFieldEnum[]
  }

  /**
   * verification findMany
   */
  export type verificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the verification
     */
    select?: verificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the verification
     */
    omit?: verificationOmit<ExtArgs> | null
    /**
     * Filter, which verifications to fetch.
     */
    where?: verificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of verifications to fetch.
     */
    orderBy?: verificationOrderByWithRelationInput | verificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing verifications.
     */
    cursor?: verificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` verifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` verifications.
     */
    skip?: number
    distinct?: VerificationScalarFieldEnum | VerificationScalarFieldEnum[]
  }

  /**
   * verification create
   */
  export type verificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the verification
     */
    select?: verificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the verification
     */
    omit?: verificationOmit<ExtArgs> | null
    /**
     * The data needed to create a verification.
     */
    data: XOR<verificationCreateInput, verificationUncheckedCreateInput>
  }

  /**
   * verification createMany
   */
  export type verificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many verifications.
     */
    data: verificationCreateManyInput | verificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * verification update
   */
  export type verificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the verification
     */
    select?: verificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the verification
     */
    omit?: verificationOmit<ExtArgs> | null
    /**
     * The data needed to update a verification.
     */
    data: XOR<verificationUpdateInput, verificationUncheckedUpdateInput>
    /**
     * Choose, which verification to update.
     */
    where: verificationWhereUniqueInput
  }

  /**
   * verification updateMany
   */
  export type verificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update verifications.
     */
    data: XOR<verificationUpdateManyMutationInput, verificationUncheckedUpdateManyInput>
    /**
     * Filter which verifications to update
     */
    where?: verificationWhereInput
    /**
     * Limit how many verifications to update.
     */
    limit?: number
  }

  /**
   * verification upsert
   */
  export type verificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the verification
     */
    select?: verificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the verification
     */
    omit?: verificationOmit<ExtArgs> | null
    /**
     * The filter to search for the verification to update in case it exists.
     */
    where: verificationWhereUniqueInput
    /**
     * In case the verification found by the `where` argument doesn't exist, create a new verification with this data.
     */
    create: XOR<verificationCreateInput, verificationUncheckedCreateInput>
    /**
     * In case the verification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<verificationUpdateInput, verificationUncheckedUpdateInput>
  }

  /**
   * verification delete
   */
  export type verificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the verification
     */
    select?: verificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the verification
     */
    omit?: verificationOmit<ExtArgs> | null
    /**
     * Filter which verification to delete.
     */
    where: verificationWhereUniqueInput
  }

  /**
   * verification deleteMany
   */
  export type verificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which verifications to delete
     */
    where?: verificationWhereInput
    /**
     * Limit how many verifications to delete.
     */
    limit?: number
  }

  /**
   * verification without action
   */
  export type verificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the verification
     */
    select?: verificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the verification
     */
    omit?: verificationOmit<ExtArgs> | null
  }


  /**
   * Model videos
   */

  export type AggregateVideos = {
    _count: VideosCountAggregateOutputType | null
    _avg: VideosAvgAggregateOutputType | null
    _sum: VideosSumAggregateOutputType | null
    _min: VideosMinAggregateOutputType | null
    _max: VideosMaxAggregateOutputType | null
  }

  export type VideosAvgAggregateOutputType = {
    id_vid: number | null
    tag_section_videos: number | null
  }

  export type VideosSumAggregateOutputType = {
    id_vid: number | null
    tag_section_videos: number | null
  }

  export type VideosMinAggregateOutputType = {
    id_vid: number | null
    titre: string | null
    lien: string | null
    date: Date | null
    afficher_carrousel_main: boolean | null
    afficher_section_videos: boolean | null
    tag_section_videos: number | null
    afficher: boolean | null
    derniere_modification: Date | null
  }

  export type VideosMaxAggregateOutputType = {
    id_vid: number | null
    titre: string | null
    lien: string | null
    date: Date | null
    afficher_carrousel_main: boolean | null
    afficher_section_videos: boolean | null
    tag_section_videos: number | null
    afficher: boolean | null
    derniere_modification: Date | null
  }

  export type VideosCountAggregateOutputType = {
    id_vid: number
    titre: number
    lien: number
    date: number
    afficher_carrousel_main: number
    afficher_section_videos: number
    tag_section_videos: number
    afficher: number
    derniere_modification: number
    _all: number
  }


  export type VideosAvgAggregateInputType = {
    id_vid?: true
    tag_section_videos?: true
  }

  export type VideosSumAggregateInputType = {
    id_vid?: true
    tag_section_videos?: true
  }

  export type VideosMinAggregateInputType = {
    id_vid?: true
    titre?: true
    lien?: true
    date?: true
    afficher_carrousel_main?: true
    afficher_section_videos?: true
    tag_section_videos?: true
    afficher?: true
    derniere_modification?: true
  }

  export type VideosMaxAggregateInputType = {
    id_vid?: true
    titre?: true
    lien?: true
    date?: true
    afficher_carrousel_main?: true
    afficher_section_videos?: true
    tag_section_videos?: true
    afficher?: true
    derniere_modification?: true
  }

  export type VideosCountAggregateInputType = {
    id_vid?: true
    titre?: true
    lien?: true
    date?: true
    afficher_carrousel_main?: true
    afficher_section_videos?: true
    tag_section_videos?: true
    afficher?: true
    derniere_modification?: true
    _all?: true
  }

  export type VideosAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which videos to aggregate.
     */
    where?: videosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of videos to fetch.
     */
    orderBy?: videosOrderByWithRelationInput | videosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: videosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` videos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` videos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned videos
    **/
    _count?: true | VideosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VideosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VideosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VideosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VideosMaxAggregateInputType
  }

  export type GetVideosAggregateType<T extends VideosAggregateArgs> = {
        [P in keyof T & keyof AggregateVideos]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVideos[P]>
      : GetScalarType<T[P], AggregateVideos[P]>
  }




  export type videosGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: videosWhereInput
    orderBy?: videosOrderByWithAggregationInput | videosOrderByWithAggregationInput[]
    by: VideosScalarFieldEnum[] | VideosScalarFieldEnum
    having?: videosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VideosCountAggregateInputType | true
    _avg?: VideosAvgAggregateInputType
    _sum?: VideosSumAggregateInputType
    _min?: VideosMinAggregateInputType
    _max?: VideosMaxAggregateInputType
  }

  export type VideosGroupByOutputType = {
    id_vid: number
    titre: string
    lien: string
    date: Date
    afficher_carrousel_main: boolean
    afficher_section_videos: boolean
    tag_section_videos: number | null
    afficher: boolean
    derniere_modification: Date
    _count: VideosCountAggregateOutputType | null
    _avg: VideosAvgAggregateOutputType | null
    _sum: VideosSumAggregateOutputType | null
    _min: VideosMinAggregateOutputType | null
    _max: VideosMaxAggregateOutputType | null
  }

  type GetVideosGroupByPayload<T extends videosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VideosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VideosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VideosGroupByOutputType[P]>
            : GetScalarType<T[P], VideosGroupByOutputType[P]>
        }
      >
    >


  export type videosSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_vid?: boolean
    titre?: boolean
    lien?: boolean
    date?: boolean
    afficher_carrousel_main?: boolean
    afficher_section_videos?: boolean
    tag_section_videos?: boolean
    afficher?: boolean
    derniere_modification?: boolean
    videos_tags_link?: boolean | videos$videos_tags_linkArgs<ExtArgs>
    _count?: boolean | VideosCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["videos"]>



  export type videosSelectScalar = {
    id_vid?: boolean
    titre?: boolean
    lien?: boolean
    date?: boolean
    afficher_carrousel_main?: boolean
    afficher_section_videos?: boolean
    tag_section_videos?: boolean
    afficher?: boolean
    derniere_modification?: boolean
  }

  export type videosOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id_vid" | "titre" | "lien" | "date" | "afficher_carrousel_main" | "afficher_section_videos" | "tag_section_videos" | "afficher" | "derniere_modification", ExtArgs["result"]["videos"]>
  export type videosInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    videos_tags_link?: boolean | videos$videos_tags_linkArgs<ExtArgs>
    _count?: boolean | VideosCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $videosPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "videos"
    objects: {
      videos_tags_link: Prisma.$videos_tags_linkPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id_vid: number
      titre: string
      lien: string
      date: Date
      afficher_carrousel_main: boolean
      afficher_section_videos: boolean
      tag_section_videos: number | null
      afficher: boolean
      derniere_modification: Date
    }, ExtArgs["result"]["videos"]>
    composites: {}
  }

  type videosGetPayload<S extends boolean | null | undefined | videosDefaultArgs> = $Result.GetResult<Prisma.$videosPayload, S>

  type videosCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<videosFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VideosCountAggregateInputType | true
    }

  export interface videosDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['videos'], meta: { name: 'videos' } }
    /**
     * Find zero or one Videos that matches the filter.
     * @param {videosFindUniqueArgs} args - Arguments to find a Videos
     * @example
     * // Get one Videos
     * const videos = await prisma.videos.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends videosFindUniqueArgs>(args: SelectSubset<T, videosFindUniqueArgs<ExtArgs>>): Prisma__videosClient<$Result.GetResult<Prisma.$videosPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Videos that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {videosFindUniqueOrThrowArgs} args - Arguments to find a Videos
     * @example
     * // Get one Videos
     * const videos = await prisma.videos.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends videosFindUniqueOrThrowArgs>(args: SelectSubset<T, videosFindUniqueOrThrowArgs<ExtArgs>>): Prisma__videosClient<$Result.GetResult<Prisma.$videosPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Videos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {videosFindFirstArgs} args - Arguments to find a Videos
     * @example
     * // Get one Videos
     * const videos = await prisma.videos.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends videosFindFirstArgs>(args?: SelectSubset<T, videosFindFirstArgs<ExtArgs>>): Prisma__videosClient<$Result.GetResult<Prisma.$videosPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Videos that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {videosFindFirstOrThrowArgs} args - Arguments to find a Videos
     * @example
     * // Get one Videos
     * const videos = await prisma.videos.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends videosFindFirstOrThrowArgs>(args?: SelectSubset<T, videosFindFirstOrThrowArgs<ExtArgs>>): Prisma__videosClient<$Result.GetResult<Prisma.$videosPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Videos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {videosFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Videos
     * const videos = await prisma.videos.findMany()
     * 
     * // Get first 10 Videos
     * const videos = await prisma.videos.findMany({ take: 10 })
     * 
     * // Only select the `id_vid`
     * const videosWithId_vidOnly = await prisma.videos.findMany({ select: { id_vid: true } })
     * 
     */
    findMany<T extends videosFindManyArgs>(args?: SelectSubset<T, videosFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$videosPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Videos.
     * @param {videosCreateArgs} args - Arguments to create a Videos.
     * @example
     * // Create one Videos
     * const Videos = await prisma.videos.create({
     *   data: {
     *     // ... data to create a Videos
     *   }
     * })
     * 
     */
    create<T extends videosCreateArgs>(args: SelectSubset<T, videosCreateArgs<ExtArgs>>): Prisma__videosClient<$Result.GetResult<Prisma.$videosPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Videos.
     * @param {videosCreateManyArgs} args - Arguments to create many Videos.
     * @example
     * // Create many Videos
     * const videos = await prisma.videos.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends videosCreateManyArgs>(args?: SelectSubset<T, videosCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Videos.
     * @param {videosDeleteArgs} args - Arguments to delete one Videos.
     * @example
     * // Delete one Videos
     * const Videos = await prisma.videos.delete({
     *   where: {
     *     // ... filter to delete one Videos
     *   }
     * })
     * 
     */
    delete<T extends videosDeleteArgs>(args: SelectSubset<T, videosDeleteArgs<ExtArgs>>): Prisma__videosClient<$Result.GetResult<Prisma.$videosPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Videos.
     * @param {videosUpdateArgs} args - Arguments to update one Videos.
     * @example
     * // Update one Videos
     * const videos = await prisma.videos.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends videosUpdateArgs>(args: SelectSubset<T, videosUpdateArgs<ExtArgs>>): Prisma__videosClient<$Result.GetResult<Prisma.$videosPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Videos.
     * @param {videosDeleteManyArgs} args - Arguments to filter Videos to delete.
     * @example
     * // Delete a few Videos
     * const { count } = await prisma.videos.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends videosDeleteManyArgs>(args?: SelectSubset<T, videosDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Videos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {videosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Videos
     * const videos = await prisma.videos.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends videosUpdateManyArgs>(args: SelectSubset<T, videosUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Videos.
     * @param {videosUpsertArgs} args - Arguments to update or create a Videos.
     * @example
     * // Update or create a Videos
     * const videos = await prisma.videos.upsert({
     *   create: {
     *     // ... data to create a Videos
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Videos we want to update
     *   }
     * })
     */
    upsert<T extends videosUpsertArgs>(args: SelectSubset<T, videosUpsertArgs<ExtArgs>>): Prisma__videosClient<$Result.GetResult<Prisma.$videosPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Videos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {videosCountArgs} args - Arguments to filter Videos to count.
     * @example
     * // Count the number of Videos
     * const count = await prisma.videos.count({
     *   where: {
     *     // ... the filter for the Videos we want to count
     *   }
     * })
    **/
    count<T extends videosCountArgs>(
      args?: Subset<T, videosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VideosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Videos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VideosAggregateArgs>(args: Subset<T, VideosAggregateArgs>): Prisma.PrismaPromise<GetVideosAggregateType<T>>

    /**
     * Group by Videos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {videosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends videosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: videosGroupByArgs['orderBy'] }
        : { orderBy?: videosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, videosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVideosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the videos model
   */
  readonly fields: videosFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for videos.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__videosClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    videos_tags_link<T extends videos$videos_tags_linkArgs<ExtArgs> = {}>(args?: Subset<T, videos$videos_tags_linkArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$videos_tags_linkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the videos model
   */
  interface videosFieldRefs {
    readonly id_vid: FieldRef<"videos", 'Int'>
    readonly titre: FieldRef<"videos", 'String'>
    readonly lien: FieldRef<"videos", 'String'>
    readonly date: FieldRef<"videos", 'DateTime'>
    readonly afficher_carrousel_main: FieldRef<"videos", 'Boolean'>
    readonly afficher_section_videos: FieldRef<"videos", 'Boolean'>
    readonly tag_section_videos: FieldRef<"videos", 'Int'>
    readonly afficher: FieldRef<"videos", 'Boolean'>
    readonly derniere_modification: FieldRef<"videos", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * videos findUnique
   */
  export type videosFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the videos
     */
    select?: videosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the videos
     */
    omit?: videosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: videosInclude<ExtArgs> | null
    /**
     * Filter, which videos to fetch.
     */
    where: videosWhereUniqueInput
  }

  /**
   * videos findUniqueOrThrow
   */
  export type videosFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the videos
     */
    select?: videosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the videos
     */
    omit?: videosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: videosInclude<ExtArgs> | null
    /**
     * Filter, which videos to fetch.
     */
    where: videosWhereUniqueInput
  }

  /**
   * videos findFirst
   */
  export type videosFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the videos
     */
    select?: videosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the videos
     */
    omit?: videosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: videosInclude<ExtArgs> | null
    /**
     * Filter, which videos to fetch.
     */
    where?: videosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of videos to fetch.
     */
    orderBy?: videosOrderByWithRelationInput | videosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for videos.
     */
    cursor?: videosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` videos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` videos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of videos.
     */
    distinct?: VideosScalarFieldEnum | VideosScalarFieldEnum[]
  }

  /**
   * videos findFirstOrThrow
   */
  export type videosFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the videos
     */
    select?: videosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the videos
     */
    omit?: videosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: videosInclude<ExtArgs> | null
    /**
     * Filter, which videos to fetch.
     */
    where?: videosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of videos to fetch.
     */
    orderBy?: videosOrderByWithRelationInput | videosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for videos.
     */
    cursor?: videosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` videos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` videos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of videos.
     */
    distinct?: VideosScalarFieldEnum | VideosScalarFieldEnum[]
  }

  /**
   * videos findMany
   */
  export type videosFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the videos
     */
    select?: videosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the videos
     */
    omit?: videosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: videosInclude<ExtArgs> | null
    /**
     * Filter, which videos to fetch.
     */
    where?: videosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of videos to fetch.
     */
    orderBy?: videosOrderByWithRelationInput | videosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing videos.
     */
    cursor?: videosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` videos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` videos.
     */
    skip?: number
    distinct?: VideosScalarFieldEnum | VideosScalarFieldEnum[]
  }

  /**
   * videos create
   */
  export type videosCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the videos
     */
    select?: videosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the videos
     */
    omit?: videosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: videosInclude<ExtArgs> | null
    /**
     * The data needed to create a videos.
     */
    data: XOR<videosCreateInput, videosUncheckedCreateInput>
  }

  /**
   * videos createMany
   */
  export type videosCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many videos.
     */
    data: videosCreateManyInput | videosCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * videos update
   */
  export type videosUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the videos
     */
    select?: videosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the videos
     */
    omit?: videosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: videosInclude<ExtArgs> | null
    /**
     * The data needed to update a videos.
     */
    data: XOR<videosUpdateInput, videosUncheckedUpdateInput>
    /**
     * Choose, which videos to update.
     */
    where: videosWhereUniqueInput
  }

  /**
   * videos updateMany
   */
  export type videosUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update videos.
     */
    data: XOR<videosUpdateManyMutationInput, videosUncheckedUpdateManyInput>
    /**
     * Filter which videos to update
     */
    where?: videosWhereInput
    /**
     * Limit how many videos to update.
     */
    limit?: number
  }

  /**
   * videos upsert
   */
  export type videosUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the videos
     */
    select?: videosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the videos
     */
    omit?: videosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: videosInclude<ExtArgs> | null
    /**
     * The filter to search for the videos to update in case it exists.
     */
    where: videosWhereUniqueInput
    /**
     * In case the videos found by the `where` argument doesn't exist, create a new videos with this data.
     */
    create: XOR<videosCreateInput, videosUncheckedCreateInput>
    /**
     * In case the videos was found with the provided `where` argument, update it with this data.
     */
    update: XOR<videosUpdateInput, videosUncheckedUpdateInput>
  }

  /**
   * videos delete
   */
  export type videosDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the videos
     */
    select?: videosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the videos
     */
    omit?: videosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: videosInclude<ExtArgs> | null
    /**
     * Filter which videos to delete.
     */
    where: videosWhereUniqueInput
  }

  /**
   * videos deleteMany
   */
  export type videosDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which videos to delete
     */
    where?: videosWhereInput
    /**
     * Limit how many videos to delete.
     */
    limit?: number
  }

  /**
   * videos.videos_tags_link
   */
  export type videos$videos_tags_linkArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the videos_tags_link
     */
    select?: videos_tags_linkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the videos_tags_link
     */
    omit?: videos_tags_linkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: videos_tags_linkInclude<ExtArgs> | null
    where?: videos_tags_linkWhereInput
    orderBy?: videos_tags_linkOrderByWithRelationInput | videos_tags_linkOrderByWithRelationInput[]
    cursor?: videos_tags_linkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Videos_tags_linkScalarFieldEnum | Videos_tags_linkScalarFieldEnum[]
  }

  /**
   * videos without action
   */
  export type videosDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the videos
     */
    select?: videosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the videos
     */
    omit?: videosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: videosInclude<ExtArgs> | null
  }


  /**
   * Model videos_tags
   */

  export type AggregateVideos_tags = {
    _count: Videos_tagsCountAggregateOutputType | null
    _avg: Videos_tagsAvgAggregateOutputType | null
    _sum: Videos_tagsSumAggregateOutputType | null
    _min: Videos_tagsMinAggregateOutputType | null
    _max: Videos_tagsMaxAggregateOutputType | null
  }

  export type Videos_tagsAvgAggregateOutputType = {
    id_tags: number | null
  }

  export type Videos_tagsSumAggregateOutputType = {
    id_tags: number | null
  }

  export type Videos_tagsMinAggregateOutputType = {
    id_tags: number | null
    titre: string | null
    important: boolean | null
  }

  export type Videos_tagsMaxAggregateOutputType = {
    id_tags: number | null
    titre: string | null
    important: boolean | null
  }

  export type Videos_tagsCountAggregateOutputType = {
    id_tags: number
    titre: number
    important: number
    _all: number
  }


  export type Videos_tagsAvgAggregateInputType = {
    id_tags?: true
  }

  export type Videos_tagsSumAggregateInputType = {
    id_tags?: true
  }

  export type Videos_tagsMinAggregateInputType = {
    id_tags?: true
    titre?: true
    important?: true
  }

  export type Videos_tagsMaxAggregateInputType = {
    id_tags?: true
    titre?: true
    important?: true
  }

  export type Videos_tagsCountAggregateInputType = {
    id_tags?: true
    titre?: true
    important?: true
    _all?: true
  }

  export type Videos_tagsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which videos_tags to aggregate.
     */
    where?: videos_tagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of videos_tags to fetch.
     */
    orderBy?: videos_tagsOrderByWithRelationInput | videos_tagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: videos_tagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` videos_tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` videos_tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned videos_tags
    **/
    _count?: true | Videos_tagsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Videos_tagsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Videos_tagsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Videos_tagsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Videos_tagsMaxAggregateInputType
  }

  export type GetVideos_tagsAggregateType<T extends Videos_tagsAggregateArgs> = {
        [P in keyof T & keyof AggregateVideos_tags]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVideos_tags[P]>
      : GetScalarType<T[P], AggregateVideos_tags[P]>
  }




  export type videos_tagsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: videos_tagsWhereInput
    orderBy?: videos_tagsOrderByWithAggregationInput | videos_tagsOrderByWithAggregationInput[]
    by: Videos_tagsScalarFieldEnum[] | Videos_tagsScalarFieldEnum
    having?: videos_tagsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Videos_tagsCountAggregateInputType | true
    _avg?: Videos_tagsAvgAggregateInputType
    _sum?: Videos_tagsSumAggregateInputType
    _min?: Videos_tagsMinAggregateInputType
    _max?: Videos_tagsMaxAggregateInputType
  }

  export type Videos_tagsGroupByOutputType = {
    id_tags: number
    titre: string
    important: boolean
    _count: Videos_tagsCountAggregateOutputType | null
    _avg: Videos_tagsAvgAggregateOutputType | null
    _sum: Videos_tagsSumAggregateOutputType | null
    _min: Videos_tagsMinAggregateOutputType | null
    _max: Videos_tagsMaxAggregateOutputType | null
  }

  type GetVideos_tagsGroupByPayload<T extends videos_tagsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Videos_tagsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Videos_tagsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Videos_tagsGroupByOutputType[P]>
            : GetScalarType<T[P], Videos_tagsGroupByOutputType[P]>
        }
      >
    >


  export type videos_tagsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_tags?: boolean
    titre?: boolean
    important?: boolean
    videos_tags_link?: boolean | videos_tags$videos_tags_linkArgs<ExtArgs>
    _count?: boolean | Videos_tagsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["videos_tags"]>



  export type videos_tagsSelectScalar = {
    id_tags?: boolean
    titre?: boolean
    important?: boolean
  }

  export type videos_tagsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id_tags" | "titre" | "important", ExtArgs["result"]["videos_tags"]>
  export type videos_tagsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    videos_tags_link?: boolean | videos_tags$videos_tags_linkArgs<ExtArgs>
    _count?: boolean | Videos_tagsCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $videos_tagsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "videos_tags"
    objects: {
      videos_tags_link: Prisma.$videos_tags_linkPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id_tags: number
      titre: string
      important: boolean
    }, ExtArgs["result"]["videos_tags"]>
    composites: {}
  }

  type videos_tagsGetPayload<S extends boolean | null | undefined | videos_tagsDefaultArgs> = $Result.GetResult<Prisma.$videos_tagsPayload, S>

  type videos_tagsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<videos_tagsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Videos_tagsCountAggregateInputType | true
    }

  export interface videos_tagsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['videos_tags'], meta: { name: 'videos_tags' } }
    /**
     * Find zero or one Videos_tags that matches the filter.
     * @param {videos_tagsFindUniqueArgs} args - Arguments to find a Videos_tags
     * @example
     * // Get one Videos_tags
     * const videos_tags = await prisma.videos_tags.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends videos_tagsFindUniqueArgs>(args: SelectSubset<T, videos_tagsFindUniqueArgs<ExtArgs>>): Prisma__videos_tagsClient<$Result.GetResult<Prisma.$videos_tagsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Videos_tags that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {videos_tagsFindUniqueOrThrowArgs} args - Arguments to find a Videos_tags
     * @example
     * // Get one Videos_tags
     * const videos_tags = await prisma.videos_tags.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends videos_tagsFindUniqueOrThrowArgs>(args: SelectSubset<T, videos_tagsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__videos_tagsClient<$Result.GetResult<Prisma.$videos_tagsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Videos_tags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {videos_tagsFindFirstArgs} args - Arguments to find a Videos_tags
     * @example
     * // Get one Videos_tags
     * const videos_tags = await prisma.videos_tags.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends videos_tagsFindFirstArgs>(args?: SelectSubset<T, videos_tagsFindFirstArgs<ExtArgs>>): Prisma__videos_tagsClient<$Result.GetResult<Prisma.$videos_tagsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Videos_tags that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {videos_tagsFindFirstOrThrowArgs} args - Arguments to find a Videos_tags
     * @example
     * // Get one Videos_tags
     * const videos_tags = await prisma.videos_tags.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends videos_tagsFindFirstOrThrowArgs>(args?: SelectSubset<T, videos_tagsFindFirstOrThrowArgs<ExtArgs>>): Prisma__videos_tagsClient<$Result.GetResult<Prisma.$videos_tagsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Videos_tags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {videos_tagsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Videos_tags
     * const videos_tags = await prisma.videos_tags.findMany()
     * 
     * // Get first 10 Videos_tags
     * const videos_tags = await prisma.videos_tags.findMany({ take: 10 })
     * 
     * // Only select the `id_tags`
     * const videos_tagsWithId_tagsOnly = await prisma.videos_tags.findMany({ select: { id_tags: true } })
     * 
     */
    findMany<T extends videos_tagsFindManyArgs>(args?: SelectSubset<T, videos_tagsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$videos_tagsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Videos_tags.
     * @param {videos_tagsCreateArgs} args - Arguments to create a Videos_tags.
     * @example
     * // Create one Videos_tags
     * const Videos_tags = await prisma.videos_tags.create({
     *   data: {
     *     // ... data to create a Videos_tags
     *   }
     * })
     * 
     */
    create<T extends videos_tagsCreateArgs>(args: SelectSubset<T, videos_tagsCreateArgs<ExtArgs>>): Prisma__videos_tagsClient<$Result.GetResult<Prisma.$videos_tagsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Videos_tags.
     * @param {videos_tagsCreateManyArgs} args - Arguments to create many Videos_tags.
     * @example
     * // Create many Videos_tags
     * const videos_tags = await prisma.videos_tags.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends videos_tagsCreateManyArgs>(args?: SelectSubset<T, videos_tagsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Videos_tags.
     * @param {videos_tagsDeleteArgs} args - Arguments to delete one Videos_tags.
     * @example
     * // Delete one Videos_tags
     * const Videos_tags = await prisma.videos_tags.delete({
     *   where: {
     *     // ... filter to delete one Videos_tags
     *   }
     * })
     * 
     */
    delete<T extends videos_tagsDeleteArgs>(args: SelectSubset<T, videos_tagsDeleteArgs<ExtArgs>>): Prisma__videos_tagsClient<$Result.GetResult<Prisma.$videos_tagsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Videos_tags.
     * @param {videos_tagsUpdateArgs} args - Arguments to update one Videos_tags.
     * @example
     * // Update one Videos_tags
     * const videos_tags = await prisma.videos_tags.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends videos_tagsUpdateArgs>(args: SelectSubset<T, videos_tagsUpdateArgs<ExtArgs>>): Prisma__videos_tagsClient<$Result.GetResult<Prisma.$videos_tagsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Videos_tags.
     * @param {videos_tagsDeleteManyArgs} args - Arguments to filter Videos_tags to delete.
     * @example
     * // Delete a few Videos_tags
     * const { count } = await prisma.videos_tags.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends videos_tagsDeleteManyArgs>(args?: SelectSubset<T, videos_tagsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Videos_tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {videos_tagsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Videos_tags
     * const videos_tags = await prisma.videos_tags.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends videos_tagsUpdateManyArgs>(args: SelectSubset<T, videos_tagsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Videos_tags.
     * @param {videos_tagsUpsertArgs} args - Arguments to update or create a Videos_tags.
     * @example
     * // Update or create a Videos_tags
     * const videos_tags = await prisma.videos_tags.upsert({
     *   create: {
     *     // ... data to create a Videos_tags
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Videos_tags we want to update
     *   }
     * })
     */
    upsert<T extends videos_tagsUpsertArgs>(args: SelectSubset<T, videos_tagsUpsertArgs<ExtArgs>>): Prisma__videos_tagsClient<$Result.GetResult<Prisma.$videos_tagsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Videos_tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {videos_tagsCountArgs} args - Arguments to filter Videos_tags to count.
     * @example
     * // Count the number of Videos_tags
     * const count = await prisma.videos_tags.count({
     *   where: {
     *     // ... the filter for the Videos_tags we want to count
     *   }
     * })
    **/
    count<T extends videos_tagsCountArgs>(
      args?: Subset<T, videos_tagsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Videos_tagsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Videos_tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Videos_tagsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Videos_tagsAggregateArgs>(args: Subset<T, Videos_tagsAggregateArgs>): Prisma.PrismaPromise<GetVideos_tagsAggregateType<T>>

    /**
     * Group by Videos_tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {videos_tagsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends videos_tagsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: videos_tagsGroupByArgs['orderBy'] }
        : { orderBy?: videos_tagsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, videos_tagsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVideos_tagsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the videos_tags model
   */
  readonly fields: videos_tagsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for videos_tags.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__videos_tagsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    videos_tags_link<T extends videos_tags$videos_tags_linkArgs<ExtArgs> = {}>(args?: Subset<T, videos_tags$videos_tags_linkArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$videos_tags_linkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the videos_tags model
   */
  interface videos_tagsFieldRefs {
    readonly id_tags: FieldRef<"videos_tags", 'Int'>
    readonly titre: FieldRef<"videos_tags", 'String'>
    readonly important: FieldRef<"videos_tags", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * videos_tags findUnique
   */
  export type videos_tagsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the videos_tags
     */
    select?: videos_tagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the videos_tags
     */
    omit?: videos_tagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: videos_tagsInclude<ExtArgs> | null
    /**
     * Filter, which videos_tags to fetch.
     */
    where: videos_tagsWhereUniqueInput
  }

  /**
   * videos_tags findUniqueOrThrow
   */
  export type videos_tagsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the videos_tags
     */
    select?: videos_tagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the videos_tags
     */
    omit?: videos_tagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: videos_tagsInclude<ExtArgs> | null
    /**
     * Filter, which videos_tags to fetch.
     */
    where: videos_tagsWhereUniqueInput
  }

  /**
   * videos_tags findFirst
   */
  export type videos_tagsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the videos_tags
     */
    select?: videos_tagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the videos_tags
     */
    omit?: videos_tagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: videos_tagsInclude<ExtArgs> | null
    /**
     * Filter, which videos_tags to fetch.
     */
    where?: videos_tagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of videos_tags to fetch.
     */
    orderBy?: videos_tagsOrderByWithRelationInput | videos_tagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for videos_tags.
     */
    cursor?: videos_tagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` videos_tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` videos_tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of videos_tags.
     */
    distinct?: Videos_tagsScalarFieldEnum | Videos_tagsScalarFieldEnum[]
  }

  /**
   * videos_tags findFirstOrThrow
   */
  export type videos_tagsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the videos_tags
     */
    select?: videos_tagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the videos_tags
     */
    omit?: videos_tagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: videos_tagsInclude<ExtArgs> | null
    /**
     * Filter, which videos_tags to fetch.
     */
    where?: videos_tagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of videos_tags to fetch.
     */
    orderBy?: videos_tagsOrderByWithRelationInput | videos_tagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for videos_tags.
     */
    cursor?: videos_tagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` videos_tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` videos_tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of videos_tags.
     */
    distinct?: Videos_tagsScalarFieldEnum | Videos_tagsScalarFieldEnum[]
  }

  /**
   * videos_tags findMany
   */
  export type videos_tagsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the videos_tags
     */
    select?: videos_tagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the videos_tags
     */
    omit?: videos_tagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: videos_tagsInclude<ExtArgs> | null
    /**
     * Filter, which videos_tags to fetch.
     */
    where?: videos_tagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of videos_tags to fetch.
     */
    orderBy?: videos_tagsOrderByWithRelationInput | videos_tagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing videos_tags.
     */
    cursor?: videos_tagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` videos_tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` videos_tags.
     */
    skip?: number
    distinct?: Videos_tagsScalarFieldEnum | Videos_tagsScalarFieldEnum[]
  }

  /**
   * videos_tags create
   */
  export type videos_tagsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the videos_tags
     */
    select?: videos_tagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the videos_tags
     */
    omit?: videos_tagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: videos_tagsInclude<ExtArgs> | null
    /**
     * The data needed to create a videos_tags.
     */
    data: XOR<videos_tagsCreateInput, videos_tagsUncheckedCreateInput>
  }

  /**
   * videos_tags createMany
   */
  export type videos_tagsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many videos_tags.
     */
    data: videos_tagsCreateManyInput | videos_tagsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * videos_tags update
   */
  export type videos_tagsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the videos_tags
     */
    select?: videos_tagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the videos_tags
     */
    omit?: videos_tagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: videos_tagsInclude<ExtArgs> | null
    /**
     * The data needed to update a videos_tags.
     */
    data: XOR<videos_tagsUpdateInput, videos_tagsUncheckedUpdateInput>
    /**
     * Choose, which videos_tags to update.
     */
    where: videos_tagsWhereUniqueInput
  }

  /**
   * videos_tags updateMany
   */
  export type videos_tagsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update videos_tags.
     */
    data: XOR<videos_tagsUpdateManyMutationInput, videos_tagsUncheckedUpdateManyInput>
    /**
     * Filter which videos_tags to update
     */
    where?: videos_tagsWhereInput
    /**
     * Limit how many videos_tags to update.
     */
    limit?: number
  }

  /**
   * videos_tags upsert
   */
  export type videos_tagsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the videos_tags
     */
    select?: videos_tagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the videos_tags
     */
    omit?: videos_tagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: videos_tagsInclude<ExtArgs> | null
    /**
     * The filter to search for the videos_tags to update in case it exists.
     */
    where: videos_tagsWhereUniqueInput
    /**
     * In case the videos_tags found by the `where` argument doesn't exist, create a new videos_tags with this data.
     */
    create: XOR<videos_tagsCreateInput, videos_tagsUncheckedCreateInput>
    /**
     * In case the videos_tags was found with the provided `where` argument, update it with this data.
     */
    update: XOR<videos_tagsUpdateInput, videos_tagsUncheckedUpdateInput>
  }

  /**
   * videos_tags delete
   */
  export type videos_tagsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the videos_tags
     */
    select?: videos_tagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the videos_tags
     */
    omit?: videos_tagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: videos_tagsInclude<ExtArgs> | null
    /**
     * Filter which videos_tags to delete.
     */
    where: videos_tagsWhereUniqueInput
  }

  /**
   * videos_tags deleteMany
   */
  export type videos_tagsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which videos_tags to delete
     */
    where?: videos_tagsWhereInput
    /**
     * Limit how many videos_tags to delete.
     */
    limit?: number
  }

  /**
   * videos_tags.videos_tags_link
   */
  export type videos_tags$videos_tags_linkArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the videos_tags_link
     */
    select?: videos_tags_linkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the videos_tags_link
     */
    omit?: videos_tags_linkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: videos_tags_linkInclude<ExtArgs> | null
    where?: videos_tags_linkWhereInput
    orderBy?: videos_tags_linkOrderByWithRelationInput | videos_tags_linkOrderByWithRelationInput[]
    cursor?: videos_tags_linkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Videos_tags_linkScalarFieldEnum | Videos_tags_linkScalarFieldEnum[]
  }

  /**
   * videos_tags without action
   */
  export type videos_tagsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the videos_tags
     */
    select?: videos_tagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the videos_tags
     */
    omit?: videos_tagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: videos_tagsInclude<ExtArgs> | null
  }


  /**
   * Model videos_tags_link
   */

  export type AggregateVideos_tags_link = {
    _count: Videos_tags_linkCountAggregateOutputType | null
    _avg: Videos_tags_linkAvgAggregateOutputType | null
    _sum: Videos_tags_linkSumAggregateOutputType | null
    _min: Videos_tags_linkMinAggregateOutputType | null
    _max: Videos_tags_linkMaxAggregateOutputType | null
  }

  export type Videos_tags_linkAvgAggregateOutputType = {
    id_vid: number | null
    id_tags: number | null
  }

  export type Videos_tags_linkSumAggregateOutputType = {
    id_vid: number | null
    id_tags: number | null
  }

  export type Videos_tags_linkMinAggregateOutputType = {
    id_vid: number | null
    id_tags: number | null
  }

  export type Videos_tags_linkMaxAggregateOutputType = {
    id_vid: number | null
    id_tags: number | null
  }

  export type Videos_tags_linkCountAggregateOutputType = {
    id_vid: number
    id_tags: number
    _all: number
  }


  export type Videos_tags_linkAvgAggregateInputType = {
    id_vid?: true
    id_tags?: true
  }

  export type Videos_tags_linkSumAggregateInputType = {
    id_vid?: true
    id_tags?: true
  }

  export type Videos_tags_linkMinAggregateInputType = {
    id_vid?: true
    id_tags?: true
  }

  export type Videos_tags_linkMaxAggregateInputType = {
    id_vid?: true
    id_tags?: true
  }

  export type Videos_tags_linkCountAggregateInputType = {
    id_vid?: true
    id_tags?: true
    _all?: true
  }

  export type Videos_tags_linkAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which videos_tags_link to aggregate.
     */
    where?: videos_tags_linkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of videos_tags_links to fetch.
     */
    orderBy?: videos_tags_linkOrderByWithRelationInput | videos_tags_linkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: videos_tags_linkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` videos_tags_links from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` videos_tags_links.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned videos_tags_links
    **/
    _count?: true | Videos_tags_linkCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Videos_tags_linkAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Videos_tags_linkSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Videos_tags_linkMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Videos_tags_linkMaxAggregateInputType
  }

  export type GetVideos_tags_linkAggregateType<T extends Videos_tags_linkAggregateArgs> = {
        [P in keyof T & keyof AggregateVideos_tags_link]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVideos_tags_link[P]>
      : GetScalarType<T[P], AggregateVideos_tags_link[P]>
  }




  export type videos_tags_linkGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: videos_tags_linkWhereInput
    orderBy?: videos_tags_linkOrderByWithAggregationInput | videos_tags_linkOrderByWithAggregationInput[]
    by: Videos_tags_linkScalarFieldEnum[] | Videos_tags_linkScalarFieldEnum
    having?: videos_tags_linkScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Videos_tags_linkCountAggregateInputType | true
    _avg?: Videos_tags_linkAvgAggregateInputType
    _sum?: Videos_tags_linkSumAggregateInputType
    _min?: Videos_tags_linkMinAggregateInputType
    _max?: Videos_tags_linkMaxAggregateInputType
  }

  export type Videos_tags_linkGroupByOutputType = {
    id_vid: number
    id_tags: number
    _count: Videos_tags_linkCountAggregateOutputType | null
    _avg: Videos_tags_linkAvgAggregateOutputType | null
    _sum: Videos_tags_linkSumAggregateOutputType | null
    _min: Videos_tags_linkMinAggregateOutputType | null
    _max: Videos_tags_linkMaxAggregateOutputType | null
  }

  type GetVideos_tags_linkGroupByPayload<T extends videos_tags_linkGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Videos_tags_linkGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Videos_tags_linkGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Videos_tags_linkGroupByOutputType[P]>
            : GetScalarType<T[P], Videos_tags_linkGroupByOutputType[P]>
        }
      >
    >


  export type videos_tags_linkSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_vid?: boolean
    id_tags?: boolean
    videos?: boolean | videosDefaultArgs<ExtArgs>
    videos_tags?: boolean | videos_tagsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["videos_tags_link"]>



  export type videos_tags_linkSelectScalar = {
    id_vid?: boolean
    id_tags?: boolean
  }

  export type videos_tags_linkOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id_vid" | "id_tags", ExtArgs["result"]["videos_tags_link"]>
  export type videos_tags_linkInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    videos?: boolean | videosDefaultArgs<ExtArgs>
    videos_tags?: boolean | videos_tagsDefaultArgs<ExtArgs>
  }

  export type $videos_tags_linkPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "videos_tags_link"
    objects: {
      videos: Prisma.$videosPayload<ExtArgs>
      videos_tags: Prisma.$videos_tagsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id_vid: number
      id_tags: number
    }, ExtArgs["result"]["videos_tags_link"]>
    composites: {}
  }

  type videos_tags_linkGetPayload<S extends boolean | null | undefined | videos_tags_linkDefaultArgs> = $Result.GetResult<Prisma.$videos_tags_linkPayload, S>

  type videos_tags_linkCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<videos_tags_linkFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Videos_tags_linkCountAggregateInputType | true
    }

  export interface videos_tags_linkDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['videos_tags_link'], meta: { name: 'videos_tags_link' } }
    /**
     * Find zero or one Videos_tags_link that matches the filter.
     * @param {videos_tags_linkFindUniqueArgs} args - Arguments to find a Videos_tags_link
     * @example
     * // Get one Videos_tags_link
     * const videos_tags_link = await prisma.videos_tags_link.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends videos_tags_linkFindUniqueArgs>(args: SelectSubset<T, videos_tags_linkFindUniqueArgs<ExtArgs>>): Prisma__videos_tags_linkClient<$Result.GetResult<Prisma.$videos_tags_linkPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Videos_tags_link that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {videos_tags_linkFindUniqueOrThrowArgs} args - Arguments to find a Videos_tags_link
     * @example
     * // Get one Videos_tags_link
     * const videos_tags_link = await prisma.videos_tags_link.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends videos_tags_linkFindUniqueOrThrowArgs>(args: SelectSubset<T, videos_tags_linkFindUniqueOrThrowArgs<ExtArgs>>): Prisma__videos_tags_linkClient<$Result.GetResult<Prisma.$videos_tags_linkPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Videos_tags_link that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {videos_tags_linkFindFirstArgs} args - Arguments to find a Videos_tags_link
     * @example
     * // Get one Videos_tags_link
     * const videos_tags_link = await prisma.videos_tags_link.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends videos_tags_linkFindFirstArgs>(args?: SelectSubset<T, videos_tags_linkFindFirstArgs<ExtArgs>>): Prisma__videos_tags_linkClient<$Result.GetResult<Prisma.$videos_tags_linkPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Videos_tags_link that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {videos_tags_linkFindFirstOrThrowArgs} args - Arguments to find a Videos_tags_link
     * @example
     * // Get one Videos_tags_link
     * const videos_tags_link = await prisma.videos_tags_link.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends videos_tags_linkFindFirstOrThrowArgs>(args?: SelectSubset<T, videos_tags_linkFindFirstOrThrowArgs<ExtArgs>>): Prisma__videos_tags_linkClient<$Result.GetResult<Prisma.$videos_tags_linkPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Videos_tags_links that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {videos_tags_linkFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Videos_tags_links
     * const videos_tags_links = await prisma.videos_tags_link.findMany()
     * 
     * // Get first 10 Videos_tags_links
     * const videos_tags_links = await prisma.videos_tags_link.findMany({ take: 10 })
     * 
     * // Only select the `id_vid`
     * const videos_tags_linkWithId_vidOnly = await prisma.videos_tags_link.findMany({ select: { id_vid: true } })
     * 
     */
    findMany<T extends videos_tags_linkFindManyArgs>(args?: SelectSubset<T, videos_tags_linkFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$videos_tags_linkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Videos_tags_link.
     * @param {videos_tags_linkCreateArgs} args - Arguments to create a Videos_tags_link.
     * @example
     * // Create one Videos_tags_link
     * const Videos_tags_link = await prisma.videos_tags_link.create({
     *   data: {
     *     // ... data to create a Videos_tags_link
     *   }
     * })
     * 
     */
    create<T extends videos_tags_linkCreateArgs>(args: SelectSubset<T, videos_tags_linkCreateArgs<ExtArgs>>): Prisma__videos_tags_linkClient<$Result.GetResult<Prisma.$videos_tags_linkPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Videos_tags_links.
     * @param {videos_tags_linkCreateManyArgs} args - Arguments to create many Videos_tags_links.
     * @example
     * // Create many Videos_tags_links
     * const videos_tags_link = await prisma.videos_tags_link.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends videos_tags_linkCreateManyArgs>(args?: SelectSubset<T, videos_tags_linkCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Videos_tags_link.
     * @param {videos_tags_linkDeleteArgs} args - Arguments to delete one Videos_tags_link.
     * @example
     * // Delete one Videos_tags_link
     * const Videos_tags_link = await prisma.videos_tags_link.delete({
     *   where: {
     *     // ... filter to delete one Videos_tags_link
     *   }
     * })
     * 
     */
    delete<T extends videos_tags_linkDeleteArgs>(args: SelectSubset<T, videos_tags_linkDeleteArgs<ExtArgs>>): Prisma__videos_tags_linkClient<$Result.GetResult<Prisma.$videos_tags_linkPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Videos_tags_link.
     * @param {videos_tags_linkUpdateArgs} args - Arguments to update one Videos_tags_link.
     * @example
     * // Update one Videos_tags_link
     * const videos_tags_link = await prisma.videos_tags_link.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends videos_tags_linkUpdateArgs>(args: SelectSubset<T, videos_tags_linkUpdateArgs<ExtArgs>>): Prisma__videos_tags_linkClient<$Result.GetResult<Prisma.$videos_tags_linkPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Videos_tags_links.
     * @param {videos_tags_linkDeleteManyArgs} args - Arguments to filter Videos_tags_links to delete.
     * @example
     * // Delete a few Videos_tags_links
     * const { count } = await prisma.videos_tags_link.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends videos_tags_linkDeleteManyArgs>(args?: SelectSubset<T, videos_tags_linkDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Videos_tags_links.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {videos_tags_linkUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Videos_tags_links
     * const videos_tags_link = await prisma.videos_tags_link.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends videos_tags_linkUpdateManyArgs>(args: SelectSubset<T, videos_tags_linkUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Videos_tags_link.
     * @param {videos_tags_linkUpsertArgs} args - Arguments to update or create a Videos_tags_link.
     * @example
     * // Update or create a Videos_tags_link
     * const videos_tags_link = await prisma.videos_tags_link.upsert({
     *   create: {
     *     // ... data to create a Videos_tags_link
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Videos_tags_link we want to update
     *   }
     * })
     */
    upsert<T extends videos_tags_linkUpsertArgs>(args: SelectSubset<T, videos_tags_linkUpsertArgs<ExtArgs>>): Prisma__videos_tags_linkClient<$Result.GetResult<Prisma.$videos_tags_linkPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Videos_tags_links.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {videos_tags_linkCountArgs} args - Arguments to filter Videos_tags_links to count.
     * @example
     * // Count the number of Videos_tags_links
     * const count = await prisma.videos_tags_link.count({
     *   where: {
     *     // ... the filter for the Videos_tags_links we want to count
     *   }
     * })
    **/
    count<T extends videos_tags_linkCountArgs>(
      args?: Subset<T, videos_tags_linkCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Videos_tags_linkCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Videos_tags_link.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Videos_tags_linkAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Videos_tags_linkAggregateArgs>(args: Subset<T, Videos_tags_linkAggregateArgs>): Prisma.PrismaPromise<GetVideos_tags_linkAggregateType<T>>

    /**
     * Group by Videos_tags_link.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {videos_tags_linkGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends videos_tags_linkGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: videos_tags_linkGroupByArgs['orderBy'] }
        : { orderBy?: videos_tags_linkGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, videos_tags_linkGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVideos_tags_linkGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the videos_tags_link model
   */
  readonly fields: videos_tags_linkFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for videos_tags_link.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__videos_tags_linkClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    videos<T extends videosDefaultArgs<ExtArgs> = {}>(args?: Subset<T, videosDefaultArgs<ExtArgs>>): Prisma__videosClient<$Result.GetResult<Prisma.$videosPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    videos_tags<T extends videos_tagsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, videos_tagsDefaultArgs<ExtArgs>>): Prisma__videos_tagsClient<$Result.GetResult<Prisma.$videos_tagsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the videos_tags_link model
   */
  interface videos_tags_linkFieldRefs {
    readonly id_vid: FieldRef<"videos_tags_link", 'Int'>
    readonly id_tags: FieldRef<"videos_tags_link", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * videos_tags_link findUnique
   */
  export type videos_tags_linkFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the videos_tags_link
     */
    select?: videos_tags_linkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the videos_tags_link
     */
    omit?: videos_tags_linkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: videos_tags_linkInclude<ExtArgs> | null
    /**
     * Filter, which videos_tags_link to fetch.
     */
    where: videos_tags_linkWhereUniqueInput
  }

  /**
   * videos_tags_link findUniqueOrThrow
   */
  export type videos_tags_linkFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the videos_tags_link
     */
    select?: videos_tags_linkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the videos_tags_link
     */
    omit?: videos_tags_linkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: videos_tags_linkInclude<ExtArgs> | null
    /**
     * Filter, which videos_tags_link to fetch.
     */
    where: videos_tags_linkWhereUniqueInput
  }

  /**
   * videos_tags_link findFirst
   */
  export type videos_tags_linkFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the videos_tags_link
     */
    select?: videos_tags_linkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the videos_tags_link
     */
    omit?: videos_tags_linkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: videos_tags_linkInclude<ExtArgs> | null
    /**
     * Filter, which videos_tags_link to fetch.
     */
    where?: videos_tags_linkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of videos_tags_links to fetch.
     */
    orderBy?: videos_tags_linkOrderByWithRelationInput | videos_tags_linkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for videos_tags_links.
     */
    cursor?: videos_tags_linkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` videos_tags_links from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` videos_tags_links.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of videos_tags_links.
     */
    distinct?: Videos_tags_linkScalarFieldEnum | Videos_tags_linkScalarFieldEnum[]
  }

  /**
   * videos_tags_link findFirstOrThrow
   */
  export type videos_tags_linkFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the videos_tags_link
     */
    select?: videos_tags_linkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the videos_tags_link
     */
    omit?: videos_tags_linkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: videos_tags_linkInclude<ExtArgs> | null
    /**
     * Filter, which videos_tags_link to fetch.
     */
    where?: videos_tags_linkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of videos_tags_links to fetch.
     */
    orderBy?: videos_tags_linkOrderByWithRelationInput | videos_tags_linkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for videos_tags_links.
     */
    cursor?: videos_tags_linkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` videos_tags_links from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` videos_tags_links.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of videos_tags_links.
     */
    distinct?: Videos_tags_linkScalarFieldEnum | Videos_tags_linkScalarFieldEnum[]
  }

  /**
   * videos_tags_link findMany
   */
  export type videos_tags_linkFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the videos_tags_link
     */
    select?: videos_tags_linkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the videos_tags_link
     */
    omit?: videos_tags_linkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: videos_tags_linkInclude<ExtArgs> | null
    /**
     * Filter, which videos_tags_links to fetch.
     */
    where?: videos_tags_linkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of videos_tags_links to fetch.
     */
    orderBy?: videos_tags_linkOrderByWithRelationInput | videos_tags_linkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing videos_tags_links.
     */
    cursor?: videos_tags_linkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` videos_tags_links from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` videos_tags_links.
     */
    skip?: number
    distinct?: Videos_tags_linkScalarFieldEnum | Videos_tags_linkScalarFieldEnum[]
  }

  /**
   * videos_tags_link create
   */
  export type videos_tags_linkCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the videos_tags_link
     */
    select?: videos_tags_linkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the videos_tags_link
     */
    omit?: videos_tags_linkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: videos_tags_linkInclude<ExtArgs> | null
    /**
     * The data needed to create a videos_tags_link.
     */
    data: XOR<videos_tags_linkCreateInput, videos_tags_linkUncheckedCreateInput>
  }

  /**
   * videos_tags_link createMany
   */
  export type videos_tags_linkCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many videos_tags_links.
     */
    data: videos_tags_linkCreateManyInput | videos_tags_linkCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * videos_tags_link update
   */
  export type videos_tags_linkUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the videos_tags_link
     */
    select?: videos_tags_linkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the videos_tags_link
     */
    omit?: videos_tags_linkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: videos_tags_linkInclude<ExtArgs> | null
    /**
     * The data needed to update a videos_tags_link.
     */
    data: XOR<videos_tags_linkUpdateInput, videos_tags_linkUncheckedUpdateInput>
    /**
     * Choose, which videos_tags_link to update.
     */
    where: videos_tags_linkWhereUniqueInput
  }

  /**
   * videos_tags_link updateMany
   */
  export type videos_tags_linkUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update videos_tags_links.
     */
    data: XOR<videos_tags_linkUpdateManyMutationInput, videos_tags_linkUncheckedUpdateManyInput>
    /**
     * Filter which videos_tags_links to update
     */
    where?: videos_tags_linkWhereInput
    /**
     * Limit how many videos_tags_links to update.
     */
    limit?: number
  }

  /**
   * videos_tags_link upsert
   */
  export type videos_tags_linkUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the videos_tags_link
     */
    select?: videos_tags_linkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the videos_tags_link
     */
    omit?: videos_tags_linkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: videos_tags_linkInclude<ExtArgs> | null
    /**
     * The filter to search for the videos_tags_link to update in case it exists.
     */
    where: videos_tags_linkWhereUniqueInput
    /**
     * In case the videos_tags_link found by the `where` argument doesn't exist, create a new videos_tags_link with this data.
     */
    create: XOR<videos_tags_linkCreateInput, videos_tags_linkUncheckedCreateInput>
    /**
     * In case the videos_tags_link was found with the provided `where` argument, update it with this data.
     */
    update: XOR<videos_tags_linkUpdateInput, videos_tags_linkUncheckedUpdateInput>
  }

  /**
   * videos_tags_link delete
   */
  export type videos_tags_linkDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the videos_tags_link
     */
    select?: videos_tags_linkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the videos_tags_link
     */
    omit?: videos_tags_linkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: videos_tags_linkInclude<ExtArgs> | null
    /**
     * Filter which videos_tags_link to delete.
     */
    where: videos_tags_linkWhereUniqueInput
  }

  /**
   * videos_tags_link deleteMany
   */
  export type videos_tags_linkDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which videos_tags_links to delete
     */
    where?: videos_tags_linkWhereInput
    /**
     * Limit how many videos_tags_links to delete.
     */
    limit?: number
  }

  /**
   * videos_tags_link without action
   */
  export type videos_tags_linkDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the videos_tags_link
     */
    select?: videos_tags_linkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the videos_tags_link
     */
    omit?: videos_tags_linkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: videos_tags_linkInclude<ExtArgs> | null
  }


  /**
   * Model accueil_clients
   */

  export type AggregateAccueil_clients = {
    _count: Accueil_clientsCountAggregateOutputType | null
    _avg: Accueil_clientsAvgAggregateOutputType | null
    _sum: Accueil_clientsSumAggregateOutputType | null
    _min: Accueil_clientsMinAggregateOutputType | null
    _max: Accueil_clientsMaxAggregateOutputType | null
  }

  export type Accueil_clientsAvgAggregateOutputType = {
    id_client: number | null
    ordre: number | null
  }

  export type Accueil_clientsSumAggregateOutputType = {
    id_client: number | null
    ordre: number | null
  }

  export type Accueil_clientsMinAggregateOutputType = {
    id_client: number | null
    client: string | null
    logo: string | null
    alt_logo: string | null
    lien_client: string | null
    ordre: number | null
    afficher: boolean | null
  }

  export type Accueil_clientsMaxAggregateOutputType = {
    id_client: number | null
    client: string | null
    logo: string | null
    alt_logo: string | null
    lien_client: string | null
    ordre: number | null
    afficher: boolean | null
  }

  export type Accueil_clientsCountAggregateOutputType = {
    id_client: number
    client: number
    logo: number
    alt_logo: number
    lien_client: number
    ordre: number
    afficher: number
    _all: number
  }


  export type Accueil_clientsAvgAggregateInputType = {
    id_client?: true
    ordre?: true
  }

  export type Accueil_clientsSumAggregateInputType = {
    id_client?: true
    ordre?: true
  }

  export type Accueil_clientsMinAggregateInputType = {
    id_client?: true
    client?: true
    logo?: true
    alt_logo?: true
    lien_client?: true
    ordre?: true
    afficher?: true
  }

  export type Accueil_clientsMaxAggregateInputType = {
    id_client?: true
    client?: true
    logo?: true
    alt_logo?: true
    lien_client?: true
    ordre?: true
    afficher?: true
  }

  export type Accueil_clientsCountAggregateInputType = {
    id_client?: true
    client?: true
    logo?: true
    alt_logo?: true
    lien_client?: true
    ordre?: true
    afficher?: true
    _all?: true
  }

  export type Accueil_clientsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which accueil_clients to aggregate.
     */
    where?: accueil_clientsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of accueil_clients to fetch.
     */
    orderBy?: accueil_clientsOrderByWithRelationInput | accueil_clientsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: accueil_clientsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` accueil_clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` accueil_clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned accueil_clients
    **/
    _count?: true | Accueil_clientsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Accueil_clientsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Accueil_clientsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Accueil_clientsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Accueil_clientsMaxAggregateInputType
  }

  export type GetAccueil_clientsAggregateType<T extends Accueil_clientsAggregateArgs> = {
        [P in keyof T & keyof AggregateAccueil_clients]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccueil_clients[P]>
      : GetScalarType<T[P], AggregateAccueil_clients[P]>
  }




  export type accueil_clientsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: accueil_clientsWhereInput
    orderBy?: accueil_clientsOrderByWithAggregationInput | accueil_clientsOrderByWithAggregationInput[]
    by: Accueil_clientsScalarFieldEnum[] | Accueil_clientsScalarFieldEnum
    having?: accueil_clientsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Accueil_clientsCountAggregateInputType | true
    _avg?: Accueil_clientsAvgAggregateInputType
    _sum?: Accueil_clientsSumAggregateInputType
    _min?: Accueil_clientsMinAggregateInputType
    _max?: Accueil_clientsMaxAggregateInputType
  }

  export type Accueil_clientsGroupByOutputType = {
    id_client: number
    client: string
    logo: string
    alt_logo: string
    lien_client: string
    ordre: number
    afficher: boolean
    _count: Accueil_clientsCountAggregateOutputType | null
    _avg: Accueil_clientsAvgAggregateOutputType | null
    _sum: Accueil_clientsSumAggregateOutputType | null
    _min: Accueil_clientsMinAggregateOutputType | null
    _max: Accueil_clientsMaxAggregateOutputType | null
  }

  type GetAccueil_clientsGroupByPayload<T extends accueil_clientsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Accueil_clientsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Accueil_clientsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Accueil_clientsGroupByOutputType[P]>
            : GetScalarType<T[P], Accueil_clientsGroupByOutputType[P]>
        }
      >
    >


  export type accueil_clientsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_client?: boolean
    client?: boolean
    logo?: boolean
    alt_logo?: boolean
    lien_client?: boolean
    ordre?: boolean
    afficher?: boolean
  }, ExtArgs["result"]["accueil_clients"]>



  export type accueil_clientsSelectScalar = {
    id_client?: boolean
    client?: boolean
    logo?: boolean
    alt_logo?: boolean
    lien_client?: boolean
    ordre?: boolean
    afficher?: boolean
  }

  export type accueil_clientsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id_client" | "client" | "logo" | "alt_logo" | "lien_client" | "ordre" | "afficher", ExtArgs["result"]["accueil_clients"]>

  export type $accueil_clientsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "accueil_clients"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id_client: number
      client: string
      logo: string
      alt_logo: string
      lien_client: string
      ordre: number
      afficher: boolean
    }, ExtArgs["result"]["accueil_clients"]>
    composites: {}
  }

  type accueil_clientsGetPayload<S extends boolean | null | undefined | accueil_clientsDefaultArgs> = $Result.GetResult<Prisma.$accueil_clientsPayload, S>

  type accueil_clientsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<accueil_clientsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Accueil_clientsCountAggregateInputType | true
    }

  export interface accueil_clientsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['accueil_clients'], meta: { name: 'accueil_clients' } }
    /**
     * Find zero or one Accueil_clients that matches the filter.
     * @param {accueil_clientsFindUniqueArgs} args - Arguments to find a Accueil_clients
     * @example
     * // Get one Accueil_clients
     * const accueil_clients = await prisma.accueil_clients.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends accueil_clientsFindUniqueArgs>(args: SelectSubset<T, accueil_clientsFindUniqueArgs<ExtArgs>>): Prisma__accueil_clientsClient<$Result.GetResult<Prisma.$accueil_clientsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Accueil_clients that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {accueil_clientsFindUniqueOrThrowArgs} args - Arguments to find a Accueil_clients
     * @example
     * // Get one Accueil_clients
     * const accueil_clients = await prisma.accueil_clients.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends accueil_clientsFindUniqueOrThrowArgs>(args: SelectSubset<T, accueil_clientsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__accueil_clientsClient<$Result.GetResult<Prisma.$accueil_clientsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Accueil_clients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {accueil_clientsFindFirstArgs} args - Arguments to find a Accueil_clients
     * @example
     * // Get one Accueil_clients
     * const accueil_clients = await prisma.accueil_clients.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends accueil_clientsFindFirstArgs>(args?: SelectSubset<T, accueil_clientsFindFirstArgs<ExtArgs>>): Prisma__accueil_clientsClient<$Result.GetResult<Prisma.$accueil_clientsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Accueil_clients that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {accueil_clientsFindFirstOrThrowArgs} args - Arguments to find a Accueil_clients
     * @example
     * // Get one Accueil_clients
     * const accueil_clients = await prisma.accueil_clients.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends accueil_clientsFindFirstOrThrowArgs>(args?: SelectSubset<T, accueil_clientsFindFirstOrThrowArgs<ExtArgs>>): Prisma__accueil_clientsClient<$Result.GetResult<Prisma.$accueil_clientsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Accueil_clients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {accueil_clientsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accueil_clients
     * const accueil_clients = await prisma.accueil_clients.findMany()
     * 
     * // Get first 10 Accueil_clients
     * const accueil_clients = await prisma.accueil_clients.findMany({ take: 10 })
     * 
     * // Only select the `id_client`
     * const accueil_clientsWithId_clientOnly = await prisma.accueil_clients.findMany({ select: { id_client: true } })
     * 
     */
    findMany<T extends accueil_clientsFindManyArgs>(args?: SelectSubset<T, accueil_clientsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$accueil_clientsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Accueil_clients.
     * @param {accueil_clientsCreateArgs} args - Arguments to create a Accueil_clients.
     * @example
     * // Create one Accueil_clients
     * const Accueil_clients = await prisma.accueil_clients.create({
     *   data: {
     *     // ... data to create a Accueil_clients
     *   }
     * })
     * 
     */
    create<T extends accueil_clientsCreateArgs>(args: SelectSubset<T, accueil_clientsCreateArgs<ExtArgs>>): Prisma__accueil_clientsClient<$Result.GetResult<Prisma.$accueil_clientsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Accueil_clients.
     * @param {accueil_clientsCreateManyArgs} args - Arguments to create many Accueil_clients.
     * @example
     * // Create many Accueil_clients
     * const accueil_clients = await prisma.accueil_clients.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends accueil_clientsCreateManyArgs>(args?: SelectSubset<T, accueil_clientsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Accueil_clients.
     * @param {accueil_clientsDeleteArgs} args - Arguments to delete one Accueil_clients.
     * @example
     * // Delete one Accueil_clients
     * const Accueil_clients = await prisma.accueil_clients.delete({
     *   where: {
     *     // ... filter to delete one Accueil_clients
     *   }
     * })
     * 
     */
    delete<T extends accueil_clientsDeleteArgs>(args: SelectSubset<T, accueil_clientsDeleteArgs<ExtArgs>>): Prisma__accueil_clientsClient<$Result.GetResult<Prisma.$accueil_clientsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Accueil_clients.
     * @param {accueil_clientsUpdateArgs} args - Arguments to update one Accueil_clients.
     * @example
     * // Update one Accueil_clients
     * const accueil_clients = await prisma.accueil_clients.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends accueil_clientsUpdateArgs>(args: SelectSubset<T, accueil_clientsUpdateArgs<ExtArgs>>): Prisma__accueil_clientsClient<$Result.GetResult<Prisma.$accueil_clientsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Accueil_clients.
     * @param {accueil_clientsDeleteManyArgs} args - Arguments to filter Accueil_clients to delete.
     * @example
     * // Delete a few Accueil_clients
     * const { count } = await prisma.accueil_clients.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends accueil_clientsDeleteManyArgs>(args?: SelectSubset<T, accueil_clientsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accueil_clients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {accueil_clientsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accueil_clients
     * const accueil_clients = await prisma.accueil_clients.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends accueil_clientsUpdateManyArgs>(args: SelectSubset<T, accueil_clientsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Accueil_clients.
     * @param {accueil_clientsUpsertArgs} args - Arguments to update or create a Accueil_clients.
     * @example
     * // Update or create a Accueil_clients
     * const accueil_clients = await prisma.accueil_clients.upsert({
     *   create: {
     *     // ... data to create a Accueil_clients
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Accueil_clients we want to update
     *   }
     * })
     */
    upsert<T extends accueil_clientsUpsertArgs>(args: SelectSubset<T, accueil_clientsUpsertArgs<ExtArgs>>): Prisma__accueil_clientsClient<$Result.GetResult<Prisma.$accueil_clientsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Accueil_clients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {accueil_clientsCountArgs} args - Arguments to filter Accueil_clients to count.
     * @example
     * // Count the number of Accueil_clients
     * const count = await prisma.accueil_clients.count({
     *   where: {
     *     // ... the filter for the Accueil_clients we want to count
     *   }
     * })
    **/
    count<T extends accueil_clientsCountArgs>(
      args?: Subset<T, accueil_clientsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Accueil_clientsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Accueil_clients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Accueil_clientsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Accueil_clientsAggregateArgs>(args: Subset<T, Accueil_clientsAggregateArgs>): Prisma.PrismaPromise<GetAccueil_clientsAggregateType<T>>

    /**
     * Group by Accueil_clients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {accueil_clientsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends accueil_clientsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: accueil_clientsGroupByArgs['orderBy'] }
        : { orderBy?: accueil_clientsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, accueil_clientsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccueil_clientsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the accueil_clients model
   */
  readonly fields: accueil_clientsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for accueil_clients.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__accueil_clientsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the accueil_clients model
   */
  interface accueil_clientsFieldRefs {
    readonly id_client: FieldRef<"accueil_clients", 'Int'>
    readonly client: FieldRef<"accueil_clients", 'String'>
    readonly logo: FieldRef<"accueil_clients", 'String'>
    readonly alt_logo: FieldRef<"accueil_clients", 'String'>
    readonly lien_client: FieldRef<"accueil_clients", 'String'>
    readonly ordre: FieldRef<"accueil_clients", 'Int'>
    readonly afficher: FieldRef<"accueil_clients", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * accueil_clients findUnique
   */
  export type accueil_clientsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accueil_clients
     */
    select?: accueil_clientsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the accueil_clients
     */
    omit?: accueil_clientsOmit<ExtArgs> | null
    /**
     * Filter, which accueil_clients to fetch.
     */
    where: accueil_clientsWhereUniqueInput
  }

  /**
   * accueil_clients findUniqueOrThrow
   */
  export type accueil_clientsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accueil_clients
     */
    select?: accueil_clientsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the accueil_clients
     */
    omit?: accueil_clientsOmit<ExtArgs> | null
    /**
     * Filter, which accueil_clients to fetch.
     */
    where: accueil_clientsWhereUniqueInput
  }

  /**
   * accueil_clients findFirst
   */
  export type accueil_clientsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accueil_clients
     */
    select?: accueil_clientsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the accueil_clients
     */
    omit?: accueil_clientsOmit<ExtArgs> | null
    /**
     * Filter, which accueil_clients to fetch.
     */
    where?: accueil_clientsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of accueil_clients to fetch.
     */
    orderBy?: accueil_clientsOrderByWithRelationInput | accueil_clientsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for accueil_clients.
     */
    cursor?: accueil_clientsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` accueil_clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` accueil_clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of accueil_clients.
     */
    distinct?: Accueil_clientsScalarFieldEnum | Accueil_clientsScalarFieldEnum[]
  }

  /**
   * accueil_clients findFirstOrThrow
   */
  export type accueil_clientsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accueil_clients
     */
    select?: accueil_clientsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the accueil_clients
     */
    omit?: accueil_clientsOmit<ExtArgs> | null
    /**
     * Filter, which accueil_clients to fetch.
     */
    where?: accueil_clientsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of accueil_clients to fetch.
     */
    orderBy?: accueil_clientsOrderByWithRelationInput | accueil_clientsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for accueil_clients.
     */
    cursor?: accueil_clientsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` accueil_clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` accueil_clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of accueil_clients.
     */
    distinct?: Accueil_clientsScalarFieldEnum | Accueil_clientsScalarFieldEnum[]
  }

  /**
   * accueil_clients findMany
   */
  export type accueil_clientsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accueil_clients
     */
    select?: accueil_clientsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the accueil_clients
     */
    omit?: accueil_clientsOmit<ExtArgs> | null
    /**
     * Filter, which accueil_clients to fetch.
     */
    where?: accueil_clientsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of accueil_clients to fetch.
     */
    orderBy?: accueil_clientsOrderByWithRelationInput | accueil_clientsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing accueil_clients.
     */
    cursor?: accueil_clientsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` accueil_clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` accueil_clients.
     */
    skip?: number
    distinct?: Accueil_clientsScalarFieldEnum | Accueil_clientsScalarFieldEnum[]
  }

  /**
   * accueil_clients create
   */
  export type accueil_clientsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accueil_clients
     */
    select?: accueil_clientsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the accueil_clients
     */
    omit?: accueil_clientsOmit<ExtArgs> | null
    /**
     * The data needed to create a accueil_clients.
     */
    data: XOR<accueil_clientsCreateInput, accueil_clientsUncheckedCreateInput>
  }

  /**
   * accueil_clients createMany
   */
  export type accueil_clientsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many accueil_clients.
     */
    data: accueil_clientsCreateManyInput | accueil_clientsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * accueil_clients update
   */
  export type accueil_clientsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accueil_clients
     */
    select?: accueil_clientsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the accueil_clients
     */
    omit?: accueil_clientsOmit<ExtArgs> | null
    /**
     * The data needed to update a accueil_clients.
     */
    data: XOR<accueil_clientsUpdateInput, accueil_clientsUncheckedUpdateInput>
    /**
     * Choose, which accueil_clients to update.
     */
    where: accueil_clientsWhereUniqueInput
  }

  /**
   * accueil_clients updateMany
   */
  export type accueil_clientsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update accueil_clients.
     */
    data: XOR<accueil_clientsUpdateManyMutationInput, accueil_clientsUncheckedUpdateManyInput>
    /**
     * Filter which accueil_clients to update
     */
    where?: accueil_clientsWhereInput
    /**
     * Limit how many accueil_clients to update.
     */
    limit?: number
  }

  /**
   * accueil_clients upsert
   */
  export type accueil_clientsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accueil_clients
     */
    select?: accueil_clientsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the accueil_clients
     */
    omit?: accueil_clientsOmit<ExtArgs> | null
    /**
     * The filter to search for the accueil_clients to update in case it exists.
     */
    where: accueil_clientsWhereUniqueInput
    /**
     * In case the accueil_clients found by the `where` argument doesn't exist, create a new accueil_clients with this data.
     */
    create: XOR<accueil_clientsCreateInput, accueil_clientsUncheckedCreateInput>
    /**
     * In case the accueil_clients was found with the provided `where` argument, update it with this data.
     */
    update: XOR<accueil_clientsUpdateInput, accueil_clientsUncheckedUpdateInput>
  }

  /**
   * accueil_clients delete
   */
  export type accueil_clientsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accueil_clients
     */
    select?: accueil_clientsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the accueil_clients
     */
    omit?: accueil_clientsOmit<ExtArgs> | null
    /**
     * Filter which accueil_clients to delete.
     */
    where: accueil_clientsWhereUniqueInput
  }

  /**
   * accueil_clients deleteMany
   */
  export type accueil_clientsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which accueil_clients to delete
     */
    where?: accueil_clientsWhereInput
    /**
     * Limit how many accueil_clients to delete.
     */
    limit?: number
  }

  /**
   * accueil_clients without action
   */
  export type accueil_clientsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accueil_clients
     */
    select?: accueil_clientsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the accueil_clients
     */
    omit?: accueil_clientsOmit<ExtArgs> | null
  }


  /**
   * Model accueil_faq
   */

  export type AggregateAccueil_faq = {
    _count: Accueil_faqCountAggregateOutputType | null
    _avg: Accueil_faqAvgAggregateOutputType | null
    _sum: Accueil_faqSumAggregateOutputType | null
    _min: Accueil_faqMinAggregateOutputType | null
    _max: Accueil_faqMaxAggregateOutputType | null
  }

  export type Accueil_faqAvgAggregateOutputType = {
    id_faq: number | null
    ordre: number | null
  }

  export type Accueil_faqSumAggregateOutputType = {
    id_faq: number | null
    ordre: number | null
  }

  export type Accueil_faqMinAggregateOutputType = {
    id_faq: number | null
    titre: string | null
    contenu: string | null
    ordre: number | null
    afficher: boolean | null
  }

  export type Accueil_faqMaxAggregateOutputType = {
    id_faq: number | null
    titre: string | null
    contenu: string | null
    ordre: number | null
    afficher: boolean | null
  }

  export type Accueil_faqCountAggregateOutputType = {
    id_faq: number
    titre: number
    contenu: number
    ordre: number
    afficher: number
    _all: number
  }


  export type Accueil_faqAvgAggregateInputType = {
    id_faq?: true
    ordre?: true
  }

  export type Accueil_faqSumAggregateInputType = {
    id_faq?: true
    ordre?: true
  }

  export type Accueil_faqMinAggregateInputType = {
    id_faq?: true
    titre?: true
    contenu?: true
    ordre?: true
    afficher?: true
  }

  export type Accueil_faqMaxAggregateInputType = {
    id_faq?: true
    titre?: true
    contenu?: true
    ordre?: true
    afficher?: true
  }

  export type Accueil_faqCountAggregateInputType = {
    id_faq?: true
    titre?: true
    contenu?: true
    ordre?: true
    afficher?: true
    _all?: true
  }

  export type Accueil_faqAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which accueil_faq to aggregate.
     */
    where?: accueil_faqWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of accueil_faqs to fetch.
     */
    orderBy?: accueil_faqOrderByWithRelationInput | accueil_faqOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: accueil_faqWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` accueil_faqs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` accueil_faqs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned accueil_faqs
    **/
    _count?: true | Accueil_faqCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Accueil_faqAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Accueil_faqSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Accueil_faqMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Accueil_faqMaxAggregateInputType
  }

  export type GetAccueil_faqAggregateType<T extends Accueil_faqAggregateArgs> = {
        [P in keyof T & keyof AggregateAccueil_faq]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccueil_faq[P]>
      : GetScalarType<T[P], AggregateAccueil_faq[P]>
  }




  export type accueil_faqGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: accueil_faqWhereInput
    orderBy?: accueil_faqOrderByWithAggregationInput | accueil_faqOrderByWithAggregationInput[]
    by: Accueil_faqScalarFieldEnum[] | Accueil_faqScalarFieldEnum
    having?: accueil_faqScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Accueil_faqCountAggregateInputType | true
    _avg?: Accueil_faqAvgAggregateInputType
    _sum?: Accueil_faqSumAggregateInputType
    _min?: Accueil_faqMinAggregateInputType
    _max?: Accueil_faqMaxAggregateInputType
  }

  export type Accueil_faqGroupByOutputType = {
    id_faq: number
    titre: string
    contenu: string
    ordre: number
    afficher: boolean
    _count: Accueil_faqCountAggregateOutputType | null
    _avg: Accueil_faqAvgAggregateOutputType | null
    _sum: Accueil_faqSumAggregateOutputType | null
    _min: Accueil_faqMinAggregateOutputType | null
    _max: Accueil_faqMaxAggregateOutputType | null
  }

  type GetAccueil_faqGroupByPayload<T extends accueil_faqGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Accueil_faqGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Accueil_faqGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Accueil_faqGroupByOutputType[P]>
            : GetScalarType<T[P], Accueil_faqGroupByOutputType[P]>
        }
      >
    >


  export type accueil_faqSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_faq?: boolean
    titre?: boolean
    contenu?: boolean
    ordre?: boolean
    afficher?: boolean
  }, ExtArgs["result"]["accueil_faq"]>



  export type accueil_faqSelectScalar = {
    id_faq?: boolean
    titre?: boolean
    contenu?: boolean
    ordre?: boolean
    afficher?: boolean
  }

  export type accueil_faqOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id_faq" | "titre" | "contenu" | "ordre" | "afficher", ExtArgs["result"]["accueil_faq"]>

  export type $accueil_faqPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "accueil_faq"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id_faq: number
      titre: string
      contenu: string
      ordre: number
      afficher: boolean
    }, ExtArgs["result"]["accueil_faq"]>
    composites: {}
  }

  type accueil_faqGetPayload<S extends boolean | null | undefined | accueil_faqDefaultArgs> = $Result.GetResult<Prisma.$accueil_faqPayload, S>

  type accueil_faqCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<accueil_faqFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Accueil_faqCountAggregateInputType | true
    }

  export interface accueil_faqDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['accueil_faq'], meta: { name: 'accueil_faq' } }
    /**
     * Find zero or one Accueil_faq that matches the filter.
     * @param {accueil_faqFindUniqueArgs} args - Arguments to find a Accueil_faq
     * @example
     * // Get one Accueil_faq
     * const accueil_faq = await prisma.accueil_faq.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends accueil_faqFindUniqueArgs>(args: SelectSubset<T, accueil_faqFindUniqueArgs<ExtArgs>>): Prisma__accueil_faqClient<$Result.GetResult<Prisma.$accueil_faqPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Accueil_faq that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {accueil_faqFindUniqueOrThrowArgs} args - Arguments to find a Accueil_faq
     * @example
     * // Get one Accueil_faq
     * const accueil_faq = await prisma.accueil_faq.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends accueil_faqFindUniqueOrThrowArgs>(args: SelectSubset<T, accueil_faqFindUniqueOrThrowArgs<ExtArgs>>): Prisma__accueil_faqClient<$Result.GetResult<Prisma.$accueil_faqPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Accueil_faq that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {accueil_faqFindFirstArgs} args - Arguments to find a Accueil_faq
     * @example
     * // Get one Accueil_faq
     * const accueil_faq = await prisma.accueil_faq.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends accueil_faqFindFirstArgs>(args?: SelectSubset<T, accueil_faqFindFirstArgs<ExtArgs>>): Prisma__accueil_faqClient<$Result.GetResult<Prisma.$accueil_faqPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Accueil_faq that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {accueil_faqFindFirstOrThrowArgs} args - Arguments to find a Accueil_faq
     * @example
     * // Get one Accueil_faq
     * const accueil_faq = await prisma.accueil_faq.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends accueil_faqFindFirstOrThrowArgs>(args?: SelectSubset<T, accueil_faqFindFirstOrThrowArgs<ExtArgs>>): Prisma__accueil_faqClient<$Result.GetResult<Prisma.$accueil_faqPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Accueil_faqs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {accueil_faqFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accueil_faqs
     * const accueil_faqs = await prisma.accueil_faq.findMany()
     * 
     * // Get first 10 Accueil_faqs
     * const accueil_faqs = await prisma.accueil_faq.findMany({ take: 10 })
     * 
     * // Only select the `id_faq`
     * const accueil_faqWithId_faqOnly = await prisma.accueil_faq.findMany({ select: { id_faq: true } })
     * 
     */
    findMany<T extends accueil_faqFindManyArgs>(args?: SelectSubset<T, accueil_faqFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$accueil_faqPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Accueil_faq.
     * @param {accueil_faqCreateArgs} args - Arguments to create a Accueil_faq.
     * @example
     * // Create one Accueil_faq
     * const Accueil_faq = await prisma.accueil_faq.create({
     *   data: {
     *     // ... data to create a Accueil_faq
     *   }
     * })
     * 
     */
    create<T extends accueil_faqCreateArgs>(args: SelectSubset<T, accueil_faqCreateArgs<ExtArgs>>): Prisma__accueil_faqClient<$Result.GetResult<Prisma.$accueil_faqPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Accueil_faqs.
     * @param {accueil_faqCreateManyArgs} args - Arguments to create many Accueil_faqs.
     * @example
     * // Create many Accueil_faqs
     * const accueil_faq = await prisma.accueil_faq.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends accueil_faqCreateManyArgs>(args?: SelectSubset<T, accueil_faqCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Accueil_faq.
     * @param {accueil_faqDeleteArgs} args - Arguments to delete one Accueil_faq.
     * @example
     * // Delete one Accueil_faq
     * const Accueil_faq = await prisma.accueil_faq.delete({
     *   where: {
     *     // ... filter to delete one Accueil_faq
     *   }
     * })
     * 
     */
    delete<T extends accueil_faqDeleteArgs>(args: SelectSubset<T, accueil_faqDeleteArgs<ExtArgs>>): Prisma__accueil_faqClient<$Result.GetResult<Prisma.$accueil_faqPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Accueil_faq.
     * @param {accueil_faqUpdateArgs} args - Arguments to update one Accueil_faq.
     * @example
     * // Update one Accueil_faq
     * const accueil_faq = await prisma.accueil_faq.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends accueil_faqUpdateArgs>(args: SelectSubset<T, accueil_faqUpdateArgs<ExtArgs>>): Prisma__accueil_faqClient<$Result.GetResult<Prisma.$accueil_faqPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Accueil_faqs.
     * @param {accueil_faqDeleteManyArgs} args - Arguments to filter Accueil_faqs to delete.
     * @example
     * // Delete a few Accueil_faqs
     * const { count } = await prisma.accueil_faq.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends accueil_faqDeleteManyArgs>(args?: SelectSubset<T, accueil_faqDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accueil_faqs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {accueil_faqUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accueil_faqs
     * const accueil_faq = await prisma.accueil_faq.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends accueil_faqUpdateManyArgs>(args: SelectSubset<T, accueil_faqUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Accueil_faq.
     * @param {accueil_faqUpsertArgs} args - Arguments to update or create a Accueil_faq.
     * @example
     * // Update or create a Accueil_faq
     * const accueil_faq = await prisma.accueil_faq.upsert({
     *   create: {
     *     // ... data to create a Accueil_faq
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Accueil_faq we want to update
     *   }
     * })
     */
    upsert<T extends accueil_faqUpsertArgs>(args: SelectSubset<T, accueil_faqUpsertArgs<ExtArgs>>): Prisma__accueil_faqClient<$Result.GetResult<Prisma.$accueil_faqPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Accueil_faqs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {accueil_faqCountArgs} args - Arguments to filter Accueil_faqs to count.
     * @example
     * // Count the number of Accueil_faqs
     * const count = await prisma.accueil_faq.count({
     *   where: {
     *     // ... the filter for the Accueil_faqs we want to count
     *   }
     * })
    **/
    count<T extends accueil_faqCountArgs>(
      args?: Subset<T, accueil_faqCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Accueil_faqCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Accueil_faq.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Accueil_faqAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Accueil_faqAggregateArgs>(args: Subset<T, Accueil_faqAggregateArgs>): Prisma.PrismaPromise<GetAccueil_faqAggregateType<T>>

    /**
     * Group by Accueil_faq.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {accueil_faqGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends accueil_faqGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: accueil_faqGroupByArgs['orderBy'] }
        : { orderBy?: accueil_faqGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, accueil_faqGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccueil_faqGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the accueil_faq model
   */
  readonly fields: accueil_faqFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for accueil_faq.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__accueil_faqClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the accueil_faq model
   */
  interface accueil_faqFieldRefs {
    readonly id_faq: FieldRef<"accueil_faq", 'Int'>
    readonly titre: FieldRef<"accueil_faq", 'String'>
    readonly contenu: FieldRef<"accueil_faq", 'String'>
    readonly ordre: FieldRef<"accueil_faq", 'Int'>
    readonly afficher: FieldRef<"accueil_faq", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * accueil_faq findUnique
   */
  export type accueil_faqFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accueil_faq
     */
    select?: accueil_faqSelect<ExtArgs> | null
    /**
     * Omit specific fields from the accueil_faq
     */
    omit?: accueil_faqOmit<ExtArgs> | null
    /**
     * Filter, which accueil_faq to fetch.
     */
    where: accueil_faqWhereUniqueInput
  }

  /**
   * accueil_faq findUniqueOrThrow
   */
  export type accueil_faqFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accueil_faq
     */
    select?: accueil_faqSelect<ExtArgs> | null
    /**
     * Omit specific fields from the accueil_faq
     */
    omit?: accueil_faqOmit<ExtArgs> | null
    /**
     * Filter, which accueil_faq to fetch.
     */
    where: accueil_faqWhereUniqueInput
  }

  /**
   * accueil_faq findFirst
   */
  export type accueil_faqFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accueil_faq
     */
    select?: accueil_faqSelect<ExtArgs> | null
    /**
     * Omit specific fields from the accueil_faq
     */
    omit?: accueil_faqOmit<ExtArgs> | null
    /**
     * Filter, which accueil_faq to fetch.
     */
    where?: accueil_faqWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of accueil_faqs to fetch.
     */
    orderBy?: accueil_faqOrderByWithRelationInput | accueil_faqOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for accueil_faqs.
     */
    cursor?: accueil_faqWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` accueil_faqs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` accueil_faqs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of accueil_faqs.
     */
    distinct?: Accueil_faqScalarFieldEnum | Accueil_faqScalarFieldEnum[]
  }

  /**
   * accueil_faq findFirstOrThrow
   */
  export type accueil_faqFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accueil_faq
     */
    select?: accueil_faqSelect<ExtArgs> | null
    /**
     * Omit specific fields from the accueil_faq
     */
    omit?: accueil_faqOmit<ExtArgs> | null
    /**
     * Filter, which accueil_faq to fetch.
     */
    where?: accueil_faqWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of accueil_faqs to fetch.
     */
    orderBy?: accueil_faqOrderByWithRelationInput | accueil_faqOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for accueil_faqs.
     */
    cursor?: accueil_faqWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` accueil_faqs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` accueil_faqs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of accueil_faqs.
     */
    distinct?: Accueil_faqScalarFieldEnum | Accueil_faqScalarFieldEnum[]
  }

  /**
   * accueil_faq findMany
   */
  export type accueil_faqFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accueil_faq
     */
    select?: accueil_faqSelect<ExtArgs> | null
    /**
     * Omit specific fields from the accueil_faq
     */
    omit?: accueil_faqOmit<ExtArgs> | null
    /**
     * Filter, which accueil_faqs to fetch.
     */
    where?: accueil_faqWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of accueil_faqs to fetch.
     */
    orderBy?: accueil_faqOrderByWithRelationInput | accueil_faqOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing accueil_faqs.
     */
    cursor?: accueil_faqWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` accueil_faqs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` accueil_faqs.
     */
    skip?: number
    distinct?: Accueil_faqScalarFieldEnum | Accueil_faqScalarFieldEnum[]
  }

  /**
   * accueil_faq create
   */
  export type accueil_faqCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accueil_faq
     */
    select?: accueil_faqSelect<ExtArgs> | null
    /**
     * Omit specific fields from the accueil_faq
     */
    omit?: accueil_faqOmit<ExtArgs> | null
    /**
     * The data needed to create a accueil_faq.
     */
    data: XOR<accueil_faqCreateInput, accueil_faqUncheckedCreateInput>
  }

  /**
   * accueil_faq createMany
   */
  export type accueil_faqCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many accueil_faqs.
     */
    data: accueil_faqCreateManyInput | accueil_faqCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * accueil_faq update
   */
  export type accueil_faqUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accueil_faq
     */
    select?: accueil_faqSelect<ExtArgs> | null
    /**
     * Omit specific fields from the accueil_faq
     */
    omit?: accueil_faqOmit<ExtArgs> | null
    /**
     * The data needed to update a accueil_faq.
     */
    data: XOR<accueil_faqUpdateInput, accueil_faqUncheckedUpdateInput>
    /**
     * Choose, which accueil_faq to update.
     */
    where: accueil_faqWhereUniqueInput
  }

  /**
   * accueil_faq updateMany
   */
  export type accueil_faqUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update accueil_faqs.
     */
    data: XOR<accueil_faqUpdateManyMutationInput, accueil_faqUncheckedUpdateManyInput>
    /**
     * Filter which accueil_faqs to update
     */
    where?: accueil_faqWhereInput
    /**
     * Limit how many accueil_faqs to update.
     */
    limit?: number
  }

  /**
   * accueil_faq upsert
   */
  export type accueil_faqUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accueil_faq
     */
    select?: accueil_faqSelect<ExtArgs> | null
    /**
     * Omit specific fields from the accueil_faq
     */
    omit?: accueil_faqOmit<ExtArgs> | null
    /**
     * The filter to search for the accueil_faq to update in case it exists.
     */
    where: accueil_faqWhereUniqueInput
    /**
     * In case the accueil_faq found by the `where` argument doesn't exist, create a new accueil_faq with this data.
     */
    create: XOR<accueil_faqCreateInput, accueil_faqUncheckedCreateInput>
    /**
     * In case the accueil_faq was found with the provided `where` argument, update it with this data.
     */
    update: XOR<accueil_faqUpdateInput, accueil_faqUncheckedUpdateInput>
  }

  /**
   * accueil_faq delete
   */
  export type accueil_faqDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accueil_faq
     */
    select?: accueil_faqSelect<ExtArgs> | null
    /**
     * Omit specific fields from the accueil_faq
     */
    omit?: accueil_faqOmit<ExtArgs> | null
    /**
     * Filter which accueil_faq to delete.
     */
    where: accueil_faqWhereUniqueInput
  }

  /**
   * accueil_faq deleteMany
   */
  export type accueil_faqDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which accueil_faqs to delete
     */
    where?: accueil_faqWhereInput
    /**
     * Limit how many accueil_faqs to delete.
     */
    limit?: number
  }

  /**
   * accueil_faq without action
   */
  export type accueil_faqDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accueil_faq
     */
    select?: accueil_faqSelect<ExtArgs> | null
    /**
     * Omit specific fields from the accueil_faq
     */
    omit?: accueil_faqOmit<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const AccountScalarFieldEnum: {
    id: 'id',
    accountId: 'accountId',
    providerId: 'providerId',
    userId: 'userId',
    accessToken: 'accessToken',
    refreshToken: 'refreshToken',
    idToken: 'idToken',
    accessTokenExpiresAt: 'accessTokenExpiresAt',
    refreshTokenExpiresAt: 'refreshTokenExpiresAt',
    scope: 'scope',
    password: 'password',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AccountScalarFieldEnum = (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum]


  export const Accueil_generalScalarFieldEnum: {
    id_gen: 'id_gen',
    video_desktop: 'video_desktop',
    video_mobile: 'video_mobile',
    video_cover: 'video_cover',
    photo: 'photo',
    photo_alt: 'photo_alt',
    description: 'description',
    localisation: 'localisation'
  };

  export type Accueil_generalScalarFieldEnum = (typeof Accueil_generalScalarFieldEnum)[keyof typeof Accueil_generalScalarFieldEnum]


  export const Apropos_etudesScalarFieldEnum: {
    id_etu: 'id_etu',
    date_debut: 'date_debut',
    date_fin: 'date_fin',
    titre: 'titre',
    nom_ecole: 'nom_ecole',
    lien_ecole: 'lien_ecole',
    afficher: 'afficher'
  };

  export type Apropos_etudesScalarFieldEnum = (typeof Apropos_etudesScalarFieldEnum)[keyof typeof Apropos_etudesScalarFieldEnum]


  export const Apropos_experiencesScalarFieldEnum: {
    id_exp: 'id_exp',
    date_debut: 'date_debut',
    date_fin: 'date_fin',
    titre: 'titre',
    nom_entreprise: 'nom_entreprise',
    lien_entreprise: 'lien_entreprise',
    afficher: 'afficher'
  };

  export type Apropos_experiencesScalarFieldEnum = (typeof Apropos_experiencesScalarFieldEnum)[keyof typeof Apropos_experiencesScalarFieldEnum]


  export const Apropos_generalScalarFieldEnum: {
    id_gen: 'id_gen',
    photo: 'photo',
    photo_alt: 'photo_alt',
    description: 'description'
  };

  export type Apropos_generalScalarFieldEnum = (typeof Apropos_generalScalarFieldEnum)[keyof typeof Apropos_generalScalarFieldEnum]


  export const Apropos_outilsScalarFieldEnum: {
    id_outil: 'id_outil',
    type_outil: 'type_outil',
    titre: 'titre',
    description: 'description',
    icone: 'icone',
    icone_alt: 'icone_alt',
    icone_rounded: 'icone_rounded',
    lien: 'lien',
    couleur_fond: 'couleur_fond',
    couleur_titre: 'couleur_titre',
    couleur_description: 'couleur_description',
    ordre: 'ordre',
    afficher: 'afficher'
  };

  export type Apropos_outilsScalarFieldEnum = (typeof Apropos_outilsScalarFieldEnum)[keyof typeof Apropos_outilsScalarFieldEnum]


  export const PhotosScalarFieldEnum: {
    id_pho: 'id_pho',
    lien_high: 'lien_high',
    lien_low: 'lien_low',
    largeur: 'largeur',
    hauteur: 'hauteur',
    alt: 'alt',
    date: 'date',
    afficher_carrousel_main: 'afficher_carrousel_main',
    afficher_carrousel_photos: 'afficher_carrousel_photos',
    afficher: 'afficher',
    derniere_modification: 'derniere_modification'
  };

  export type PhotosScalarFieldEnum = (typeof PhotosScalarFieldEnum)[keyof typeof PhotosScalarFieldEnum]


  export const Photos_albumsScalarFieldEnum: {
    id_alb: 'id_alb',
    titre: 'titre',
    lien_cover: 'lien_cover',
    date: 'date',
    afficher: 'afficher',
    derniere_modification: 'derniere_modification'
  };

  export type Photos_albumsScalarFieldEnum = (typeof Photos_albumsScalarFieldEnum)[keyof typeof Photos_albumsScalarFieldEnum]


  export const Photos_albums_linkScalarFieldEnum: {
    id_pho: 'id_pho',
    id_alb: 'id_alb',
    position: 'position'
  };

  export type Photos_albums_linkScalarFieldEnum = (typeof Photos_albums_linkScalarFieldEnum)[keyof typeof Photos_albums_linkScalarFieldEnum]


  export const Photos_albums_tags_linkScalarFieldEnum: {
    id_alb: 'id_alb',
    id_tags: 'id_tags'
  };

  export type Photos_albums_tags_linkScalarFieldEnum = (typeof Photos_albums_tags_linkScalarFieldEnum)[keyof typeof Photos_albums_tags_linkScalarFieldEnum]


  export const Photos_tagsScalarFieldEnum: {
    id_tags: 'id_tags',
    titre: 'titre',
    important: 'important'
  };

  export type Photos_tagsScalarFieldEnum = (typeof Photos_tagsScalarFieldEnum)[keyof typeof Photos_tagsScalarFieldEnum]


  export const Photos_tags_linkScalarFieldEnum: {
    id_pho: 'id_pho',
    id_tags: 'id_tags'
  };

  export type Photos_tags_linkScalarFieldEnum = (typeof Photos_tags_linkScalarFieldEnum)[keyof typeof Photos_tags_linkScalarFieldEnum]


  export const Photos_tags_rechercheScalarFieldEnum: {
    id_tags: 'id_tags',
    titre: 'titre',
    important: 'important'
  };

  export type Photos_tags_rechercheScalarFieldEnum = (typeof Photos_tags_rechercheScalarFieldEnum)[keyof typeof Photos_tags_rechercheScalarFieldEnum]


  export const Photos_tags_recherche_linkScalarFieldEnum: {
    id_pho: 'id_pho',
    id_tags: 'id_tags'
  };

  export type Photos_tags_recherche_linkScalarFieldEnum = (typeof Photos_tags_recherche_linkScalarFieldEnum)[keyof typeof Photos_tags_recherche_linkScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    id: 'id',
    expiresAt: 'expiresAt',
    token: 'token',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    userId: 'userId'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    emailVerified: 'emailVerified',
    image: 'image',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const UtilisateursScalarFieldEnum: {
    id_user: 'id_user',
    img: 'img',
    email: 'email',
    username: 'username',
    password: 'password',
    role: 'role'
  };

  export type UtilisateursScalarFieldEnum = (typeof UtilisateursScalarFieldEnum)[keyof typeof UtilisateursScalarFieldEnum]


  export const VerificationScalarFieldEnum: {
    id: 'id',
    identifier: 'identifier',
    value: 'value',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VerificationScalarFieldEnum = (typeof VerificationScalarFieldEnum)[keyof typeof VerificationScalarFieldEnum]


  export const VideosScalarFieldEnum: {
    id_vid: 'id_vid',
    titre: 'titre',
    lien: 'lien',
    date: 'date',
    afficher_carrousel_main: 'afficher_carrousel_main',
    afficher_section_videos: 'afficher_section_videos',
    tag_section_videos: 'tag_section_videos',
    afficher: 'afficher',
    derniere_modification: 'derniere_modification'
  };

  export type VideosScalarFieldEnum = (typeof VideosScalarFieldEnum)[keyof typeof VideosScalarFieldEnum]


  export const Videos_tagsScalarFieldEnum: {
    id_tags: 'id_tags',
    titre: 'titre',
    important: 'important'
  };

  export type Videos_tagsScalarFieldEnum = (typeof Videos_tagsScalarFieldEnum)[keyof typeof Videos_tagsScalarFieldEnum]


  export const Videos_tags_linkScalarFieldEnum: {
    id_vid: 'id_vid',
    id_tags: 'id_tags'
  };

  export type Videos_tags_linkScalarFieldEnum = (typeof Videos_tags_linkScalarFieldEnum)[keyof typeof Videos_tags_linkScalarFieldEnum]


  export const Accueil_clientsScalarFieldEnum: {
    id_client: 'id_client',
    client: 'client',
    logo: 'logo',
    alt_logo: 'alt_logo',
    lien_client: 'lien_client',
    ordre: 'ordre',
    afficher: 'afficher'
  };

  export type Accueil_clientsScalarFieldEnum = (typeof Accueil_clientsScalarFieldEnum)[keyof typeof Accueil_clientsScalarFieldEnum]


  export const Accueil_faqScalarFieldEnum: {
    id_faq: 'id_faq',
    titre: 'titre',
    contenu: 'contenu',
    ordre: 'ordre',
    afficher: 'afficher'
  };

  export type Accueil_faqScalarFieldEnum = (typeof Accueil_faqScalarFieldEnum)[keyof typeof Accueil_faqScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const accountOrderByRelevanceFieldEnum: {
    id: 'id',
    accountId: 'accountId',
    providerId: 'providerId',
    userId: 'userId',
    accessToken: 'accessToken',
    refreshToken: 'refreshToken',
    idToken: 'idToken',
    scope: 'scope',
    password: 'password'
  };

  export type accountOrderByRelevanceFieldEnum = (typeof accountOrderByRelevanceFieldEnum)[keyof typeof accountOrderByRelevanceFieldEnum]


  export const accueil_generalOrderByRelevanceFieldEnum: {
    video_desktop: 'video_desktop',
    video_mobile: 'video_mobile',
    video_cover: 'video_cover',
    photo: 'photo',
    photo_alt: 'photo_alt',
    description: 'description',
    localisation: 'localisation'
  };

  export type accueil_generalOrderByRelevanceFieldEnum = (typeof accueil_generalOrderByRelevanceFieldEnum)[keyof typeof accueil_generalOrderByRelevanceFieldEnum]


  export const apropos_etudesOrderByRelevanceFieldEnum: {
    titre: 'titre',
    nom_ecole: 'nom_ecole',
    lien_ecole: 'lien_ecole'
  };

  export type apropos_etudesOrderByRelevanceFieldEnum = (typeof apropos_etudesOrderByRelevanceFieldEnum)[keyof typeof apropos_etudesOrderByRelevanceFieldEnum]


  export const apropos_experiencesOrderByRelevanceFieldEnum: {
    titre: 'titre',
    nom_entreprise: 'nom_entreprise',
    lien_entreprise: 'lien_entreprise'
  };

  export type apropos_experiencesOrderByRelevanceFieldEnum = (typeof apropos_experiencesOrderByRelevanceFieldEnum)[keyof typeof apropos_experiencesOrderByRelevanceFieldEnum]


  export const apropos_generalOrderByRelevanceFieldEnum: {
    photo: 'photo',
    photo_alt: 'photo_alt',
    description: 'description'
  };

  export type apropos_generalOrderByRelevanceFieldEnum = (typeof apropos_generalOrderByRelevanceFieldEnum)[keyof typeof apropos_generalOrderByRelevanceFieldEnum]


  export const apropos_outilsOrderByRelevanceFieldEnum: {
    type_outil: 'type_outil',
    titre: 'titre',
    description: 'description',
    icone: 'icone',
    icone_alt: 'icone_alt',
    lien: 'lien',
    couleur_fond: 'couleur_fond',
    couleur_titre: 'couleur_titre',
    couleur_description: 'couleur_description'
  };

  export type apropos_outilsOrderByRelevanceFieldEnum = (typeof apropos_outilsOrderByRelevanceFieldEnum)[keyof typeof apropos_outilsOrderByRelevanceFieldEnum]


  export const photosOrderByRelevanceFieldEnum: {
    lien_high: 'lien_high',
    lien_low: 'lien_low',
    alt: 'alt'
  };

  export type photosOrderByRelevanceFieldEnum = (typeof photosOrderByRelevanceFieldEnum)[keyof typeof photosOrderByRelevanceFieldEnum]


  export const photos_albumsOrderByRelevanceFieldEnum: {
    titre: 'titre',
    lien_cover: 'lien_cover'
  };

  export type photos_albumsOrderByRelevanceFieldEnum = (typeof photos_albumsOrderByRelevanceFieldEnum)[keyof typeof photos_albumsOrderByRelevanceFieldEnum]


  export const photos_tagsOrderByRelevanceFieldEnum: {
    titre: 'titre'
  };

  export type photos_tagsOrderByRelevanceFieldEnum = (typeof photos_tagsOrderByRelevanceFieldEnum)[keyof typeof photos_tagsOrderByRelevanceFieldEnum]


  export const photos_tags_rechercheOrderByRelevanceFieldEnum: {
    titre: 'titre'
  };

  export type photos_tags_rechercheOrderByRelevanceFieldEnum = (typeof photos_tags_rechercheOrderByRelevanceFieldEnum)[keyof typeof photos_tags_rechercheOrderByRelevanceFieldEnum]


  export const sessionOrderByRelevanceFieldEnum: {
    id: 'id',
    token: 'token',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    userId: 'userId'
  };

  export type sessionOrderByRelevanceFieldEnum = (typeof sessionOrderByRelevanceFieldEnum)[keyof typeof sessionOrderByRelevanceFieldEnum]


  export const userOrderByRelevanceFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    image: 'image'
  };

  export type userOrderByRelevanceFieldEnum = (typeof userOrderByRelevanceFieldEnum)[keyof typeof userOrderByRelevanceFieldEnum]


  export const utilisateursOrderByRelevanceFieldEnum: {
    img: 'img',
    email: 'email',
    username: 'username',
    password: 'password',
    role: 'role'
  };

  export type utilisateursOrderByRelevanceFieldEnum = (typeof utilisateursOrderByRelevanceFieldEnum)[keyof typeof utilisateursOrderByRelevanceFieldEnum]


  export const verificationOrderByRelevanceFieldEnum: {
    id: 'id',
    identifier: 'identifier',
    value: 'value'
  };

  export type verificationOrderByRelevanceFieldEnum = (typeof verificationOrderByRelevanceFieldEnum)[keyof typeof verificationOrderByRelevanceFieldEnum]


  export const videosOrderByRelevanceFieldEnum: {
    titre: 'titre',
    lien: 'lien'
  };

  export type videosOrderByRelevanceFieldEnum = (typeof videosOrderByRelevanceFieldEnum)[keyof typeof videosOrderByRelevanceFieldEnum]


  export const videos_tagsOrderByRelevanceFieldEnum: {
    titre: 'titre'
  };

  export type videos_tagsOrderByRelevanceFieldEnum = (typeof videos_tagsOrderByRelevanceFieldEnum)[keyof typeof videos_tagsOrderByRelevanceFieldEnum]


  export const accueil_clientsOrderByRelevanceFieldEnum: {
    client: 'client',
    logo: 'logo',
    alt_logo: 'alt_logo',
    lien_client: 'lien_client'
  };

  export type accueil_clientsOrderByRelevanceFieldEnum = (typeof accueil_clientsOrderByRelevanceFieldEnum)[keyof typeof accueil_clientsOrderByRelevanceFieldEnum]


  export const accueil_faqOrderByRelevanceFieldEnum: {
    titre: 'titre',
    contenu: 'contenu'
  };

  export type accueil_faqOrderByRelevanceFieldEnum = (typeof accueil_faqOrderByRelevanceFieldEnum)[keyof typeof accueil_faqOrderByRelevanceFieldEnum]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type accountWhereInput = {
    AND?: accountWhereInput | accountWhereInput[]
    OR?: accountWhereInput[]
    NOT?: accountWhereInput | accountWhereInput[]
    id?: StringFilter<"account"> | string
    accountId?: StringFilter<"account"> | string
    providerId?: StringFilter<"account"> | string
    userId?: StringFilter<"account"> | string
    accessToken?: StringNullableFilter<"account"> | string | null
    refreshToken?: StringNullableFilter<"account"> | string | null
    idToken?: StringNullableFilter<"account"> | string | null
    accessTokenExpiresAt?: DateTimeNullableFilter<"account"> | Date | string | null
    refreshTokenExpiresAt?: DateTimeNullableFilter<"account"> | Date | string | null
    scope?: StringNullableFilter<"account"> | string | null
    password?: StringNullableFilter<"account"> | string | null
    createdAt?: DateTimeFilter<"account"> | Date | string
    updatedAt?: DateTimeFilter<"account"> | Date | string
  }

  export type accountOrderByWithRelationInput = {
    id?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    userId?: SortOrder
    accessToken?: SortOrderInput | SortOrder
    refreshToken?: SortOrderInput | SortOrder
    idToken?: SortOrderInput | SortOrder
    accessTokenExpiresAt?: SortOrderInput | SortOrder
    refreshTokenExpiresAt?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _relevance?: accountOrderByRelevanceInput
  }

  export type accountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: accountWhereInput | accountWhereInput[]
    OR?: accountWhereInput[]
    NOT?: accountWhereInput | accountWhereInput[]
    accountId?: StringFilter<"account"> | string
    providerId?: StringFilter<"account"> | string
    userId?: StringFilter<"account"> | string
    accessToken?: StringNullableFilter<"account"> | string | null
    refreshToken?: StringNullableFilter<"account"> | string | null
    idToken?: StringNullableFilter<"account"> | string | null
    accessTokenExpiresAt?: DateTimeNullableFilter<"account"> | Date | string | null
    refreshTokenExpiresAt?: DateTimeNullableFilter<"account"> | Date | string | null
    scope?: StringNullableFilter<"account"> | string | null
    password?: StringNullableFilter<"account"> | string | null
    createdAt?: DateTimeFilter<"account"> | Date | string
    updatedAt?: DateTimeFilter<"account"> | Date | string
  }, "id">

  export type accountOrderByWithAggregationInput = {
    id?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    userId?: SortOrder
    accessToken?: SortOrderInput | SortOrder
    refreshToken?: SortOrderInput | SortOrder
    idToken?: SortOrderInput | SortOrder
    accessTokenExpiresAt?: SortOrderInput | SortOrder
    refreshTokenExpiresAt?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: accountCountOrderByAggregateInput
    _max?: accountMaxOrderByAggregateInput
    _min?: accountMinOrderByAggregateInput
  }

  export type accountScalarWhereWithAggregatesInput = {
    AND?: accountScalarWhereWithAggregatesInput | accountScalarWhereWithAggregatesInput[]
    OR?: accountScalarWhereWithAggregatesInput[]
    NOT?: accountScalarWhereWithAggregatesInput | accountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"account"> | string
    accountId?: StringWithAggregatesFilter<"account"> | string
    providerId?: StringWithAggregatesFilter<"account"> | string
    userId?: StringWithAggregatesFilter<"account"> | string
    accessToken?: StringNullableWithAggregatesFilter<"account"> | string | null
    refreshToken?: StringNullableWithAggregatesFilter<"account"> | string | null
    idToken?: StringNullableWithAggregatesFilter<"account"> | string | null
    accessTokenExpiresAt?: DateTimeNullableWithAggregatesFilter<"account"> | Date | string | null
    refreshTokenExpiresAt?: DateTimeNullableWithAggregatesFilter<"account"> | Date | string | null
    scope?: StringNullableWithAggregatesFilter<"account"> | string | null
    password?: StringNullableWithAggregatesFilter<"account"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"account"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"account"> | Date | string
  }

  export type accueil_generalWhereInput = {
    AND?: accueil_generalWhereInput | accueil_generalWhereInput[]
    OR?: accueil_generalWhereInput[]
    NOT?: accueil_generalWhereInput | accueil_generalWhereInput[]
    id_gen?: IntFilter<"accueil_general"> | number
    video_desktop?: StringFilter<"accueil_general"> | string
    video_mobile?: StringFilter<"accueil_general"> | string
    video_cover?: StringFilter<"accueil_general"> | string
    photo?: StringFilter<"accueil_general"> | string
    photo_alt?: StringFilter<"accueil_general"> | string
    description?: StringFilter<"accueil_general"> | string
    localisation?: StringFilter<"accueil_general"> | string
  }

  export type accueil_generalOrderByWithRelationInput = {
    id_gen?: SortOrder
    video_desktop?: SortOrder
    video_mobile?: SortOrder
    video_cover?: SortOrder
    photo?: SortOrder
    photo_alt?: SortOrder
    description?: SortOrder
    localisation?: SortOrder
    _relevance?: accueil_generalOrderByRelevanceInput
  }

  export type accueil_generalWhereUniqueInput = Prisma.AtLeast<{
    id_gen?: number
    AND?: accueil_generalWhereInput | accueil_generalWhereInput[]
    OR?: accueil_generalWhereInput[]
    NOT?: accueil_generalWhereInput | accueil_generalWhereInput[]
    video_desktop?: StringFilter<"accueil_general"> | string
    video_mobile?: StringFilter<"accueil_general"> | string
    video_cover?: StringFilter<"accueil_general"> | string
    photo?: StringFilter<"accueil_general"> | string
    photo_alt?: StringFilter<"accueil_general"> | string
    description?: StringFilter<"accueil_general"> | string
    localisation?: StringFilter<"accueil_general"> | string
  }, "id_gen">

  export type accueil_generalOrderByWithAggregationInput = {
    id_gen?: SortOrder
    video_desktop?: SortOrder
    video_mobile?: SortOrder
    video_cover?: SortOrder
    photo?: SortOrder
    photo_alt?: SortOrder
    description?: SortOrder
    localisation?: SortOrder
    _count?: accueil_generalCountOrderByAggregateInput
    _avg?: accueil_generalAvgOrderByAggregateInput
    _max?: accueil_generalMaxOrderByAggregateInput
    _min?: accueil_generalMinOrderByAggregateInput
    _sum?: accueil_generalSumOrderByAggregateInput
  }

  export type accueil_generalScalarWhereWithAggregatesInput = {
    AND?: accueil_generalScalarWhereWithAggregatesInput | accueil_generalScalarWhereWithAggregatesInput[]
    OR?: accueil_generalScalarWhereWithAggregatesInput[]
    NOT?: accueil_generalScalarWhereWithAggregatesInput | accueil_generalScalarWhereWithAggregatesInput[]
    id_gen?: IntWithAggregatesFilter<"accueil_general"> | number
    video_desktop?: StringWithAggregatesFilter<"accueil_general"> | string
    video_mobile?: StringWithAggregatesFilter<"accueil_general"> | string
    video_cover?: StringWithAggregatesFilter<"accueil_general"> | string
    photo?: StringWithAggregatesFilter<"accueil_general"> | string
    photo_alt?: StringWithAggregatesFilter<"accueil_general"> | string
    description?: StringWithAggregatesFilter<"accueil_general"> | string
    localisation?: StringWithAggregatesFilter<"accueil_general"> | string
  }

  export type apropos_etudesWhereInput = {
    AND?: apropos_etudesWhereInput | apropos_etudesWhereInput[]
    OR?: apropos_etudesWhereInput[]
    NOT?: apropos_etudesWhereInput | apropos_etudesWhereInput[]
    id_etu?: IntFilter<"apropos_etudes"> | number
    date_debut?: DateTimeFilter<"apropos_etudes"> | Date | string
    date_fin?: DateTimeNullableFilter<"apropos_etudes"> | Date | string | null
    titre?: StringFilter<"apropos_etudes"> | string
    nom_ecole?: StringFilter<"apropos_etudes"> | string
    lien_ecole?: StringFilter<"apropos_etudes"> | string
    afficher?: BoolFilter<"apropos_etudes"> | boolean
  }

  export type apropos_etudesOrderByWithRelationInput = {
    id_etu?: SortOrder
    date_debut?: SortOrder
    date_fin?: SortOrderInput | SortOrder
    titre?: SortOrder
    nom_ecole?: SortOrder
    lien_ecole?: SortOrder
    afficher?: SortOrder
    _relevance?: apropos_etudesOrderByRelevanceInput
  }

  export type apropos_etudesWhereUniqueInput = Prisma.AtLeast<{
    id_etu?: number
    AND?: apropos_etudesWhereInput | apropos_etudesWhereInput[]
    OR?: apropos_etudesWhereInput[]
    NOT?: apropos_etudesWhereInput | apropos_etudesWhereInput[]
    date_debut?: DateTimeFilter<"apropos_etudes"> | Date | string
    date_fin?: DateTimeNullableFilter<"apropos_etudes"> | Date | string | null
    titre?: StringFilter<"apropos_etudes"> | string
    nom_ecole?: StringFilter<"apropos_etudes"> | string
    lien_ecole?: StringFilter<"apropos_etudes"> | string
    afficher?: BoolFilter<"apropos_etudes"> | boolean
  }, "id_etu">

  export type apropos_etudesOrderByWithAggregationInput = {
    id_etu?: SortOrder
    date_debut?: SortOrder
    date_fin?: SortOrderInput | SortOrder
    titre?: SortOrder
    nom_ecole?: SortOrder
    lien_ecole?: SortOrder
    afficher?: SortOrder
    _count?: apropos_etudesCountOrderByAggregateInput
    _avg?: apropos_etudesAvgOrderByAggregateInput
    _max?: apropos_etudesMaxOrderByAggregateInput
    _min?: apropos_etudesMinOrderByAggregateInput
    _sum?: apropos_etudesSumOrderByAggregateInput
  }

  export type apropos_etudesScalarWhereWithAggregatesInput = {
    AND?: apropos_etudesScalarWhereWithAggregatesInput | apropos_etudesScalarWhereWithAggregatesInput[]
    OR?: apropos_etudesScalarWhereWithAggregatesInput[]
    NOT?: apropos_etudesScalarWhereWithAggregatesInput | apropos_etudesScalarWhereWithAggregatesInput[]
    id_etu?: IntWithAggregatesFilter<"apropos_etudes"> | number
    date_debut?: DateTimeWithAggregatesFilter<"apropos_etudes"> | Date | string
    date_fin?: DateTimeNullableWithAggregatesFilter<"apropos_etudes"> | Date | string | null
    titre?: StringWithAggregatesFilter<"apropos_etudes"> | string
    nom_ecole?: StringWithAggregatesFilter<"apropos_etudes"> | string
    lien_ecole?: StringWithAggregatesFilter<"apropos_etudes"> | string
    afficher?: BoolWithAggregatesFilter<"apropos_etudes"> | boolean
  }

  export type apropos_experiencesWhereInput = {
    AND?: apropos_experiencesWhereInput | apropos_experiencesWhereInput[]
    OR?: apropos_experiencesWhereInput[]
    NOT?: apropos_experiencesWhereInput | apropos_experiencesWhereInput[]
    id_exp?: IntFilter<"apropos_experiences"> | number
    date_debut?: DateTimeFilter<"apropos_experiences"> | Date | string
    date_fin?: DateTimeNullableFilter<"apropos_experiences"> | Date | string | null
    titre?: StringFilter<"apropos_experiences"> | string
    nom_entreprise?: StringFilter<"apropos_experiences"> | string
    lien_entreprise?: StringFilter<"apropos_experiences"> | string
    afficher?: BoolFilter<"apropos_experiences"> | boolean
  }

  export type apropos_experiencesOrderByWithRelationInput = {
    id_exp?: SortOrder
    date_debut?: SortOrder
    date_fin?: SortOrderInput | SortOrder
    titre?: SortOrder
    nom_entreprise?: SortOrder
    lien_entreprise?: SortOrder
    afficher?: SortOrder
    _relevance?: apropos_experiencesOrderByRelevanceInput
  }

  export type apropos_experiencesWhereUniqueInput = Prisma.AtLeast<{
    id_exp?: number
    AND?: apropos_experiencesWhereInput | apropos_experiencesWhereInput[]
    OR?: apropos_experiencesWhereInput[]
    NOT?: apropos_experiencesWhereInput | apropos_experiencesWhereInput[]
    date_debut?: DateTimeFilter<"apropos_experiences"> | Date | string
    date_fin?: DateTimeNullableFilter<"apropos_experiences"> | Date | string | null
    titre?: StringFilter<"apropos_experiences"> | string
    nom_entreprise?: StringFilter<"apropos_experiences"> | string
    lien_entreprise?: StringFilter<"apropos_experiences"> | string
    afficher?: BoolFilter<"apropos_experiences"> | boolean
  }, "id_exp">

  export type apropos_experiencesOrderByWithAggregationInput = {
    id_exp?: SortOrder
    date_debut?: SortOrder
    date_fin?: SortOrderInput | SortOrder
    titre?: SortOrder
    nom_entreprise?: SortOrder
    lien_entreprise?: SortOrder
    afficher?: SortOrder
    _count?: apropos_experiencesCountOrderByAggregateInput
    _avg?: apropos_experiencesAvgOrderByAggregateInput
    _max?: apropos_experiencesMaxOrderByAggregateInput
    _min?: apropos_experiencesMinOrderByAggregateInput
    _sum?: apropos_experiencesSumOrderByAggregateInput
  }

  export type apropos_experiencesScalarWhereWithAggregatesInput = {
    AND?: apropos_experiencesScalarWhereWithAggregatesInput | apropos_experiencesScalarWhereWithAggregatesInput[]
    OR?: apropos_experiencesScalarWhereWithAggregatesInput[]
    NOT?: apropos_experiencesScalarWhereWithAggregatesInput | apropos_experiencesScalarWhereWithAggregatesInput[]
    id_exp?: IntWithAggregatesFilter<"apropos_experiences"> | number
    date_debut?: DateTimeWithAggregatesFilter<"apropos_experiences"> | Date | string
    date_fin?: DateTimeNullableWithAggregatesFilter<"apropos_experiences"> | Date | string | null
    titre?: StringWithAggregatesFilter<"apropos_experiences"> | string
    nom_entreprise?: StringWithAggregatesFilter<"apropos_experiences"> | string
    lien_entreprise?: StringWithAggregatesFilter<"apropos_experiences"> | string
    afficher?: BoolWithAggregatesFilter<"apropos_experiences"> | boolean
  }

  export type apropos_generalWhereInput = {
    AND?: apropos_generalWhereInput | apropos_generalWhereInput[]
    OR?: apropos_generalWhereInput[]
    NOT?: apropos_generalWhereInput | apropos_generalWhereInput[]
    id_gen?: IntFilter<"apropos_general"> | number
    photo?: StringFilter<"apropos_general"> | string
    photo_alt?: StringFilter<"apropos_general"> | string
    description?: StringFilter<"apropos_general"> | string
  }

  export type apropos_generalOrderByWithRelationInput = {
    id_gen?: SortOrder
    photo?: SortOrder
    photo_alt?: SortOrder
    description?: SortOrder
    _relevance?: apropos_generalOrderByRelevanceInput
  }

  export type apropos_generalWhereUniqueInput = Prisma.AtLeast<{
    id_gen?: number
    AND?: apropos_generalWhereInput | apropos_generalWhereInput[]
    OR?: apropos_generalWhereInput[]
    NOT?: apropos_generalWhereInput | apropos_generalWhereInput[]
    photo?: StringFilter<"apropos_general"> | string
    photo_alt?: StringFilter<"apropos_general"> | string
    description?: StringFilter<"apropos_general"> | string
  }, "id_gen">

  export type apropos_generalOrderByWithAggregationInput = {
    id_gen?: SortOrder
    photo?: SortOrder
    photo_alt?: SortOrder
    description?: SortOrder
    _count?: apropos_generalCountOrderByAggregateInput
    _avg?: apropos_generalAvgOrderByAggregateInput
    _max?: apropos_generalMaxOrderByAggregateInput
    _min?: apropos_generalMinOrderByAggregateInput
    _sum?: apropos_generalSumOrderByAggregateInput
  }

  export type apropos_generalScalarWhereWithAggregatesInput = {
    AND?: apropos_generalScalarWhereWithAggregatesInput | apropos_generalScalarWhereWithAggregatesInput[]
    OR?: apropos_generalScalarWhereWithAggregatesInput[]
    NOT?: apropos_generalScalarWhereWithAggregatesInput | apropos_generalScalarWhereWithAggregatesInput[]
    id_gen?: IntWithAggregatesFilter<"apropos_general"> | number
    photo?: StringWithAggregatesFilter<"apropos_general"> | string
    photo_alt?: StringWithAggregatesFilter<"apropos_general"> | string
    description?: StringWithAggregatesFilter<"apropos_general"> | string
  }

  export type apropos_outilsWhereInput = {
    AND?: apropos_outilsWhereInput | apropos_outilsWhereInput[]
    OR?: apropos_outilsWhereInput[]
    NOT?: apropos_outilsWhereInput | apropos_outilsWhereInput[]
    id_outil?: IntFilter<"apropos_outils"> | number
    type_outil?: StringFilter<"apropos_outils"> | string
    titre?: StringFilter<"apropos_outils"> | string
    description?: StringFilter<"apropos_outils"> | string
    icone?: StringFilter<"apropos_outils"> | string
    icone_alt?: StringFilter<"apropos_outils"> | string
    icone_rounded?: BoolFilter<"apropos_outils"> | boolean
    lien?: StringFilter<"apropos_outils"> | string
    couleur_fond?: StringFilter<"apropos_outils"> | string
    couleur_titre?: StringFilter<"apropos_outils"> | string
    couleur_description?: StringFilter<"apropos_outils"> | string
    ordre?: IntFilter<"apropos_outils"> | number
    afficher?: BoolFilter<"apropos_outils"> | boolean
  }

  export type apropos_outilsOrderByWithRelationInput = {
    id_outil?: SortOrder
    type_outil?: SortOrder
    titre?: SortOrder
    description?: SortOrder
    icone?: SortOrder
    icone_alt?: SortOrder
    icone_rounded?: SortOrder
    lien?: SortOrder
    couleur_fond?: SortOrder
    couleur_titre?: SortOrder
    couleur_description?: SortOrder
    ordre?: SortOrder
    afficher?: SortOrder
    _relevance?: apropos_outilsOrderByRelevanceInput
  }

  export type apropos_outilsWhereUniqueInput = Prisma.AtLeast<{
    id_outil?: number
    AND?: apropos_outilsWhereInput | apropos_outilsWhereInput[]
    OR?: apropos_outilsWhereInput[]
    NOT?: apropos_outilsWhereInput | apropos_outilsWhereInput[]
    type_outil?: StringFilter<"apropos_outils"> | string
    titre?: StringFilter<"apropos_outils"> | string
    description?: StringFilter<"apropos_outils"> | string
    icone?: StringFilter<"apropos_outils"> | string
    icone_alt?: StringFilter<"apropos_outils"> | string
    icone_rounded?: BoolFilter<"apropos_outils"> | boolean
    lien?: StringFilter<"apropos_outils"> | string
    couleur_fond?: StringFilter<"apropos_outils"> | string
    couleur_titre?: StringFilter<"apropos_outils"> | string
    couleur_description?: StringFilter<"apropos_outils"> | string
    ordre?: IntFilter<"apropos_outils"> | number
    afficher?: BoolFilter<"apropos_outils"> | boolean
  }, "id_outil">

  export type apropos_outilsOrderByWithAggregationInput = {
    id_outil?: SortOrder
    type_outil?: SortOrder
    titre?: SortOrder
    description?: SortOrder
    icone?: SortOrder
    icone_alt?: SortOrder
    icone_rounded?: SortOrder
    lien?: SortOrder
    couleur_fond?: SortOrder
    couleur_titre?: SortOrder
    couleur_description?: SortOrder
    ordre?: SortOrder
    afficher?: SortOrder
    _count?: apropos_outilsCountOrderByAggregateInput
    _avg?: apropos_outilsAvgOrderByAggregateInput
    _max?: apropos_outilsMaxOrderByAggregateInput
    _min?: apropos_outilsMinOrderByAggregateInput
    _sum?: apropos_outilsSumOrderByAggregateInput
  }

  export type apropos_outilsScalarWhereWithAggregatesInput = {
    AND?: apropos_outilsScalarWhereWithAggregatesInput | apropos_outilsScalarWhereWithAggregatesInput[]
    OR?: apropos_outilsScalarWhereWithAggregatesInput[]
    NOT?: apropos_outilsScalarWhereWithAggregatesInput | apropos_outilsScalarWhereWithAggregatesInput[]
    id_outil?: IntWithAggregatesFilter<"apropos_outils"> | number
    type_outil?: StringWithAggregatesFilter<"apropos_outils"> | string
    titre?: StringWithAggregatesFilter<"apropos_outils"> | string
    description?: StringWithAggregatesFilter<"apropos_outils"> | string
    icone?: StringWithAggregatesFilter<"apropos_outils"> | string
    icone_alt?: StringWithAggregatesFilter<"apropos_outils"> | string
    icone_rounded?: BoolWithAggregatesFilter<"apropos_outils"> | boolean
    lien?: StringWithAggregatesFilter<"apropos_outils"> | string
    couleur_fond?: StringWithAggregatesFilter<"apropos_outils"> | string
    couleur_titre?: StringWithAggregatesFilter<"apropos_outils"> | string
    couleur_description?: StringWithAggregatesFilter<"apropos_outils"> | string
    ordre?: IntWithAggregatesFilter<"apropos_outils"> | number
    afficher?: BoolWithAggregatesFilter<"apropos_outils"> | boolean
  }

  export type photosWhereInput = {
    AND?: photosWhereInput | photosWhereInput[]
    OR?: photosWhereInput[]
    NOT?: photosWhereInput | photosWhereInput[]
    id_pho?: IntFilter<"photos"> | number
    lien_high?: StringFilter<"photos"> | string
    lien_low?: StringFilter<"photos"> | string
    largeur?: IntFilter<"photos"> | number
    hauteur?: IntFilter<"photos"> | number
    alt?: StringFilter<"photos"> | string
    date?: DateTimeFilter<"photos"> | Date | string
    afficher_carrousel_main?: BoolFilter<"photos"> | boolean
    afficher_carrousel_photos?: BoolFilter<"photos"> | boolean
    afficher?: BoolFilter<"photos"> | boolean
    derniere_modification?: DateTimeFilter<"photos"> | Date | string
    photos_albums_link?: Photos_albums_linkListRelationFilter
    photos_tags_link?: Photos_tags_linkListRelationFilter
    photos_tags_recherche_link?: Photos_tags_recherche_linkListRelationFilter
  }

  export type photosOrderByWithRelationInput = {
    id_pho?: SortOrder
    lien_high?: SortOrder
    lien_low?: SortOrder
    largeur?: SortOrder
    hauteur?: SortOrder
    alt?: SortOrder
    date?: SortOrder
    afficher_carrousel_main?: SortOrder
    afficher_carrousel_photos?: SortOrder
    afficher?: SortOrder
    derniere_modification?: SortOrder
    photos_albums_link?: photos_albums_linkOrderByRelationAggregateInput
    photos_tags_link?: photos_tags_linkOrderByRelationAggregateInput
    photos_tags_recherche_link?: photos_tags_recherche_linkOrderByRelationAggregateInput
    _relevance?: photosOrderByRelevanceInput
  }

  export type photosWhereUniqueInput = Prisma.AtLeast<{
    id_pho?: number
    AND?: photosWhereInput | photosWhereInput[]
    OR?: photosWhereInput[]
    NOT?: photosWhereInput | photosWhereInput[]
    lien_high?: StringFilter<"photos"> | string
    lien_low?: StringFilter<"photos"> | string
    largeur?: IntFilter<"photos"> | number
    hauteur?: IntFilter<"photos"> | number
    alt?: StringFilter<"photos"> | string
    date?: DateTimeFilter<"photos"> | Date | string
    afficher_carrousel_main?: BoolFilter<"photos"> | boolean
    afficher_carrousel_photos?: BoolFilter<"photos"> | boolean
    afficher?: BoolFilter<"photos"> | boolean
    derniere_modification?: DateTimeFilter<"photos"> | Date | string
    photos_albums_link?: Photos_albums_linkListRelationFilter
    photos_tags_link?: Photos_tags_linkListRelationFilter
    photos_tags_recherche_link?: Photos_tags_recherche_linkListRelationFilter
  }, "id_pho">

  export type photosOrderByWithAggregationInput = {
    id_pho?: SortOrder
    lien_high?: SortOrder
    lien_low?: SortOrder
    largeur?: SortOrder
    hauteur?: SortOrder
    alt?: SortOrder
    date?: SortOrder
    afficher_carrousel_main?: SortOrder
    afficher_carrousel_photos?: SortOrder
    afficher?: SortOrder
    derniere_modification?: SortOrder
    _count?: photosCountOrderByAggregateInput
    _avg?: photosAvgOrderByAggregateInput
    _max?: photosMaxOrderByAggregateInput
    _min?: photosMinOrderByAggregateInput
    _sum?: photosSumOrderByAggregateInput
  }

  export type photosScalarWhereWithAggregatesInput = {
    AND?: photosScalarWhereWithAggregatesInput | photosScalarWhereWithAggregatesInput[]
    OR?: photosScalarWhereWithAggregatesInput[]
    NOT?: photosScalarWhereWithAggregatesInput | photosScalarWhereWithAggregatesInput[]
    id_pho?: IntWithAggregatesFilter<"photos"> | number
    lien_high?: StringWithAggregatesFilter<"photos"> | string
    lien_low?: StringWithAggregatesFilter<"photos"> | string
    largeur?: IntWithAggregatesFilter<"photos"> | number
    hauteur?: IntWithAggregatesFilter<"photos"> | number
    alt?: StringWithAggregatesFilter<"photos"> | string
    date?: DateTimeWithAggregatesFilter<"photos"> | Date | string
    afficher_carrousel_main?: BoolWithAggregatesFilter<"photos"> | boolean
    afficher_carrousel_photos?: BoolWithAggregatesFilter<"photos"> | boolean
    afficher?: BoolWithAggregatesFilter<"photos"> | boolean
    derniere_modification?: DateTimeWithAggregatesFilter<"photos"> | Date | string
  }

  export type photos_albumsWhereInput = {
    AND?: photos_albumsWhereInput | photos_albumsWhereInput[]
    OR?: photos_albumsWhereInput[]
    NOT?: photos_albumsWhereInput | photos_albumsWhereInput[]
    id_alb?: IntFilter<"photos_albums"> | number
    titre?: StringFilter<"photos_albums"> | string
    lien_cover?: StringFilter<"photos_albums"> | string
    date?: DateTimeFilter<"photos_albums"> | Date | string
    afficher?: BoolFilter<"photos_albums"> | boolean
    derniere_modification?: DateTimeFilter<"photos_albums"> | Date | string
    photos_albums_link?: Photos_albums_linkListRelationFilter
    photos_albums_tags_link?: Photos_albums_tags_linkListRelationFilter
  }

  export type photos_albumsOrderByWithRelationInput = {
    id_alb?: SortOrder
    titre?: SortOrder
    lien_cover?: SortOrder
    date?: SortOrder
    afficher?: SortOrder
    derniere_modification?: SortOrder
    photos_albums_link?: photos_albums_linkOrderByRelationAggregateInput
    photos_albums_tags_link?: photos_albums_tags_linkOrderByRelationAggregateInput
    _relevance?: photos_albumsOrderByRelevanceInput
  }

  export type photos_albumsWhereUniqueInput = Prisma.AtLeast<{
    id_alb?: number
    AND?: photos_albumsWhereInput | photos_albumsWhereInput[]
    OR?: photos_albumsWhereInput[]
    NOT?: photos_albumsWhereInput | photos_albumsWhereInput[]
    titre?: StringFilter<"photos_albums"> | string
    lien_cover?: StringFilter<"photos_albums"> | string
    date?: DateTimeFilter<"photos_albums"> | Date | string
    afficher?: BoolFilter<"photos_albums"> | boolean
    derniere_modification?: DateTimeFilter<"photos_albums"> | Date | string
    photos_albums_link?: Photos_albums_linkListRelationFilter
    photos_albums_tags_link?: Photos_albums_tags_linkListRelationFilter
  }, "id_alb">

  export type photos_albumsOrderByWithAggregationInput = {
    id_alb?: SortOrder
    titre?: SortOrder
    lien_cover?: SortOrder
    date?: SortOrder
    afficher?: SortOrder
    derniere_modification?: SortOrder
    _count?: photos_albumsCountOrderByAggregateInput
    _avg?: photos_albumsAvgOrderByAggregateInput
    _max?: photos_albumsMaxOrderByAggregateInput
    _min?: photos_albumsMinOrderByAggregateInput
    _sum?: photos_albumsSumOrderByAggregateInput
  }

  export type photos_albumsScalarWhereWithAggregatesInput = {
    AND?: photos_albumsScalarWhereWithAggregatesInput | photos_albumsScalarWhereWithAggregatesInput[]
    OR?: photos_albumsScalarWhereWithAggregatesInput[]
    NOT?: photos_albumsScalarWhereWithAggregatesInput | photos_albumsScalarWhereWithAggregatesInput[]
    id_alb?: IntWithAggregatesFilter<"photos_albums"> | number
    titre?: StringWithAggregatesFilter<"photos_albums"> | string
    lien_cover?: StringWithAggregatesFilter<"photos_albums"> | string
    date?: DateTimeWithAggregatesFilter<"photos_albums"> | Date | string
    afficher?: BoolWithAggregatesFilter<"photos_albums"> | boolean
    derniere_modification?: DateTimeWithAggregatesFilter<"photos_albums"> | Date | string
  }

  export type photos_albums_linkWhereInput = {
    AND?: photos_albums_linkWhereInput | photos_albums_linkWhereInput[]
    OR?: photos_albums_linkWhereInput[]
    NOT?: photos_albums_linkWhereInput | photos_albums_linkWhereInput[]
    id_pho?: IntFilter<"photos_albums_link"> | number
    id_alb?: IntFilter<"photos_albums_link"> | number
    position?: IntNullableFilter<"photos_albums_link"> | number | null
    photos?: XOR<PhotosScalarRelationFilter, photosWhereInput>
    photos_albums?: XOR<Photos_albumsScalarRelationFilter, photos_albumsWhereInput>
  }

  export type photos_albums_linkOrderByWithRelationInput = {
    id_pho?: SortOrder
    id_alb?: SortOrder
    position?: SortOrderInput | SortOrder
    photos?: photosOrderByWithRelationInput
    photos_albums?: photos_albumsOrderByWithRelationInput
  }

  export type photos_albums_linkWhereUniqueInput = Prisma.AtLeast<{
    id_pho_id_alb?: photos_albums_linkId_phoId_albCompoundUniqueInput
    AND?: photos_albums_linkWhereInput | photos_albums_linkWhereInput[]
    OR?: photos_albums_linkWhereInput[]
    NOT?: photos_albums_linkWhereInput | photos_albums_linkWhereInput[]
    id_pho?: IntFilter<"photos_albums_link"> | number
    id_alb?: IntFilter<"photos_albums_link"> | number
    position?: IntNullableFilter<"photos_albums_link"> | number | null
    photos?: XOR<PhotosScalarRelationFilter, photosWhereInput>
    photos_albums?: XOR<Photos_albumsScalarRelationFilter, photos_albumsWhereInput>
  }, "id_pho_id_alb">

  export type photos_albums_linkOrderByWithAggregationInput = {
    id_pho?: SortOrder
    id_alb?: SortOrder
    position?: SortOrderInput | SortOrder
    _count?: photos_albums_linkCountOrderByAggregateInput
    _avg?: photos_albums_linkAvgOrderByAggregateInput
    _max?: photos_albums_linkMaxOrderByAggregateInput
    _min?: photos_albums_linkMinOrderByAggregateInput
    _sum?: photos_albums_linkSumOrderByAggregateInput
  }

  export type photos_albums_linkScalarWhereWithAggregatesInput = {
    AND?: photos_albums_linkScalarWhereWithAggregatesInput | photos_albums_linkScalarWhereWithAggregatesInput[]
    OR?: photos_albums_linkScalarWhereWithAggregatesInput[]
    NOT?: photos_albums_linkScalarWhereWithAggregatesInput | photos_albums_linkScalarWhereWithAggregatesInput[]
    id_pho?: IntWithAggregatesFilter<"photos_albums_link"> | number
    id_alb?: IntWithAggregatesFilter<"photos_albums_link"> | number
    position?: IntNullableWithAggregatesFilter<"photos_albums_link"> | number | null
  }

  export type photos_albums_tags_linkWhereInput = {
    AND?: photos_albums_tags_linkWhereInput | photos_albums_tags_linkWhereInput[]
    OR?: photos_albums_tags_linkWhereInput[]
    NOT?: photos_albums_tags_linkWhereInput | photos_albums_tags_linkWhereInput[]
    id_alb?: IntFilter<"photos_albums_tags_link"> | number
    id_tags?: IntFilter<"photos_albums_tags_link"> | number
    photos_albums?: XOR<Photos_albumsScalarRelationFilter, photos_albumsWhereInput>
    photos_tags?: XOR<Photos_tagsScalarRelationFilter, photos_tagsWhereInput>
  }

  export type photos_albums_tags_linkOrderByWithRelationInput = {
    id_alb?: SortOrder
    id_tags?: SortOrder
    photos_albums?: photos_albumsOrderByWithRelationInput
    photos_tags?: photos_tagsOrderByWithRelationInput
  }

  export type photos_albums_tags_linkWhereUniqueInput = Prisma.AtLeast<{
    id_alb_id_tags?: photos_albums_tags_linkId_albId_tagsCompoundUniqueInput
    AND?: photos_albums_tags_linkWhereInput | photos_albums_tags_linkWhereInput[]
    OR?: photos_albums_tags_linkWhereInput[]
    NOT?: photos_albums_tags_linkWhereInput | photos_albums_tags_linkWhereInput[]
    id_alb?: IntFilter<"photos_albums_tags_link"> | number
    id_tags?: IntFilter<"photos_albums_tags_link"> | number
    photos_albums?: XOR<Photos_albumsScalarRelationFilter, photos_albumsWhereInput>
    photos_tags?: XOR<Photos_tagsScalarRelationFilter, photos_tagsWhereInput>
  }, "id_alb_id_tags">

  export type photos_albums_tags_linkOrderByWithAggregationInput = {
    id_alb?: SortOrder
    id_tags?: SortOrder
    _count?: photos_albums_tags_linkCountOrderByAggregateInput
    _avg?: photos_albums_tags_linkAvgOrderByAggregateInput
    _max?: photos_albums_tags_linkMaxOrderByAggregateInput
    _min?: photos_albums_tags_linkMinOrderByAggregateInput
    _sum?: photos_albums_tags_linkSumOrderByAggregateInput
  }

  export type photos_albums_tags_linkScalarWhereWithAggregatesInput = {
    AND?: photos_albums_tags_linkScalarWhereWithAggregatesInput | photos_albums_tags_linkScalarWhereWithAggregatesInput[]
    OR?: photos_albums_tags_linkScalarWhereWithAggregatesInput[]
    NOT?: photos_albums_tags_linkScalarWhereWithAggregatesInput | photos_albums_tags_linkScalarWhereWithAggregatesInput[]
    id_alb?: IntWithAggregatesFilter<"photos_albums_tags_link"> | number
    id_tags?: IntWithAggregatesFilter<"photos_albums_tags_link"> | number
  }

  export type photos_tagsWhereInput = {
    AND?: photos_tagsWhereInput | photos_tagsWhereInput[]
    OR?: photos_tagsWhereInput[]
    NOT?: photos_tagsWhereInput | photos_tagsWhereInput[]
    id_tags?: IntFilter<"photos_tags"> | number
    titre?: StringFilter<"photos_tags"> | string
    important?: BoolFilter<"photos_tags"> | boolean
    photos_albums_tags_link?: Photos_albums_tags_linkListRelationFilter
    photos_tags_link?: Photos_tags_linkListRelationFilter
  }

  export type photos_tagsOrderByWithRelationInput = {
    id_tags?: SortOrder
    titre?: SortOrder
    important?: SortOrder
    photos_albums_tags_link?: photos_albums_tags_linkOrderByRelationAggregateInput
    photos_tags_link?: photos_tags_linkOrderByRelationAggregateInput
    _relevance?: photos_tagsOrderByRelevanceInput
  }

  export type photos_tagsWhereUniqueInput = Prisma.AtLeast<{
    id_tags?: number
    AND?: photos_tagsWhereInput | photos_tagsWhereInput[]
    OR?: photos_tagsWhereInput[]
    NOT?: photos_tagsWhereInput | photos_tagsWhereInput[]
    titre?: StringFilter<"photos_tags"> | string
    important?: BoolFilter<"photos_tags"> | boolean
    photos_albums_tags_link?: Photos_albums_tags_linkListRelationFilter
    photos_tags_link?: Photos_tags_linkListRelationFilter
  }, "id_tags">

  export type photos_tagsOrderByWithAggregationInput = {
    id_tags?: SortOrder
    titre?: SortOrder
    important?: SortOrder
    _count?: photos_tagsCountOrderByAggregateInput
    _avg?: photos_tagsAvgOrderByAggregateInput
    _max?: photos_tagsMaxOrderByAggregateInput
    _min?: photos_tagsMinOrderByAggregateInput
    _sum?: photos_tagsSumOrderByAggregateInput
  }

  export type photos_tagsScalarWhereWithAggregatesInput = {
    AND?: photos_tagsScalarWhereWithAggregatesInput | photos_tagsScalarWhereWithAggregatesInput[]
    OR?: photos_tagsScalarWhereWithAggregatesInput[]
    NOT?: photos_tagsScalarWhereWithAggregatesInput | photos_tagsScalarWhereWithAggregatesInput[]
    id_tags?: IntWithAggregatesFilter<"photos_tags"> | number
    titre?: StringWithAggregatesFilter<"photos_tags"> | string
    important?: BoolWithAggregatesFilter<"photos_tags"> | boolean
  }

  export type photos_tags_linkWhereInput = {
    AND?: photos_tags_linkWhereInput | photos_tags_linkWhereInput[]
    OR?: photos_tags_linkWhereInput[]
    NOT?: photos_tags_linkWhereInput | photos_tags_linkWhereInput[]
    id_pho?: IntFilter<"photos_tags_link"> | number
    id_tags?: IntFilter<"photos_tags_link"> | number
    photos?: XOR<PhotosScalarRelationFilter, photosWhereInput>
    photos_tags?: XOR<Photos_tagsScalarRelationFilter, photos_tagsWhereInput>
  }

  export type photos_tags_linkOrderByWithRelationInput = {
    id_pho?: SortOrder
    id_tags?: SortOrder
    photos?: photosOrderByWithRelationInput
    photos_tags?: photos_tagsOrderByWithRelationInput
  }

  export type photos_tags_linkWhereUniqueInput = Prisma.AtLeast<{
    id_pho_id_tags?: photos_tags_linkId_phoId_tagsCompoundUniqueInput
    AND?: photos_tags_linkWhereInput | photos_tags_linkWhereInput[]
    OR?: photos_tags_linkWhereInput[]
    NOT?: photos_tags_linkWhereInput | photos_tags_linkWhereInput[]
    id_pho?: IntFilter<"photos_tags_link"> | number
    id_tags?: IntFilter<"photos_tags_link"> | number
    photos?: XOR<PhotosScalarRelationFilter, photosWhereInput>
    photos_tags?: XOR<Photos_tagsScalarRelationFilter, photos_tagsWhereInput>
  }, "id_pho_id_tags">

  export type photos_tags_linkOrderByWithAggregationInput = {
    id_pho?: SortOrder
    id_tags?: SortOrder
    _count?: photos_tags_linkCountOrderByAggregateInput
    _avg?: photos_tags_linkAvgOrderByAggregateInput
    _max?: photos_tags_linkMaxOrderByAggregateInput
    _min?: photos_tags_linkMinOrderByAggregateInput
    _sum?: photos_tags_linkSumOrderByAggregateInput
  }

  export type photos_tags_linkScalarWhereWithAggregatesInput = {
    AND?: photos_tags_linkScalarWhereWithAggregatesInput | photos_tags_linkScalarWhereWithAggregatesInput[]
    OR?: photos_tags_linkScalarWhereWithAggregatesInput[]
    NOT?: photos_tags_linkScalarWhereWithAggregatesInput | photos_tags_linkScalarWhereWithAggregatesInput[]
    id_pho?: IntWithAggregatesFilter<"photos_tags_link"> | number
    id_tags?: IntWithAggregatesFilter<"photos_tags_link"> | number
  }

  export type photos_tags_rechercheWhereInput = {
    AND?: photos_tags_rechercheWhereInput | photos_tags_rechercheWhereInput[]
    OR?: photos_tags_rechercheWhereInput[]
    NOT?: photos_tags_rechercheWhereInput | photos_tags_rechercheWhereInput[]
    id_tags?: IntFilter<"photos_tags_recherche"> | number
    titre?: StringFilter<"photos_tags_recherche"> | string
    important?: BoolFilter<"photos_tags_recherche"> | boolean
    photos_tags_recherche_link?: Photos_tags_recherche_linkListRelationFilter
  }

  export type photos_tags_rechercheOrderByWithRelationInput = {
    id_tags?: SortOrder
    titre?: SortOrder
    important?: SortOrder
    photos_tags_recherche_link?: photos_tags_recherche_linkOrderByRelationAggregateInput
    _relevance?: photos_tags_rechercheOrderByRelevanceInput
  }

  export type photos_tags_rechercheWhereUniqueInput = Prisma.AtLeast<{
    id_tags?: number
    AND?: photos_tags_rechercheWhereInput | photos_tags_rechercheWhereInput[]
    OR?: photos_tags_rechercheWhereInput[]
    NOT?: photos_tags_rechercheWhereInput | photos_tags_rechercheWhereInput[]
    titre?: StringFilter<"photos_tags_recherche"> | string
    important?: BoolFilter<"photos_tags_recherche"> | boolean
    photos_tags_recherche_link?: Photos_tags_recherche_linkListRelationFilter
  }, "id_tags">

  export type photos_tags_rechercheOrderByWithAggregationInput = {
    id_tags?: SortOrder
    titre?: SortOrder
    important?: SortOrder
    _count?: photos_tags_rechercheCountOrderByAggregateInput
    _avg?: photos_tags_rechercheAvgOrderByAggregateInput
    _max?: photos_tags_rechercheMaxOrderByAggregateInput
    _min?: photos_tags_rechercheMinOrderByAggregateInput
    _sum?: photos_tags_rechercheSumOrderByAggregateInput
  }

  export type photos_tags_rechercheScalarWhereWithAggregatesInput = {
    AND?: photos_tags_rechercheScalarWhereWithAggregatesInput | photos_tags_rechercheScalarWhereWithAggregatesInput[]
    OR?: photos_tags_rechercheScalarWhereWithAggregatesInput[]
    NOT?: photos_tags_rechercheScalarWhereWithAggregatesInput | photos_tags_rechercheScalarWhereWithAggregatesInput[]
    id_tags?: IntWithAggregatesFilter<"photos_tags_recherche"> | number
    titre?: StringWithAggregatesFilter<"photos_tags_recherche"> | string
    important?: BoolWithAggregatesFilter<"photos_tags_recherche"> | boolean
  }

  export type photos_tags_recherche_linkWhereInput = {
    AND?: photos_tags_recherche_linkWhereInput | photos_tags_recherche_linkWhereInput[]
    OR?: photos_tags_recherche_linkWhereInput[]
    NOT?: photos_tags_recherche_linkWhereInput | photos_tags_recherche_linkWhereInput[]
    id_pho?: IntFilter<"photos_tags_recherche_link"> | number
    id_tags?: IntFilter<"photos_tags_recherche_link"> | number
    photos?: XOR<PhotosScalarRelationFilter, photosWhereInput>
    photos_tags_recherche?: XOR<Photos_tags_rechercheScalarRelationFilter, photos_tags_rechercheWhereInput>
  }

  export type photos_tags_recherche_linkOrderByWithRelationInput = {
    id_pho?: SortOrder
    id_tags?: SortOrder
    photos?: photosOrderByWithRelationInput
    photos_tags_recherche?: photos_tags_rechercheOrderByWithRelationInput
  }

  export type photos_tags_recherche_linkWhereUniqueInput = Prisma.AtLeast<{
    id_pho_id_tags?: photos_tags_recherche_linkId_phoId_tagsCompoundUniqueInput
    AND?: photos_tags_recherche_linkWhereInput | photos_tags_recherche_linkWhereInput[]
    OR?: photos_tags_recherche_linkWhereInput[]
    NOT?: photos_tags_recherche_linkWhereInput | photos_tags_recherche_linkWhereInput[]
    id_pho?: IntFilter<"photos_tags_recherche_link"> | number
    id_tags?: IntFilter<"photos_tags_recherche_link"> | number
    photos?: XOR<PhotosScalarRelationFilter, photosWhereInput>
    photos_tags_recherche?: XOR<Photos_tags_rechercheScalarRelationFilter, photos_tags_rechercheWhereInput>
  }, "id_pho_id_tags">

  export type photos_tags_recherche_linkOrderByWithAggregationInput = {
    id_pho?: SortOrder
    id_tags?: SortOrder
    _count?: photos_tags_recherche_linkCountOrderByAggregateInput
    _avg?: photos_tags_recherche_linkAvgOrderByAggregateInput
    _max?: photos_tags_recherche_linkMaxOrderByAggregateInput
    _min?: photos_tags_recherche_linkMinOrderByAggregateInput
    _sum?: photos_tags_recherche_linkSumOrderByAggregateInput
  }

  export type photos_tags_recherche_linkScalarWhereWithAggregatesInput = {
    AND?: photos_tags_recherche_linkScalarWhereWithAggregatesInput | photos_tags_recherche_linkScalarWhereWithAggregatesInput[]
    OR?: photos_tags_recherche_linkScalarWhereWithAggregatesInput[]
    NOT?: photos_tags_recherche_linkScalarWhereWithAggregatesInput | photos_tags_recherche_linkScalarWhereWithAggregatesInput[]
    id_pho?: IntWithAggregatesFilter<"photos_tags_recherche_link"> | number
    id_tags?: IntWithAggregatesFilter<"photos_tags_recherche_link"> | number
  }

  export type sessionWhereInput = {
    AND?: sessionWhereInput | sessionWhereInput[]
    OR?: sessionWhereInput[]
    NOT?: sessionWhereInput | sessionWhereInput[]
    id?: StringFilter<"session"> | string
    expiresAt?: DateTimeFilter<"session"> | Date | string
    token?: StringFilter<"session"> | string
    createdAt?: DateTimeFilter<"session"> | Date | string
    updatedAt?: DateTimeFilter<"session"> | Date | string
    ipAddress?: StringNullableFilter<"session"> | string | null
    userAgent?: StringNullableFilter<"session"> | string | null
    userId?: StringFilter<"session"> | string
  }

  export type sessionOrderByWithRelationInput = {
    id?: SortOrder
    expiresAt?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    userId?: SortOrder
    _relevance?: sessionOrderByRelevanceInput
  }

  export type sessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    AND?: sessionWhereInput | sessionWhereInput[]
    OR?: sessionWhereInput[]
    NOT?: sessionWhereInput | sessionWhereInput[]
    expiresAt?: DateTimeFilter<"session"> | Date | string
    createdAt?: DateTimeFilter<"session"> | Date | string
    updatedAt?: DateTimeFilter<"session"> | Date | string
    ipAddress?: StringNullableFilter<"session"> | string | null
    userAgent?: StringNullableFilter<"session"> | string | null
    userId?: StringFilter<"session"> | string
  }, "id" | "token">

  export type sessionOrderByWithAggregationInput = {
    id?: SortOrder
    expiresAt?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    userId?: SortOrder
    _count?: sessionCountOrderByAggregateInput
    _max?: sessionMaxOrderByAggregateInput
    _min?: sessionMinOrderByAggregateInput
  }

  export type sessionScalarWhereWithAggregatesInput = {
    AND?: sessionScalarWhereWithAggregatesInput | sessionScalarWhereWithAggregatesInput[]
    OR?: sessionScalarWhereWithAggregatesInput[]
    NOT?: sessionScalarWhereWithAggregatesInput | sessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"session"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"session"> | Date | string
    token?: StringWithAggregatesFilter<"session"> | string
    createdAt?: DateTimeWithAggregatesFilter<"session"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"session"> | Date | string
    ipAddress?: StringNullableWithAggregatesFilter<"session"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"session"> | string | null
    userId?: StringWithAggregatesFilter<"session"> | string
  }

  export type userWhereInput = {
    AND?: userWhereInput | userWhereInput[]
    OR?: userWhereInput[]
    NOT?: userWhereInput | userWhereInput[]
    id?: StringFilter<"user"> | string
    name?: StringFilter<"user"> | string
    email?: StringFilter<"user"> | string
    emailVerified?: BoolFilter<"user"> | boolean
    image?: StringNullableFilter<"user"> | string | null
    createdAt?: DateTimeFilter<"user"> | Date | string
    updatedAt?: DateTimeFilter<"user"> | Date | string
  }

  export type userOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _relevance?: userOrderByRelevanceInput
  }

  export type userWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: userWhereInput | userWhereInput[]
    OR?: userWhereInput[]
    NOT?: userWhereInput | userWhereInput[]
    name?: StringFilter<"user"> | string
    emailVerified?: BoolFilter<"user"> | boolean
    image?: StringNullableFilter<"user"> | string | null
    createdAt?: DateTimeFilter<"user"> | Date | string
    updatedAt?: DateTimeFilter<"user"> | Date | string
  }, "id" | "email">

  export type userOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: userCountOrderByAggregateInput
    _max?: userMaxOrderByAggregateInput
    _min?: userMinOrderByAggregateInput
  }

  export type userScalarWhereWithAggregatesInput = {
    AND?: userScalarWhereWithAggregatesInput | userScalarWhereWithAggregatesInput[]
    OR?: userScalarWhereWithAggregatesInput[]
    NOT?: userScalarWhereWithAggregatesInput | userScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"user"> | string
    name?: StringWithAggregatesFilter<"user"> | string
    email?: StringWithAggregatesFilter<"user"> | string
    emailVerified?: BoolWithAggregatesFilter<"user"> | boolean
    image?: StringNullableWithAggregatesFilter<"user"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"user"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"user"> | Date | string
  }

  export type utilisateursWhereInput = {
    AND?: utilisateursWhereInput | utilisateursWhereInput[]
    OR?: utilisateursWhereInput[]
    NOT?: utilisateursWhereInput | utilisateursWhereInput[]
    id_user?: IntFilter<"utilisateurs"> | number
    img?: StringFilter<"utilisateurs"> | string
    email?: StringNullableFilter<"utilisateurs"> | string | null
    username?: StringFilter<"utilisateurs"> | string
    password?: StringFilter<"utilisateurs"> | string
    role?: StringFilter<"utilisateurs"> | string
  }

  export type utilisateursOrderByWithRelationInput = {
    id_user?: SortOrder
    img?: SortOrder
    email?: SortOrderInput | SortOrder
    username?: SortOrder
    password?: SortOrder
    role?: SortOrder
    _relevance?: utilisateursOrderByRelevanceInput
  }

  export type utilisateursWhereUniqueInput = Prisma.AtLeast<{
    id_user?: number
    AND?: utilisateursWhereInput | utilisateursWhereInput[]
    OR?: utilisateursWhereInput[]
    NOT?: utilisateursWhereInput | utilisateursWhereInput[]
    img?: StringFilter<"utilisateurs"> | string
    email?: StringNullableFilter<"utilisateurs"> | string | null
    username?: StringFilter<"utilisateurs"> | string
    password?: StringFilter<"utilisateurs"> | string
    role?: StringFilter<"utilisateurs"> | string
  }, "id_user">

  export type utilisateursOrderByWithAggregationInput = {
    id_user?: SortOrder
    img?: SortOrder
    email?: SortOrderInput | SortOrder
    username?: SortOrder
    password?: SortOrder
    role?: SortOrder
    _count?: utilisateursCountOrderByAggregateInput
    _avg?: utilisateursAvgOrderByAggregateInput
    _max?: utilisateursMaxOrderByAggregateInput
    _min?: utilisateursMinOrderByAggregateInput
    _sum?: utilisateursSumOrderByAggregateInput
  }

  export type utilisateursScalarWhereWithAggregatesInput = {
    AND?: utilisateursScalarWhereWithAggregatesInput | utilisateursScalarWhereWithAggregatesInput[]
    OR?: utilisateursScalarWhereWithAggregatesInput[]
    NOT?: utilisateursScalarWhereWithAggregatesInput | utilisateursScalarWhereWithAggregatesInput[]
    id_user?: IntWithAggregatesFilter<"utilisateurs"> | number
    img?: StringWithAggregatesFilter<"utilisateurs"> | string
    email?: StringNullableWithAggregatesFilter<"utilisateurs"> | string | null
    username?: StringWithAggregatesFilter<"utilisateurs"> | string
    password?: StringWithAggregatesFilter<"utilisateurs"> | string
    role?: StringWithAggregatesFilter<"utilisateurs"> | string
  }

  export type verificationWhereInput = {
    AND?: verificationWhereInput | verificationWhereInput[]
    OR?: verificationWhereInput[]
    NOT?: verificationWhereInput | verificationWhereInput[]
    id?: StringFilter<"verification"> | string
    identifier?: StringFilter<"verification"> | string
    value?: StringFilter<"verification"> | string
    expiresAt?: DateTimeFilter<"verification"> | Date | string
    createdAt?: DateTimeNullableFilter<"verification"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"verification"> | Date | string | null
  }

  export type verificationOrderByWithRelationInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _relevance?: verificationOrderByRelevanceInput
  }

  export type verificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: verificationWhereInput | verificationWhereInput[]
    OR?: verificationWhereInput[]
    NOT?: verificationWhereInput | verificationWhereInput[]
    identifier?: StringFilter<"verification"> | string
    value?: StringFilter<"verification"> | string
    expiresAt?: DateTimeFilter<"verification"> | Date | string
    createdAt?: DateTimeNullableFilter<"verification"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"verification"> | Date | string | null
  }, "id">

  export type verificationOrderByWithAggregationInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: verificationCountOrderByAggregateInput
    _max?: verificationMaxOrderByAggregateInput
    _min?: verificationMinOrderByAggregateInput
  }

  export type verificationScalarWhereWithAggregatesInput = {
    AND?: verificationScalarWhereWithAggregatesInput | verificationScalarWhereWithAggregatesInput[]
    OR?: verificationScalarWhereWithAggregatesInput[]
    NOT?: verificationScalarWhereWithAggregatesInput | verificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"verification"> | string
    identifier?: StringWithAggregatesFilter<"verification"> | string
    value?: StringWithAggregatesFilter<"verification"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"verification"> | Date | string
    createdAt?: DateTimeNullableWithAggregatesFilter<"verification"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"verification"> | Date | string | null
  }

  export type videosWhereInput = {
    AND?: videosWhereInput | videosWhereInput[]
    OR?: videosWhereInput[]
    NOT?: videosWhereInput | videosWhereInput[]
    id_vid?: IntFilter<"videos"> | number
    titre?: StringFilter<"videos"> | string
    lien?: StringFilter<"videos"> | string
    date?: DateTimeFilter<"videos"> | Date | string
    afficher_carrousel_main?: BoolFilter<"videos"> | boolean
    afficher_section_videos?: BoolFilter<"videos"> | boolean
    tag_section_videos?: IntNullableFilter<"videos"> | number | null
    afficher?: BoolFilter<"videos"> | boolean
    derniere_modification?: DateTimeFilter<"videos"> | Date | string
    videos_tags_link?: Videos_tags_linkListRelationFilter
  }

  export type videosOrderByWithRelationInput = {
    id_vid?: SortOrder
    titre?: SortOrder
    lien?: SortOrder
    date?: SortOrder
    afficher_carrousel_main?: SortOrder
    afficher_section_videos?: SortOrder
    tag_section_videos?: SortOrderInput | SortOrder
    afficher?: SortOrder
    derniere_modification?: SortOrder
    videos_tags_link?: videos_tags_linkOrderByRelationAggregateInput
    _relevance?: videosOrderByRelevanceInput
  }

  export type videosWhereUniqueInput = Prisma.AtLeast<{
    id_vid?: number
    AND?: videosWhereInput | videosWhereInput[]
    OR?: videosWhereInput[]
    NOT?: videosWhereInput | videosWhereInput[]
    titre?: StringFilter<"videos"> | string
    lien?: StringFilter<"videos"> | string
    date?: DateTimeFilter<"videos"> | Date | string
    afficher_carrousel_main?: BoolFilter<"videos"> | boolean
    afficher_section_videos?: BoolFilter<"videos"> | boolean
    tag_section_videos?: IntNullableFilter<"videos"> | number | null
    afficher?: BoolFilter<"videos"> | boolean
    derniere_modification?: DateTimeFilter<"videos"> | Date | string
    videos_tags_link?: Videos_tags_linkListRelationFilter
  }, "id_vid">

  export type videosOrderByWithAggregationInput = {
    id_vid?: SortOrder
    titre?: SortOrder
    lien?: SortOrder
    date?: SortOrder
    afficher_carrousel_main?: SortOrder
    afficher_section_videos?: SortOrder
    tag_section_videos?: SortOrderInput | SortOrder
    afficher?: SortOrder
    derniere_modification?: SortOrder
    _count?: videosCountOrderByAggregateInput
    _avg?: videosAvgOrderByAggregateInput
    _max?: videosMaxOrderByAggregateInput
    _min?: videosMinOrderByAggregateInput
    _sum?: videosSumOrderByAggregateInput
  }

  export type videosScalarWhereWithAggregatesInput = {
    AND?: videosScalarWhereWithAggregatesInput | videosScalarWhereWithAggregatesInput[]
    OR?: videosScalarWhereWithAggregatesInput[]
    NOT?: videosScalarWhereWithAggregatesInput | videosScalarWhereWithAggregatesInput[]
    id_vid?: IntWithAggregatesFilter<"videos"> | number
    titre?: StringWithAggregatesFilter<"videos"> | string
    lien?: StringWithAggregatesFilter<"videos"> | string
    date?: DateTimeWithAggregatesFilter<"videos"> | Date | string
    afficher_carrousel_main?: BoolWithAggregatesFilter<"videos"> | boolean
    afficher_section_videos?: BoolWithAggregatesFilter<"videos"> | boolean
    tag_section_videos?: IntNullableWithAggregatesFilter<"videos"> | number | null
    afficher?: BoolWithAggregatesFilter<"videos"> | boolean
    derniere_modification?: DateTimeWithAggregatesFilter<"videos"> | Date | string
  }

  export type videos_tagsWhereInput = {
    AND?: videos_tagsWhereInput | videos_tagsWhereInput[]
    OR?: videos_tagsWhereInput[]
    NOT?: videos_tagsWhereInput | videos_tagsWhereInput[]
    id_tags?: IntFilter<"videos_tags"> | number
    titre?: StringFilter<"videos_tags"> | string
    important?: BoolFilter<"videos_tags"> | boolean
    videos_tags_link?: Videos_tags_linkListRelationFilter
  }

  export type videos_tagsOrderByWithRelationInput = {
    id_tags?: SortOrder
    titre?: SortOrder
    important?: SortOrder
    videos_tags_link?: videos_tags_linkOrderByRelationAggregateInput
    _relevance?: videos_tagsOrderByRelevanceInput
  }

  export type videos_tagsWhereUniqueInput = Prisma.AtLeast<{
    id_tags?: number
    AND?: videos_tagsWhereInput | videos_tagsWhereInput[]
    OR?: videos_tagsWhereInput[]
    NOT?: videos_tagsWhereInput | videos_tagsWhereInput[]
    titre?: StringFilter<"videos_tags"> | string
    important?: BoolFilter<"videos_tags"> | boolean
    videos_tags_link?: Videos_tags_linkListRelationFilter
  }, "id_tags">

  export type videos_tagsOrderByWithAggregationInput = {
    id_tags?: SortOrder
    titre?: SortOrder
    important?: SortOrder
    _count?: videos_tagsCountOrderByAggregateInput
    _avg?: videos_tagsAvgOrderByAggregateInput
    _max?: videos_tagsMaxOrderByAggregateInput
    _min?: videos_tagsMinOrderByAggregateInput
    _sum?: videos_tagsSumOrderByAggregateInput
  }

  export type videos_tagsScalarWhereWithAggregatesInput = {
    AND?: videos_tagsScalarWhereWithAggregatesInput | videos_tagsScalarWhereWithAggregatesInput[]
    OR?: videos_tagsScalarWhereWithAggregatesInput[]
    NOT?: videos_tagsScalarWhereWithAggregatesInput | videos_tagsScalarWhereWithAggregatesInput[]
    id_tags?: IntWithAggregatesFilter<"videos_tags"> | number
    titre?: StringWithAggregatesFilter<"videos_tags"> | string
    important?: BoolWithAggregatesFilter<"videos_tags"> | boolean
  }

  export type videos_tags_linkWhereInput = {
    AND?: videos_tags_linkWhereInput | videos_tags_linkWhereInput[]
    OR?: videos_tags_linkWhereInput[]
    NOT?: videos_tags_linkWhereInput | videos_tags_linkWhereInput[]
    id_vid?: IntFilter<"videos_tags_link"> | number
    id_tags?: IntFilter<"videos_tags_link"> | number
    videos?: XOR<VideosScalarRelationFilter, videosWhereInput>
    videos_tags?: XOR<Videos_tagsScalarRelationFilter, videos_tagsWhereInput>
  }

  export type videos_tags_linkOrderByWithRelationInput = {
    id_vid?: SortOrder
    id_tags?: SortOrder
    videos?: videosOrderByWithRelationInput
    videos_tags?: videos_tagsOrderByWithRelationInput
  }

  export type videos_tags_linkWhereUniqueInput = Prisma.AtLeast<{
    id_vid_id_tags?: videos_tags_linkId_vidId_tagsCompoundUniqueInput
    AND?: videos_tags_linkWhereInput | videos_tags_linkWhereInput[]
    OR?: videos_tags_linkWhereInput[]
    NOT?: videos_tags_linkWhereInput | videos_tags_linkWhereInput[]
    id_vid?: IntFilter<"videos_tags_link"> | number
    id_tags?: IntFilter<"videos_tags_link"> | number
    videos?: XOR<VideosScalarRelationFilter, videosWhereInput>
    videos_tags?: XOR<Videos_tagsScalarRelationFilter, videos_tagsWhereInput>
  }, "id_vid_id_tags">

  export type videos_tags_linkOrderByWithAggregationInput = {
    id_vid?: SortOrder
    id_tags?: SortOrder
    _count?: videos_tags_linkCountOrderByAggregateInput
    _avg?: videos_tags_linkAvgOrderByAggregateInput
    _max?: videos_tags_linkMaxOrderByAggregateInput
    _min?: videos_tags_linkMinOrderByAggregateInput
    _sum?: videos_tags_linkSumOrderByAggregateInput
  }

  export type videos_tags_linkScalarWhereWithAggregatesInput = {
    AND?: videos_tags_linkScalarWhereWithAggregatesInput | videos_tags_linkScalarWhereWithAggregatesInput[]
    OR?: videos_tags_linkScalarWhereWithAggregatesInput[]
    NOT?: videos_tags_linkScalarWhereWithAggregatesInput | videos_tags_linkScalarWhereWithAggregatesInput[]
    id_vid?: IntWithAggregatesFilter<"videos_tags_link"> | number
    id_tags?: IntWithAggregatesFilter<"videos_tags_link"> | number
  }

  export type accueil_clientsWhereInput = {
    AND?: accueil_clientsWhereInput | accueil_clientsWhereInput[]
    OR?: accueil_clientsWhereInput[]
    NOT?: accueil_clientsWhereInput | accueil_clientsWhereInput[]
    id_client?: IntFilter<"accueil_clients"> | number
    client?: StringFilter<"accueil_clients"> | string
    logo?: StringFilter<"accueil_clients"> | string
    alt_logo?: StringFilter<"accueil_clients"> | string
    lien_client?: StringFilter<"accueil_clients"> | string
    ordre?: IntFilter<"accueil_clients"> | number
    afficher?: BoolFilter<"accueil_clients"> | boolean
  }

  export type accueil_clientsOrderByWithRelationInput = {
    id_client?: SortOrder
    client?: SortOrder
    logo?: SortOrder
    alt_logo?: SortOrder
    lien_client?: SortOrder
    ordre?: SortOrder
    afficher?: SortOrder
    _relevance?: accueil_clientsOrderByRelevanceInput
  }

  export type accueil_clientsWhereUniqueInput = Prisma.AtLeast<{
    id_client?: number
    AND?: accueil_clientsWhereInput | accueil_clientsWhereInput[]
    OR?: accueil_clientsWhereInput[]
    NOT?: accueil_clientsWhereInput | accueil_clientsWhereInput[]
    client?: StringFilter<"accueil_clients"> | string
    logo?: StringFilter<"accueil_clients"> | string
    alt_logo?: StringFilter<"accueil_clients"> | string
    lien_client?: StringFilter<"accueil_clients"> | string
    ordre?: IntFilter<"accueil_clients"> | number
    afficher?: BoolFilter<"accueil_clients"> | boolean
  }, "id_client">

  export type accueil_clientsOrderByWithAggregationInput = {
    id_client?: SortOrder
    client?: SortOrder
    logo?: SortOrder
    alt_logo?: SortOrder
    lien_client?: SortOrder
    ordre?: SortOrder
    afficher?: SortOrder
    _count?: accueil_clientsCountOrderByAggregateInput
    _avg?: accueil_clientsAvgOrderByAggregateInput
    _max?: accueil_clientsMaxOrderByAggregateInput
    _min?: accueil_clientsMinOrderByAggregateInput
    _sum?: accueil_clientsSumOrderByAggregateInput
  }

  export type accueil_clientsScalarWhereWithAggregatesInput = {
    AND?: accueil_clientsScalarWhereWithAggregatesInput | accueil_clientsScalarWhereWithAggregatesInput[]
    OR?: accueil_clientsScalarWhereWithAggregatesInput[]
    NOT?: accueil_clientsScalarWhereWithAggregatesInput | accueil_clientsScalarWhereWithAggregatesInput[]
    id_client?: IntWithAggregatesFilter<"accueil_clients"> | number
    client?: StringWithAggregatesFilter<"accueil_clients"> | string
    logo?: StringWithAggregatesFilter<"accueil_clients"> | string
    alt_logo?: StringWithAggregatesFilter<"accueil_clients"> | string
    lien_client?: StringWithAggregatesFilter<"accueil_clients"> | string
    ordre?: IntWithAggregatesFilter<"accueil_clients"> | number
    afficher?: BoolWithAggregatesFilter<"accueil_clients"> | boolean
  }

  export type accueil_faqWhereInput = {
    AND?: accueil_faqWhereInput | accueil_faqWhereInput[]
    OR?: accueil_faqWhereInput[]
    NOT?: accueil_faqWhereInput | accueil_faqWhereInput[]
    id_faq?: IntFilter<"accueil_faq"> | number
    titre?: StringFilter<"accueil_faq"> | string
    contenu?: StringFilter<"accueil_faq"> | string
    ordre?: IntFilter<"accueil_faq"> | number
    afficher?: BoolFilter<"accueil_faq"> | boolean
  }

  export type accueil_faqOrderByWithRelationInput = {
    id_faq?: SortOrder
    titre?: SortOrder
    contenu?: SortOrder
    ordre?: SortOrder
    afficher?: SortOrder
    _relevance?: accueil_faqOrderByRelevanceInput
  }

  export type accueil_faqWhereUniqueInput = Prisma.AtLeast<{
    id_faq?: number
    AND?: accueil_faqWhereInput | accueil_faqWhereInput[]
    OR?: accueil_faqWhereInput[]
    NOT?: accueil_faqWhereInput | accueil_faqWhereInput[]
    titre?: StringFilter<"accueil_faq"> | string
    contenu?: StringFilter<"accueil_faq"> | string
    ordre?: IntFilter<"accueil_faq"> | number
    afficher?: BoolFilter<"accueil_faq"> | boolean
  }, "id_faq">

  export type accueil_faqOrderByWithAggregationInput = {
    id_faq?: SortOrder
    titre?: SortOrder
    contenu?: SortOrder
    ordre?: SortOrder
    afficher?: SortOrder
    _count?: accueil_faqCountOrderByAggregateInput
    _avg?: accueil_faqAvgOrderByAggregateInput
    _max?: accueil_faqMaxOrderByAggregateInput
    _min?: accueil_faqMinOrderByAggregateInput
    _sum?: accueil_faqSumOrderByAggregateInput
  }

  export type accueil_faqScalarWhereWithAggregatesInput = {
    AND?: accueil_faqScalarWhereWithAggregatesInput | accueil_faqScalarWhereWithAggregatesInput[]
    OR?: accueil_faqScalarWhereWithAggregatesInput[]
    NOT?: accueil_faqScalarWhereWithAggregatesInput | accueil_faqScalarWhereWithAggregatesInput[]
    id_faq?: IntWithAggregatesFilter<"accueil_faq"> | number
    titre?: StringWithAggregatesFilter<"accueil_faq"> | string
    contenu?: StringWithAggregatesFilter<"accueil_faq"> | string
    ordre?: IntWithAggregatesFilter<"accueil_faq"> | number
    afficher?: BoolWithAggregatesFilter<"accueil_faq"> | boolean
  }

  export type accountCreateInput = {
    id: string
    accountId: string
    providerId: string
    userId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    scope?: string | null
    password?: string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type accountUncheckedCreateInput = {
    id: string
    accountId: string
    providerId: string
    userId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    scope?: string | null
    password?: string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type accountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type accountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type accountCreateManyInput = {
    id: string
    accountId: string
    providerId: string
    userId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    scope?: string | null
    password?: string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type accountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type accountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type accueil_generalCreateInput = {
    video_desktop: string
    video_mobile: string
    video_cover: string
    photo: string
    photo_alt: string
    description: string
    localisation: string
  }

  export type accueil_generalUncheckedCreateInput = {
    id_gen?: number
    video_desktop: string
    video_mobile: string
    video_cover: string
    photo: string
    photo_alt: string
    description: string
    localisation: string
  }

  export type accueil_generalUpdateInput = {
    video_desktop?: StringFieldUpdateOperationsInput | string
    video_mobile?: StringFieldUpdateOperationsInput | string
    video_cover?: StringFieldUpdateOperationsInput | string
    photo?: StringFieldUpdateOperationsInput | string
    photo_alt?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    localisation?: StringFieldUpdateOperationsInput | string
  }

  export type accueil_generalUncheckedUpdateInput = {
    id_gen?: IntFieldUpdateOperationsInput | number
    video_desktop?: StringFieldUpdateOperationsInput | string
    video_mobile?: StringFieldUpdateOperationsInput | string
    video_cover?: StringFieldUpdateOperationsInput | string
    photo?: StringFieldUpdateOperationsInput | string
    photo_alt?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    localisation?: StringFieldUpdateOperationsInput | string
  }

  export type accueil_generalCreateManyInput = {
    id_gen?: number
    video_desktop: string
    video_mobile: string
    video_cover: string
    photo: string
    photo_alt: string
    description: string
    localisation: string
  }

  export type accueil_generalUpdateManyMutationInput = {
    video_desktop?: StringFieldUpdateOperationsInput | string
    video_mobile?: StringFieldUpdateOperationsInput | string
    video_cover?: StringFieldUpdateOperationsInput | string
    photo?: StringFieldUpdateOperationsInput | string
    photo_alt?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    localisation?: StringFieldUpdateOperationsInput | string
  }

  export type accueil_generalUncheckedUpdateManyInput = {
    id_gen?: IntFieldUpdateOperationsInput | number
    video_desktop?: StringFieldUpdateOperationsInput | string
    video_mobile?: StringFieldUpdateOperationsInput | string
    video_cover?: StringFieldUpdateOperationsInput | string
    photo?: StringFieldUpdateOperationsInput | string
    photo_alt?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    localisation?: StringFieldUpdateOperationsInput | string
  }

  export type apropos_etudesCreateInput = {
    date_debut: Date | string
    date_fin?: Date | string | null
    titre: string
    nom_ecole: string
    lien_ecole: string
    afficher: boolean
  }

  export type apropos_etudesUncheckedCreateInput = {
    id_etu?: number
    date_debut: Date | string
    date_fin?: Date | string | null
    titre: string
    nom_ecole: string
    lien_ecole: string
    afficher: boolean
  }

  export type apropos_etudesUpdateInput = {
    date_debut?: DateTimeFieldUpdateOperationsInput | Date | string
    date_fin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    titre?: StringFieldUpdateOperationsInput | string
    nom_ecole?: StringFieldUpdateOperationsInput | string
    lien_ecole?: StringFieldUpdateOperationsInput | string
    afficher?: BoolFieldUpdateOperationsInput | boolean
  }

  export type apropos_etudesUncheckedUpdateInput = {
    id_etu?: IntFieldUpdateOperationsInput | number
    date_debut?: DateTimeFieldUpdateOperationsInput | Date | string
    date_fin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    titre?: StringFieldUpdateOperationsInput | string
    nom_ecole?: StringFieldUpdateOperationsInput | string
    lien_ecole?: StringFieldUpdateOperationsInput | string
    afficher?: BoolFieldUpdateOperationsInput | boolean
  }

  export type apropos_etudesCreateManyInput = {
    id_etu?: number
    date_debut: Date | string
    date_fin?: Date | string | null
    titre: string
    nom_ecole: string
    lien_ecole: string
    afficher: boolean
  }

  export type apropos_etudesUpdateManyMutationInput = {
    date_debut?: DateTimeFieldUpdateOperationsInput | Date | string
    date_fin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    titre?: StringFieldUpdateOperationsInput | string
    nom_ecole?: StringFieldUpdateOperationsInput | string
    lien_ecole?: StringFieldUpdateOperationsInput | string
    afficher?: BoolFieldUpdateOperationsInput | boolean
  }

  export type apropos_etudesUncheckedUpdateManyInput = {
    id_etu?: IntFieldUpdateOperationsInput | number
    date_debut?: DateTimeFieldUpdateOperationsInput | Date | string
    date_fin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    titre?: StringFieldUpdateOperationsInput | string
    nom_ecole?: StringFieldUpdateOperationsInput | string
    lien_ecole?: StringFieldUpdateOperationsInput | string
    afficher?: BoolFieldUpdateOperationsInput | boolean
  }

  export type apropos_experiencesCreateInput = {
    date_debut: Date | string
    date_fin?: Date | string | null
    titre: string
    nom_entreprise: string
    lien_entreprise: string
    afficher: boolean
  }

  export type apropos_experiencesUncheckedCreateInput = {
    id_exp?: number
    date_debut: Date | string
    date_fin?: Date | string | null
    titre: string
    nom_entreprise: string
    lien_entreprise: string
    afficher: boolean
  }

  export type apropos_experiencesUpdateInput = {
    date_debut?: DateTimeFieldUpdateOperationsInput | Date | string
    date_fin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    titre?: StringFieldUpdateOperationsInput | string
    nom_entreprise?: StringFieldUpdateOperationsInput | string
    lien_entreprise?: StringFieldUpdateOperationsInput | string
    afficher?: BoolFieldUpdateOperationsInput | boolean
  }

  export type apropos_experiencesUncheckedUpdateInput = {
    id_exp?: IntFieldUpdateOperationsInput | number
    date_debut?: DateTimeFieldUpdateOperationsInput | Date | string
    date_fin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    titre?: StringFieldUpdateOperationsInput | string
    nom_entreprise?: StringFieldUpdateOperationsInput | string
    lien_entreprise?: StringFieldUpdateOperationsInput | string
    afficher?: BoolFieldUpdateOperationsInput | boolean
  }

  export type apropos_experiencesCreateManyInput = {
    id_exp?: number
    date_debut: Date | string
    date_fin?: Date | string | null
    titre: string
    nom_entreprise: string
    lien_entreprise: string
    afficher: boolean
  }

  export type apropos_experiencesUpdateManyMutationInput = {
    date_debut?: DateTimeFieldUpdateOperationsInput | Date | string
    date_fin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    titre?: StringFieldUpdateOperationsInput | string
    nom_entreprise?: StringFieldUpdateOperationsInput | string
    lien_entreprise?: StringFieldUpdateOperationsInput | string
    afficher?: BoolFieldUpdateOperationsInput | boolean
  }

  export type apropos_experiencesUncheckedUpdateManyInput = {
    id_exp?: IntFieldUpdateOperationsInput | number
    date_debut?: DateTimeFieldUpdateOperationsInput | Date | string
    date_fin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    titre?: StringFieldUpdateOperationsInput | string
    nom_entreprise?: StringFieldUpdateOperationsInput | string
    lien_entreprise?: StringFieldUpdateOperationsInput | string
    afficher?: BoolFieldUpdateOperationsInput | boolean
  }

  export type apropos_generalCreateInput = {
    photo: string
    photo_alt: string
    description: string
  }

  export type apropos_generalUncheckedCreateInput = {
    id_gen?: number
    photo: string
    photo_alt: string
    description: string
  }

  export type apropos_generalUpdateInput = {
    photo?: StringFieldUpdateOperationsInput | string
    photo_alt?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type apropos_generalUncheckedUpdateInput = {
    id_gen?: IntFieldUpdateOperationsInput | number
    photo?: StringFieldUpdateOperationsInput | string
    photo_alt?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type apropos_generalCreateManyInput = {
    id_gen?: number
    photo: string
    photo_alt: string
    description: string
  }

  export type apropos_generalUpdateManyMutationInput = {
    photo?: StringFieldUpdateOperationsInput | string
    photo_alt?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type apropos_generalUncheckedUpdateManyInput = {
    id_gen?: IntFieldUpdateOperationsInput | number
    photo?: StringFieldUpdateOperationsInput | string
    photo_alt?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type apropos_outilsCreateInput = {
    type_outil?: string
    titre: string
    description: string
    icone: string
    icone_alt: string
    icone_rounded: boolean
    lien: string
    couleur_fond: string
    couleur_titre: string
    couleur_description: string
    ordre: number
    afficher: boolean
  }

  export type apropos_outilsUncheckedCreateInput = {
    id_outil?: number
    type_outil?: string
    titre: string
    description: string
    icone: string
    icone_alt: string
    icone_rounded: boolean
    lien: string
    couleur_fond: string
    couleur_titre: string
    couleur_description: string
    ordre: number
    afficher: boolean
  }

  export type apropos_outilsUpdateInput = {
    type_outil?: StringFieldUpdateOperationsInput | string
    titre?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    icone?: StringFieldUpdateOperationsInput | string
    icone_alt?: StringFieldUpdateOperationsInput | string
    icone_rounded?: BoolFieldUpdateOperationsInput | boolean
    lien?: StringFieldUpdateOperationsInput | string
    couleur_fond?: StringFieldUpdateOperationsInput | string
    couleur_titre?: StringFieldUpdateOperationsInput | string
    couleur_description?: StringFieldUpdateOperationsInput | string
    ordre?: IntFieldUpdateOperationsInput | number
    afficher?: BoolFieldUpdateOperationsInput | boolean
  }

  export type apropos_outilsUncheckedUpdateInput = {
    id_outil?: IntFieldUpdateOperationsInput | number
    type_outil?: StringFieldUpdateOperationsInput | string
    titre?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    icone?: StringFieldUpdateOperationsInput | string
    icone_alt?: StringFieldUpdateOperationsInput | string
    icone_rounded?: BoolFieldUpdateOperationsInput | boolean
    lien?: StringFieldUpdateOperationsInput | string
    couleur_fond?: StringFieldUpdateOperationsInput | string
    couleur_titre?: StringFieldUpdateOperationsInput | string
    couleur_description?: StringFieldUpdateOperationsInput | string
    ordre?: IntFieldUpdateOperationsInput | number
    afficher?: BoolFieldUpdateOperationsInput | boolean
  }

  export type apropos_outilsCreateManyInput = {
    id_outil?: number
    type_outil?: string
    titre: string
    description: string
    icone: string
    icone_alt: string
    icone_rounded: boolean
    lien: string
    couleur_fond: string
    couleur_titre: string
    couleur_description: string
    ordre: number
    afficher: boolean
  }

  export type apropos_outilsUpdateManyMutationInput = {
    type_outil?: StringFieldUpdateOperationsInput | string
    titre?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    icone?: StringFieldUpdateOperationsInput | string
    icone_alt?: StringFieldUpdateOperationsInput | string
    icone_rounded?: BoolFieldUpdateOperationsInput | boolean
    lien?: StringFieldUpdateOperationsInput | string
    couleur_fond?: StringFieldUpdateOperationsInput | string
    couleur_titre?: StringFieldUpdateOperationsInput | string
    couleur_description?: StringFieldUpdateOperationsInput | string
    ordre?: IntFieldUpdateOperationsInput | number
    afficher?: BoolFieldUpdateOperationsInput | boolean
  }

  export type apropos_outilsUncheckedUpdateManyInput = {
    id_outil?: IntFieldUpdateOperationsInput | number
    type_outil?: StringFieldUpdateOperationsInput | string
    titre?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    icone?: StringFieldUpdateOperationsInput | string
    icone_alt?: StringFieldUpdateOperationsInput | string
    icone_rounded?: BoolFieldUpdateOperationsInput | boolean
    lien?: StringFieldUpdateOperationsInput | string
    couleur_fond?: StringFieldUpdateOperationsInput | string
    couleur_titre?: StringFieldUpdateOperationsInput | string
    couleur_description?: StringFieldUpdateOperationsInput | string
    ordre?: IntFieldUpdateOperationsInput | number
    afficher?: BoolFieldUpdateOperationsInput | boolean
  }

  export type photosCreateInput = {
    lien_high: string
    lien_low: string
    largeur: number
    hauteur: number
    alt: string
    date: Date | string
    afficher_carrousel_main?: boolean
    afficher_carrousel_photos?: boolean
    afficher: boolean
    derniere_modification: Date | string
    photos_albums_link?: photos_albums_linkCreateNestedManyWithoutPhotosInput
    photos_tags_link?: photos_tags_linkCreateNestedManyWithoutPhotosInput
    photos_tags_recherche_link?: photos_tags_recherche_linkCreateNestedManyWithoutPhotosInput
  }

  export type photosUncheckedCreateInput = {
    id_pho?: number
    lien_high: string
    lien_low: string
    largeur: number
    hauteur: number
    alt: string
    date: Date | string
    afficher_carrousel_main?: boolean
    afficher_carrousel_photos?: boolean
    afficher: boolean
    derniere_modification: Date | string
    photos_albums_link?: photos_albums_linkUncheckedCreateNestedManyWithoutPhotosInput
    photos_tags_link?: photos_tags_linkUncheckedCreateNestedManyWithoutPhotosInput
    photos_tags_recherche_link?: photos_tags_recherche_linkUncheckedCreateNestedManyWithoutPhotosInput
  }

  export type photosUpdateInput = {
    lien_high?: StringFieldUpdateOperationsInput | string
    lien_low?: StringFieldUpdateOperationsInput | string
    largeur?: IntFieldUpdateOperationsInput | number
    hauteur?: IntFieldUpdateOperationsInput | number
    alt?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    afficher_carrousel_main?: BoolFieldUpdateOperationsInput | boolean
    afficher_carrousel_photos?: BoolFieldUpdateOperationsInput | boolean
    afficher?: BoolFieldUpdateOperationsInput | boolean
    derniere_modification?: DateTimeFieldUpdateOperationsInput | Date | string
    photos_albums_link?: photos_albums_linkUpdateManyWithoutPhotosNestedInput
    photos_tags_link?: photos_tags_linkUpdateManyWithoutPhotosNestedInput
    photos_tags_recherche_link?: photos_tags_recherche_linkUpdateManyWithoutPhotosNestedInput
  }

  export type photosUncheckedUpdateInput = {
    id_pho?: IntFieldUpdateOperationsInput | number
    lien_high?: StringFieldUpdateOperationsInput | string
    lien_low?: StringFieldUpdateOperationsInput | string
    largeur?: IntFieldUpdateOperationsInput | number
    hauteur?: IntFieldUpdateOperationsInput | number
    alt?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    afficher_carrousel_main?: BoolFieldUpdateOperationsInput | boolean
    afficher_carrousel_photos?: BoolFieldUpdateOperationsInput | boolean
    afficher?: BoolFieldUpdateOperationsInput | boolean
    derniere_modification?: DateTimeFieldUpdateOperationsInput | Date | string
    photos_albums_link?: photos_albums_linkUncheckedUpdateManyWithoutPhotosNestedInput
    photos_tags_link?: photos_tags_linkUncheckedUpdateManyWithoutPhotosNestedInput
    photos_tags_recherche_link?: photos_tags_recherche_linkUncheckedUpdateManyWithoutPhotosNestedInput
  }

  export type photosCreateManyInput = {
    id_pho?: number
    lien_high: string
    lien_low: string
    largeur: number
    hauteur: number
    alt: string
    date: Date | string
    afficher_carrousel_main?: boolean
    afficher_carrousel_photos?: boolean
    afficher: boolean
    derniere_modification: Date | string
  }

  export type photosUpdateManyMutationInput = {
    lien_high?: StringFieldUpdateOperationsInput | string
    lien_low?: StringFieldUpdateOperationsInput | string
    largeur?: IntFieldUpdateOperationsInput | number
    hauteur?: IntFieldUpdateOperationsInput | number
    alt?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    afficher_carrousel_main?: BoolFieldUpdateOperationsInput | boolean
    afficher_carrousel_photos?: BoolFieldUpdateOperationsInput | boolean
    afficher?: BoolFieldUpdateOperationsInput | boolean
    derniere_modification?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type photosUncheckedUpdateManyInput = {
    id_pho?: IntFieldUpdateOperationsInput | number
    lien_high?: StringFieldUpdateOperationsInput | string
    lien_low?: StringFieldUpdateOperationsInput | string
    largeur?: IntFieldUpdateOperationsInput | number
    hauteur?: IntFieldUpdateOperationsInput | number
    alt?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    afficher_carrousel_main?: BoolFieldUpdateOperationsInput | boolean
    afficher_carrousel_photos?: BoolFieldUpdateOperationsInput | boolean
    afficher?: BoolFieldUpdateOperationsInput | boolean
    derniere_modification?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type photos_albumsCreateInput = {
    titre: string
    lien_cover: string
    date: Date | string
    afficher: boolean
    derniere_modification: Date | string
    photos_albums_link?: photos_albums_linkCreateNestedManyWithoutPhotos_albumsInput
    photos_albums_tags_link?: photos_albums_tags_linkCreateNestedManyWithoutPhotos_albumsInput
  }

  export type photos_albumsUncheckedCreateInput = {
    id_alb?: number
    titre: string
    lien_cover: string
    date: Date | string
    afficher: boolean
    derniere_modification: Date | string
    photos_albums_link?: photos_albums_linkUncheckedCreateNestedManyWithoutPhotos_albumsInput
    photos_albums_tags_link?: photos_albums_tags_linkUncheckedCreateNestedManyWithoutPhotos_albumsInput
  }

  export type photos_albumsUpdateInput = {
    titre?: StringFieldUpdateOperationsInput | string
    lien_cover?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    afficher?: BoolFieldUpdateOperationsInput | boolean
    derniere_modification?: DateTimeFieldUpdateOperationsInput | Date | string
    photos_albums_link?: photos_albums_linkUpdateManyWithoutPhotos_albumsNestedInput
    photos_albums_tags_link?: photos_albums_tags_linkUpdateManyWithoutPhotos_albumsNestedInput
  }

  export type photos_albumsUncheckedUpdateInput = {
    id_alb?: IntFieldUpdateOperationsInput | number
    titre?: StringFieldUpdateOperationsInput | string
    lien_cover?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    afficher?: BoolFieldUpdateOperationsInput | boolean
    derniere_modification?: DateTimeFieldUpdateOperationsInput | Date | string
    photos_albums_link?: photos_albums_linkUncheckedUpdateManyWithoutPhotos_albumsNestedInput
    photos_albums_tags_link?: photos_albums_tags_linkUncheckedUpdateManyWithoutPhotos_albumsNestedInput
  }

  export type photos_albumsCreateManyInput = {
    id_alb?: number
    titre: string
    lien_cover: string
    date: Date | string
    afficher: boolean
    derniere_modification: Date | string
  }

  export type photos_albumsUpdateManyMutationInput = {
    titre?: StringFieldUpdateOperationsInput | string
    lien_cover?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    afficher?: BoolFieldUpdateOperationsInput | boolean
    derniere_modification?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type photos_albumsUncheckedUpdateManyInput = {
    id_alb?: IntFieldUpdateOperationsInput | number
    titre?: StringFieldUpdateOperationsInput | string
    lien_cover?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    afficher?: BoolFieldUpdateOperationsInput | boolean
    derniere_modification?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type photos_albums_linkCreateInput = {
    position?: number | null
    photos: photosCreateNestedOneWithoutPhotos_albums_linkInput
    photos_albums: photos_albumsCreateNestedOneWithoutPhotos_albums_linkInput
  }

  export type photos_albums_linkUncheckedCreateInput = {
    id_pho: number
    id_alb: number
    position?: number | null
  }

  export type photos_albums_linkUpdateInput = {
    position?: NullableIntFieldUpdateOperationsInput | number | null
    photos?: photosUpdateOneRequiredWithoutPhotos_albums_linkNestedInput
    photos_albums?: photos_albumsUpdateOneRequiredWithoutPhotos_albums_linkNestedInput
  }

  export type photos_albums_linkUncheckedUpdateInput = {
    id_pho?: IntFieldUpdateOperationsInput | number
    id_alb?: IntFieldUpdateOperationsInput | number
    position?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type photos_albums_linkCreateManyInput = {
    id_pho: number
    id_alb: number
    position?: number | null
  }

  export type photos_albums_linkUpdateManyMutationInput = {
    position?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type photos_albums_linkUncheckedUpdateManyInput = {
    id_pho?: IntFieldUpdateOperationsInput | number
    id_alb?: IntFieldUpdateOperationsInput | number
    position?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type photos_albums_tags_linkCreateInput = {
    photos_albums: photos_albumsCreateNestedOneWithoutPhotos_albums_tags_linkInput
    photos_tags: photos_tagsCreateNestedOneWithoutPhotos_albums_tags_linkInput
  }

  export type photos_albums_tags_linkUncheckedCreateInput = {
    id_alb: number
    id_tags: number
  }

  export type photos_albums_tags_linkUpdateInput = {
    photos_albums?: photos_albumsUpdateOneRequiredWithoutPhotos_albums_tags_linkNestedInput
    photos_tags?: photos_tagsUpdateOneRequiredWithoutPhotos_albums_tags_linkNestedInput
  }

  export type photos_albums_tags_linkUncheckedUpdateInput = {
    id_alb?: IntFieldUpdateOperationsInput | number
    id_tags?: IntFieldUpdateOperationsInput | number
  }

  export type photos_albums_tags_linkCreateManyInput = {
    id_alb: number
    id_tags: number
  }

  export type photos_albums_tags_linkUpdateManyMutationInput = {

  }

  export type photos_albums_tags_linkUncheckedUpdateManyInput = {
    id_alb?: IntFieldUpdateOperationsInput | number
    id_tags?: IntFieldUpdateOperationsInput | number
  }

  export type photos_tagsCreateInput = {
    titre: string
    important: boolean
    photos_albums_tags_link?: photos_albums_tags_linkCreateNestedManyWithoutPhotos_tagsInput
    photos_tags_link?: photos_tags_linkCreateNestedManyWithoutPhotos_tagsInput
  }

  export type photos_tagsUncheckedCreateInput = {
    id_tags?: number
    titre: string
    important: boolean
    photos_albums_tags_link?: photos_albums_tags_linkUncheckedCreateNestedManyWithoutPhotos_tagsInput
    photos_tags_link?: photos_tags_linkUncheckedCreateNestedManyWithoutPhotos_tagsInput
  }

  export type photos_tagsUpdateInput = {
    titre?: StringFieldUpdateOperationsInput | string
    important?: BoolFieldUpdateOperationsInput | boolean
    photos_albums_tags_link?: photos_albums_tags_linkUpdateManyWithoutPhotos_tagsNestedInput
    photos_tags_link?: photos_tags_linkUpdateManyWithoutPhotos_tagsNestedInput
  }

  export type photos_tagsUncheckedUpdateInput = {
    id_tags?: IntFieldUpdateOperationsInput | number
    titre?: StringFieldUpdateOperationsInput | string
    important?: BoolFieldUpdateOperationsInput | boolean
    photos_albums_tags_link?: photos_albums_tags_linkUncheckedUpdateManyWithoutPhotos_tagsNestedInput
    photos_tags_link?: photos_tags_linkUncheckedUpdateManyWithoutPhotos_tagsNestedInput
  }

  export type photos_tagsCreateManyInput = {
    id_tags?: number
    titre: string
    important: boolean
  }

  export type photos_tagsUpdateManyMutationInput = {
    titre?: StringFieldUpdateOperationsInput | string
    important?: BoolFieldUpdateOperationsInput | boolean
  }

  export type photos_tagsUncheckedUpdateManyInput = {
    id_tags?: IntFieldUpdateOperationsInput | number
    titre?: StringFieldUpdateOperationsInput | string
    important?: BoolFieldUpdateOperationsInput | boolean
  }

  export type photos_tags_linkCreateInput = {
    photos: photosCreateNestedOneWithoutPhotos_tags_linkInput
    photos_tags: photos_tagsCreateNestedOneWithoutPhotos_tags_linkInput
  }

  export type photos_tags_linkUncheckedCreateInput = {
    id_pho: number
    id_tags: number
  }

  export type photos_tags_linkUpdateInput = {
    photos?: photosUpdateOneRequiredWithoutPhotos_tags_linkNestedInput
    photos_tags?: photos_tagsUpdateOneRequiredWithoutPhotos_tags_linkNestedInput
  }

  export type photos_tags_linkUncheckedUpdateInput = {
    id_pho?: IntFieldUpdateOperationsInput | number
    id_tags?: IntFieldUpdateOperationsInput | number
  }

  export type photos_tags_linkCreateManyInput = {
    id_pho: number
    id_tags: number
  }

  export type photos_tags_linkUpdateManyMutationInput = {

  }

  export type photos_tags_linkUncheckedUpdateManyInput = {
    id_pho?: IntFieldUpdateOperationsInput | number
    id_tags?: IntFieldUpdateOperationsInput | number
  }

  export type photos_tags_rechercheCreateInput = {
    titre: string
    important: boolean
    photos_tags_recherche_link?: photos_tags_recherche_linkCreateNestedManyWithoutPhotos_tags_rechercheInput
  }

  export type photos_tags_rechercheUncheckedCreateInput = {
    id_tags?: number
    titre: string
    important: boolean
    photos_tags_recherche_link?: photos_tags_recherche_linkUncheckedCreateNestedManyWithoutPhotos_tags_rechercheInput
  }

  export type photos_tags_rechercheUpdateInput = {
    titre?: StringFieldUpdateOperationsInput | string
    important?: BoolFieldUpdateOperationsInput | boolean
    photos_tags_recherche_link?: photos_tags_recherche_linkUpdateManyWithoutPhotos_tags_rechercheNestedInput
  }

  export type photos_tags_rechercheUncheckedUpdateInput = {
    id_tags?: IntFieldUpdateOperationsInput | number
    titre?: StringFieldUpdateOperationsInput | string
    important?: BoolFieldUpdateOperationsInput | boolean
    photos_tags_recherche_link?: photos_tags_recherche_linkUncheckedUpdateManyWithoutPhotos_tags_rechercheNestedInput
  }

  export type photos_tags_rechercheCreateManyInput = {
    id_tags?: number
    titre: string
    important: boolean
  }

  export type photos_tags_rechercheUpdateManyMutationInput = {
    titre?: StringFieldUpdateOperationsInput | string
    important?: BoolFieldUpdateOperationsInput | boolean
  }

  export type photos_tags_rechercheUncheckedUpdateManyInput = {
    id_tags?: IntFieldUpdateOperationsInput | number
    titre?: StringFieldUpdateOperationsInput | string
    important?: BoolFieldUpdateOperationsInput | boolean
  }

  export type photos_tags_recherche_linkCreateInput = {
    photos: photosCreateNestedOneWithoutPhotos_tags_recherche_linkInput
    photos_tags_recherche: photos_tags_rechercheCreateNestedOneWithoutPhotos_tags_recherche_linkInput
  }

  export type photos_tags_recherche_linkUncheckedCreateInput = {
    id_pho: number
    id_tags: number
  }

  export type photos_tags_recherche_linkUpdateInput = {
    photos?: photosUpdateOneRequiredWithoutPhotos_tags_recherche_linkNestedInput
    photos_tags_recherche?: photos_tags_rechercheUpdateOneRequiredWithoutPhotos_tags_recherche_linkNestedInput
  }

  export type photos_tags_recherche_linkUncheckedUpdateInput = {
    id_pho?: IntFieldUpdateOperationsInput | number
    id_tags?: IntFieldUpdateOperationsInput | number
  }

  export type photos_tags_recherche_linkCreateManyInput = {
    id_pho: number
    id_tags: number
  }

  export type photos_tags_recherche_linkUpdateManyMutationInput = {

  }

  export type photos_tags_recherche_linkUncheckedUpdateManyInput = {
    id_pho?: IntFieldUpdateOperationsInput | number
    id_tags?: IntFieldUpdateOperationsInput | number
  }

  export type sessionCreateInput = {
    id: string
    expiresAt: Date | string
    token: string
    createdAt: Date | string
    updatedAt: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    userId: string
  }

  export type sessionUncheckedCreateInput = {
    id: string
    expiresAt: Date | string
    token: string
    createdAt: Date | string
    updatedAt: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    userId: string
  }

  export type sessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type sessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type sessionCreateManyInput = {
    id: string
    expiresAt: Date | string
    token: string
    createdAt: Date | string
    updatedAt: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    userId: string
  }

  export type sessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type sessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type userCreateInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type userUncheckedCreateInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type userUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type userUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type userCreateManyInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type userUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type userUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type utilisateursCreateInput = {
    img: string
    email?: string | null
    username: string
    password: string
    role: string
  }

  export type utilisateursUncheckedCreateInput = {
    id_user?: number
    img: string
    email?: string | null
    username: string
    password: string
    role: string
  }

  export type utilisateursUpdateInput = {
    img?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
  }

  export type utilisateursUncheckedUpdateInput = {
    id_user?: IntFieldUpdateOperationsInput | number
    img?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
  }

  export type utilisateursCreateManyInput = {
    id_user?: number
    img: string
    email?: string | null
    username: string
    password: string
    role: string
  }

  export type utilisateursUpdateManyMutationInput = {
    img?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
  }

  export type utilisateursUncheckedUpdateManyInput = {
    id_user?: IntFieldUpdateOperationsInput | number
    img?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
  }

  export type verificationCreateInput = {
    id: string
    identifier: string
    value: string
    expiresAt: Date | string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type verificationUncheckedCreateInput = {
    id: string
    identifier: string
    value: string
    expiresAt: Date | string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type verificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type verificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type verificationCreateManyInput = {
    id: string
    identifier: string
    value: string
    expiresAt: Date | string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type verificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type verificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type videosCreateInput = {
    titre: string
    lien: string
    date: Date | string
    afficher_carrousel_main?: boolean
    afficher_section_videos?: boolean
    tag_section_videos?: number | null
    afficher: boolean
    derniere_modification: Date | string
    videos_tags_link?: videos_tags_linkCreateNestedManyWithoutVideosInput
  }

  export type videosUncheckedCreateInput = {
    id_vid?: number
    titre: string
    lien: string
    date: Date | string
    afficher_carrousel_main?: boolean
    afficher_section_videos?: boolean
    tag_section_videos?: number | null
    afficher: boolean
    derniere_modification: Date | string
    videos_tags_link?: videos_tags_linkUncheckedCreateNestedManyWithoutVideosInput
  }

  export type videosUpdateInput = {
    titre?: StringFieldUpdateOperationsInput | string
    lien?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    afficher_carrousel_main?: BoolFieldUpdateOperationsInput | boolean
    afficher_section_videos?: BoolFieldUpdateOperationsInput | boolean
    tag_section_videos?: NullableIntFieldUpdateOperationsInput | number | null
    afficher?: BoolFieldUpdateOperationsInput | boolean
    derniere_modification?: DateTimeFieldUpdateOperationsInput | Date | string
    videos_tags_link?: videos_tags_linkUpdateManyWithoutVideosNestedInput
  }

  export type videosUncheckedUpdateInput = {
    id_vid?: IntFieldUpdateOperationsInput | number
    titre?: StringFieldUpdateOperationsInput | string
    lien?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    afficher_carrousel_main?: BoolFieldUpdateOperationsInput | boolean
    afficher_section_videos?: BoolFieldUpdateOperationsInput | boolean
    tag_section_videos?: NullableIntFieldUpdateOperationsInput | number | null
    afficher?: BoolFieldUpdateOperationsInput | boolean
    derniere_modification?: DateTimeFieldUpdateOperationsInput | Date | string
    videos_tags_link?: videos_tags_linkUncheckedUpdateManyWithoutVideosNestedInput
  }

  export type videosCreateManyInput = {
    id_vid?: number
    titre: string
    lien: string
    date: Date | string
    afficher_carrousel_main?: boolean
    afficher_section_videos?: boolean
    tag_section_videos?: number | null
    afficher: boolean
    derniere_modification: Date | string
  }

  export type videosUpdateManyMutationInput = {
    titre?: StringFieldUpdateOperationsInput | string
    lien?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    afficher_carrousel_main?: BoolFieldUpdateOperationsInput | boolean
    afficher_section_videos?: BoolFieldUpdateOperationsInput | boolean
    tag_section_videos?: NullableIntFieldUpdateOperationsInput | number | null
    afficher?: BoolFieldUpdateOperationsInput | boolean
    derniere_modification?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type videosUncheckedUpdateManyInput = {
    id_vid?: IntFieldUpdateOperationsInput | number
    titre?: StringFieldUpdateOperationsInput | string
    lien?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    afficher_carrousel_main?: BoolFieldUpdateOperationsInput | boolean
    afficher_section_videos?: BoolFieldUpdateOperationsInput | boolean
    tag_section_videos?: NullableIntFieldUpdateOperationsInput | number | null
    afficher?: BoolFieldUpdateOperationsInput | boolean
    derniere_modification?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type videos_tagsCreateInput = {
    titre: string
    important: boolean
    videos_tags_link?: videos_tags_linkCreateNestedManyWithoutVideos_tagsInput
  }

  export type videos_tagsUncheckedCreateInput = {
    id_tags?: number
    titre: string
    important: boolean
    videos_tags_link?: videos_tags_linkUncheckedCreateNestedManyWithoutVideos_tagsInput
  }

  export type videos_tagsUpdateInput = {
    titre?: StringFieldUpdateOperationsInput | string
    important?: BoolFieldUpdateOperationsInput | boolean
    videos_tags_link?: videos_tags_linkUpdateManyWithoutVideos_tagsNestedInput
  }

  export type videos_tagsUncheckedUpdateInput = {
    id_tags?: IntFieldUpdateOperationsInput | number
    titre?: StringFieldUpdateOperationsInput | string
    important?: BoolFieldUpdateOperationsInput | boolean
    videos_tags_link?: videos_tags_linkUncheckedUpdateManyWithoutVideos_tagsNestedInput
  }

  export type videos_tagsCreateManyInput = {
    id_tags?: number
    titre: string
    important: boolean
  }

  export type videos_tagsUpdateManyMutationInput = {
    titre?: StringFieldUpdateOperationsInput | string
    important?: BoolFieldUpdateOperationsInput | boolean
  }

  export type videos_tagsUncheckedUpdateManyInput = {
    id_tags?: IntFieldUpdateOperationsInput | number
    titre?: StringFieldUpdateOperationsInput | string
    important?: BoolFieldUpdateOperationsInput | boolean
  }

  export type videos_tags_linkCreateInput = {
    videos: videosCreateNestedOneWithoutVideos_tags_linkInput
    videos_tags: videos_tagsCreateNestedOneWithoutVideos_tags_linkInput
  }

  export type videos_tags_linkUncheckedCreateInput = {
    id_vid: number
    id_tags: number
  }

  export type videos_tags_linkUpdateInput = {
    videos?: videosUpdateOneRequiredWithoutVideos_tags_linkNestedInput
    videos_tags?: videos_tagsUpdateOneRequiredWithoutVideos_tags_linkNestedInput
  }

  export type videos_tags_linkUncheckedUpdateInput = {
    id_vid?: IntFieldUpdateOperationsInput | number
    id_tags?: IntFieldUpdateOperationsInput | number
  }

  export type videos_tags_linkCreateManyInput = {
    id_vid: number
    id_tags: number
  }

  export type videos_tags_linkUpdateManyMutationInput = {

  }

  export type videos_tags_linkUncheckedUpdateManyInput = {
    id_vid?: IntFieldUpdateOperationsInput | number
    id_tags?: IntFieldUpdateOperationsInput | number
  }

  export type accueil_clientsCreateInput = {
    client: string
    logo: string
    alt_logo: string
    lien_client: string
    ordre: number
    afficher: boolean
  }

  export type accueil_clientsUncheckedCreateInput = {
    id_client?: number
    client: string
    logo: string
    alt_logo: string
    lien_client: string
    ordre: number
    afficher: boolean
  }

  export type accueil_clientsUpdateInput = {
    client?: StringFieldUpdateOperationsInput | string
    logo?: StringFieldUpdateOperationsInput | string
    alt_logo?: StringFieldUpdateOperationsInput | string
    lien_client?: StringFieldUpdateOperationsInput | string
    ordre?: IntFieldUpdateOperationsInput | number
    afficher?: BoolFieldUpdateOperationsInput | boolean
  }

  export type accueil_clientsUncheckedUpdateInput = {
    id_client?: IntFieldUpdateOperationsInput | number
    client?: StringFieldUpdateOperationsInput | string
    logo?: StringFieldUpdateOperationsInput | string
    alt_logo?: StringFieldUpdateOperationsInput | string
    lien_client?: StringFieldUpdateOperationsInput | string
    ordre?: IntFieldUpdateOperationsInput | number
    afficher?: BoolFieldUpdateOperationsInput | boolean
  }

  export type accueil_clientsCreateManyInput = {
    id_client?: number
    client: string
    logo: string
    alt_logo: string
    lien_client: string
    ordre: number
    afficher: boolean
  }

  export type accueil_clientsUpdateManyMutationInput = {
    client?: StringFieldUpdateOperationsInput | string
    logo?: StringFieldUpdateOperationsInput | string
    alt_logo?: StringFieldUpdateOperationsInput | string
    lien_client?: StringFieldUpdateOperationsInput | string
    ordre?: IntFieldUpdateOperationsInput | number
    afficher?: BoolFieldUpdateOperationsInput | boolean
  }

  export type accueil_clientsUncheckedUpdateManyInput = {
    id_client?: IntFieldUpdateOperationsInput | number
    client?: StringFieldUpdateOperationsInput | string
    logo?: StringFieldUpdateOperationsInput | string
    alt_logo?: StringFieldUpdateOperationsInput | string
    lien_client?: StringFieldUpdateOperationsInput | string
    ordre?: IntFieldUpdateOperationsInput | number
    afficher?: BoolFieldUpdateOperationsInput | boolean
  }

  export type accueil_faqCreateInput = {
    titre: string
    contenu: string
    ordre: number
    afficher: boolean
  }

  export type accueil_faqUncheckedCreateInput = {
    id_faq?: number
    titre: string
    contenu: string
    ordre: number
    afficher: boolean
  }

  export type accueil_faqUpdateInput = {
    titre?: StringFieldUpdateOperationsInput | string
    contenu?: StringFieldUpdateOperationsInput | string
    ordre?: IntFieldUpdateOperationsInput | number
    afficher?: BoolFieldUpdateOperationsInput | boolean
  }

  export type accueil_faqUncheckedUpdateInput = {
    id_faq?: IntFieldUpdateOperationsInput | number
    titre?: StringFieldUpdateOperationsInput | string
    contenu?: StringFieldUpdateOperationsInput | string
    ordre?: IntFieldUpdateOperationsInput | number
    afficher?: BoolFieldUpdateOperationsInput | boolean
  }

  export type accueil_faqCreateManyInput = {
    id_faq?: number
    titre: string
    contenu: string
    ordre: number
    afficher: boolean
  }

  export type accueil_faqUpdateManyMutationInput = {
    titre?: StringFieldUpdateOperationsInput | string
    contenu?: StringFieldUpdateOperationsInput | string
    ordre?: IntFieldUpdateOperationsInput | number
    afficher?: BoolFieldUpdateOperationsInput | boolean
  }

  export type accueil_faqUncheckedUpdateManyInput = {
    id_faq?: IntFieldUpdateOperationsInput | number
    titre?: StringFieldUpdateOperationsInput | string
    contenu?: StringFieldUpdateOperationsInput | string
    ordre?: IntFieldUpdateOperationsInput | number
    afficher?: BoolFieldUpdateOperationsInput | boolean
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type accountOrderByRelevanceInput = {
    fields: accountOrderByRelevanceFieldEnum | accountOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type accountCountOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    userId?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    idToken?: SortOrder
    accessTokenExpiresAt?: SortOrder
    refreshTokenExpiresAt?: SortOrder
    scope?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type accountMaxOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    userId?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    idToken?: SortOrder
    accessTokenExpiresAt?: SortOrder
    refreshTokenExpiresAt?: SortOrder
    scope?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type accountMinOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    userId?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    idToken?: SortOrder
    accessTokenExpiresAt?: SortOrder
    refreshTokenExpiresAt?: SortOrder
    scope?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type accueil_generalOrderByRelevanceInput = {
    fields: accueil_generalOrderByRelevanceFieldEnum | accueil_generalOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type accueil_generalCountOrderByAggregateInput = {
    id_gen?: SortOrder
    video_desktop?: SortOrder
    video_mobile?: SortOrder
    video_cover?: SortOrder
    photo?: SortOrder
    photo_alt?: SortOrder
    description?: SortOrder
    localisation?: SortOrder
  }

  export type accueil_generalAvgOrderByAggregateInput = {
    id_gen?: SortOrder
  }

  export type accueil_generalMaxOrderByAggregateInput = {
    id_gen?: SortOrder
    video_desktop?: SortOrder
    video_mobile?: SortOrder
    video_cover?: SortOrder
    photo?: SortOrder
    photo_alt?: SortOrder
    description?: SortOrder
    localisation?: SortOrder
  }

  export type accueil_generalMinOrderByAggregateInput = {
    id_gen?: SortOrder
    video_desktop?: SortOrder
    video_mobile?: SortOrder
    video_cover?: SortOrder
    photo?: SortOrder
    photo_alt?: SortOrder
    description?: SortOrder
    localisation?: SortOrder
  }

  export type accueil_generalSumOrderByAggregateInput = {
    id_gen?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type apropos_etudesOrderByRelevanceInput = {
    fields: apropos_etudesOrderByRelevanceFieldEnum | apropos_etudesOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type apropos_etudesCountOrderByAggregateInput = {
    id_etu?: SortOrder
    date_debut?: SortOrder
    date_fin?: SortOrder
    titre?: SortOrder
    nom_ecole?: SortOrder
    lien_ecole?: SortOrder
    afficher?: SortOrder
  }

  export type apropos_etudesAvgOrderByAggregateInput = {
    id_etu?: SortOrder
  }

  export type apropos_etudesMaxOrderByAggregateInput = {
    id_etu?: SortOrder
    date_debut?: SortOrder
    date_fin?: SortOrder
    titre?: SortOrder
    nom_ecole?: SortOrder
    lien_ecole?: SortOrder
    afficher?: SortOrder
  }

  export type apropos_etudesMinOrderByAggregateInput = {
    id_etu?: SortOrder
    date_debut?: SortOrder
    date_fin?: SortOrder
    titre?: SortOrder
    nom_ecole?: SortOrder
    lien_ecole?: SortOrder
    afficher?: SortOrder
  }

  export type apropos_etudesSumOrderByAggregateInput = {
    id_etu?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type apropos_experiencesOrderByRelevanceInput = {
    fields: apropos_experiencesOrderByRelevanceFieldEnum | apropos_experiencesOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type apropos_experiencesCountOrderByAggregateInput = {
    id_exp?: SortOrder
    date_debut?: SortOrder
    date_fin?: SortOrder
    titre?: SortOrder
    nom_entreprise?: SortOrder
    lien_entreprise?: SortOrder
    afficher?: SortOrder
  }

  export type apropos_experiencesAvgOrderByAggregateInput = {
    id_exp?: SortOrder
  }

  export type apropos_experiencesMaxOrderByAggregateInput = {
    id_exp?: SortOrder
    date_debut?: SortOrder
    date_fin?: SortOrder
    titre?: SortOrder
    nom_entreprise?: SortOrder
    lien_entreprise?: SortOrder
    afficher?: SortOrder
  }

  export type apropos_experiencesMinOrderByAggregateInput = {
    id_exp?: SortOrder
    date_debut?: SortOrder
    date_fin?: SortOrder
    titre?: SortOrder
    nom_entreprise?: SortOrder
    lien_entreprise?: SortOrder
    afficher?: SortOrder
  }

  export type apropos_experiencesSumOrderByAggregateInput = {
    id_exp?: SortOrder
  }

  export type apropos_generalOrderByRelevanceInput = {
    fields: apropos_generalOrderByRelevanceFieldEnum | apropos_generalOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type apropos_generalCountOrderByAggregateInput = {
    id_gen?: SortOrder
    photo?: SortOrder
    photo_alt?: SortOrder
    description?: SortOrder
  }

  export type apropos_generalAvgOrderByAggregateInput = {
    id_gen?: SortOrder
  }

  export type apropos_generalMaxOrderByAggregateInput = {
    id_gen?: SortOrder
    photo?: SortOrder
    photo_alt?: SortOrder
    description?: SortOrder
  }

  export type apropos_generalMinOrderByAggregateInput = {
    id_gen?: SortOrder
    photo?: SortOrder
    photo_alt?: SortOrder
    description?: SortOrder
  }

  export type apropos_generalSumOrderByAggregateInput = {
    id_gen?: SortOrder
  }

  export type apropos_outilsOrderByRelevanceInput = {
    fields: apropos_outilsOrderByRelevanceFieldEnum | apropos_outilsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type apropos_outilsCountOrderByAggregateInput = {
    id_outil?: SortOrder
    type_outil?: SortOrder
    titre?: SortOrder
    description?: SortOrder
    icone?: SortOrder
    icone_alt?: SortOrder
    icone_rounded?: SortOrder
    lien?: SortOrder
    couleur_fond?: SortOrder
    couleur_titre?: SortOrder
    couleur_description?: SortOrder
    ordre?: SortOrder
    afficher?: SortOrder
  }

  export type apropos_outilsAvgOrderByAggregateInput = {
    id_outil?: SortOrder
    ordre?: SortOrder
  }

  export type apropos_outilsMaxOrderByAggregateInput = {
    id_outil?: SortOrder
    type_outil?: SortOrder
    titre?: SortOrder
    description?: SortOrder
    icone?: SortOrder
    icone_alt?: SortOrder
    icone_rounded?: SortOrder
    lien?: SortOrder
    couleur_fond?: SortOrder
    couleur_titre?: SortOrder
    couleur_description?: SortOrder
    ordre?: SortOrder
    afficher?: SortOrder
  }

  export type apropos_outilsMinOrderByAggregateInput = {
    id_outil?: SortOrder
    type_outil?: SortOrder
    titre?: SortOrder
    description?: SortOrder
    icone?: SortOrder
    icone_alt?: SortOrder
    icone_rounded?: SortOrder
    lien?: SortOrder
    couleur_fond?: SortOrder
    couleur_titre?: SortOrder
    couleur_description?: SortOrder
    ordre?: SortOrder
    afficher?: SortOrder
  }

  export type apropos_outilsSumOrderByAggregateInput = {
    id_outil?: SortOrder
    ordre?: SortOrder
  }

  export type Photos_albums_linkListRelationFilter = {
    every?: photos_albums_linkWhereInput
    some?: photos_albums_linkWhereInput
    none?: photos_albums_linkWhereInput
  }

  export type Photos_tags_linkListRelationFilter = {
    every?: photos_tags_linkWhereInput
    some?: photos_tags_linkWhereInput
    none?: photos_tags_linkWhereInput
  }

  export type Photos_tags_recherche_linkListRelationFilter = {
    every?: photos_tags_recherche_linkWhereInput
    some?: photos_tags_recherche_linkWhereInput
    none?: photos_tags_recherche_linkWhereInput
  }

  export type photos_albums_linkOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type photos_tags_linkOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type photos_tags_recherche_linkOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type photosOrderByRelevanceInput = {
    fields: photosOrderByRelevanceFieldEnum | photosOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type photosCountOrderByAggregateInput = {
    id_pho?: SortOrder
    lien_high?: SortOrder
    lien_low?: SortOrder
    largeur?: SortOrder
    hauteur?: SortOrder
    alt?: SortOrder
    date?: SortOrder
    afficher_carrousel_main?: SortOrder
    afficher_carrousel_photos?: SortOrder
    afficher?: SortOrder
    derniere_modification?: SortOrder
  }

  export type photosAvgOrderByAggregateInput = {
    id_pho?: SortOrder
    largeur?: SortOrder
    hauteur?: SortOrder
  }

  export type photosMaxOrderByAggregateInput = {
    id_pho?: SortOrder
    lien_high?: SortOrder
    lien_low?: SortOrder
    largeur?: SortOrder
    hauteur?: SortOrder
    alt?: SortOrder
    date?: SortOrder
    afficher_carrousel_main?: SortOrder
    afficher_carrousel_photos?: SortOrder
    afficher?: SortOrder
    derniere_modification?: SortOrder
  }

  export type photosMinOrderByAggregateInput = {
    id_pho?: SortOrder
    lien_high?: SortOrder
    lien_low?: SortOrder
    largeur?: SortOrder
    hauteur?: SortOrder
    alt?: SortOrder
    date?: SortOrder
    afficher_carrousel_main?: SortOrder
    afficher_carrousel_photos?: SortOrder
    afficher?: SortOrder
    derniere_modification?: SortOrder
  }

  export type photosSumOrderByAggregateInput = {
    id_pho?: SortOrder
    largeur?: SortOrder
    hauteur?: SortOrder
  }

  export type Photos_albums_tags_linkListRelationFilter = {
    every?: photos_albums_tags_linkWhereInput
    some?: photos_albums_tags_linkWhereInput
    none?: photos_albums_tags_linkWhereInput
  }

  export type photos_albums_tags_linkOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type photos_albumsOrderByRelevanceInput = {
    fields: photos_albumsOrderByRelevanceFieldEnum | photos_albumsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type photos_albumsCountOrderByAggregateInput = {
    id_alb?: SortOrder
    titre?: SortOrder
    lien_cover?: SortOrder
    date?: SortOrder
    afficher?: SortOrder
    derniere_modification?: SortOrder
  }

  export type photos_albumsAvgOrderByAggregateInput = {
    id_alb?: SortOrder
  }

  export type photos_albumsMaxOrderByAggregateInput = {
    id_alb?: SortOrder
    titre?: SortOrder
    lien_cover?: SortOrder
    date?: SortOrder
    afficher?: SortOrder
    derniere_modification?: SortOrder
  }

  export type photos_albumsMinOrderByAggregateInput = {
    id_alb?: SortOrder
    titre?: SortOrder
    lien_cover?: SortOrder
    date?: SortOrder
    afficher?: SortOrder
    derniere_modification?: SortOrder
  }

  export type photos_albumsSumOrderByAggregateInput = {
    id_alb?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type PhotosScalarRelationFilter = {
    is?: photosWhereInput
    isNot?: photosWhereInput
  }

  export type Photos_albumsScalarRelationFilter = {
    is?: photos_albumsWhereInput
    isNot?: photos_albumsWhereInput
  }

  export type photos_albums_linkId_phoId_albCompoundUniqueInput = {
    id_pho: number
    id_alb: number
  }

  export type photos_albums_linkCountOrderByAggregateInput = {
    id_pho?: SortOrder
    id_alb?: SortOrder
    position?: SortOrder
  }

  export type photos_albums_linkAvgOrderByAggregateInput = {
    id_pho?: SortOrder
    id_alb?: SortOrder
    position?: SortOrder
  }

  export type photos_albums_linkMaxOrderByAggregateInput = {
    id_pho?: SortOrder
    id_alb?: SortOrder
    position?: SortOrder
  }

  export type photos_albums_linkMinOrderByAggregateInput = {
    id_pho?: SortOrder
    id_alb?: SortOrder
    position?: SortOrder
  }

  export type photos_albums_linkSumOrderByAggregateInput = {
    id_pho?: SortOrder
    id_alb?: SortOrder
    position?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type Photos_tagsScalarRelationFilter = {
    is?: photos_tagsWhereInput
    isNot?: photos_tagsWhereInput
  }

  export type photos_albums_tags_linkId_albId_tagsCompoundUniqueInput = {
    id_alb: number
    id_tags: number
  }

  export type photos_albums_tags_linkCountOrderByAggregateInput = {
    id_alb?: SortOrder
    id_tags?: SortOrder
  }

  export type photos_albums_tags_linkAvgOrderByAggregateInput = {
    id_alb?: SortOrder
    id_tags?: SortOrder
  }

  export type photos_albums_tags_linkMaxOrderByAggregateInput = {
    id_alb?: SortOrder
    id_tags?: SortOrder
  }

  export type photos_albums_tags_linkMinOrderByAggregateInput = {
    id_alb?: SortOrder
    id_tags?: SortOrder
  }

  export type photos_albums_tags_linkSumOrderByAggregateInput = {
    id_alb?: SortOrder
    id_tags?: SortOrder
  }

  export type photos_tagsOrderByRelevanceInput = {
    fields: photos_tagsOrderByRelevanceFieldEnum | photos_tagsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type photos_tagsCountOrderByAggregateInput = {
    id_tags?: SortOrder
    titre?: SortOrder
    important?: SortOrder
  }

  export type photos_tagsAvgOrderByAggregateInput = {
    id_tags?: SortOrder
  }

  export type photos_tagsMaxOrderByAggregateInput = {
    id_tags?: SortOrder
    titre?: SortOrder
    important?: SortOrder
  }

  export type photos_tagsMinOrderByAggregateInput = {
    id_tags?: SortOrder
    titre?: SortOrder
    important?: SortOrder
  }

  export type photos_tagsSumOrderByAggregateInput = {
    id_tags?: SortOrder
  }

  export type photos_tags_linkId_phoId_tagsCompoundUniqueInput = {
    id_pho: number
    id_tags: number
  }

  export type photos_tags_linkCountOrderByAggregateInput = {
    id_pho?: SortOrder
    id_tags?: SortOrder
  }

  export type photos_tags_linkAvgOrderByAggregateInput = {
    id_pho?: SortOrder
    id_tags?: SortOrder
  }

  export type photos_tags_linkMaxOrderByAggregateInput = {
    id_pho?: SortOrder
    id_tags?: SortOrder
  }

  export type photos_tags_linkMinOrderByAggregateInput = {
    id_pho?: SortOrder
    id_tags?: SortOrder
  }

  export type photos_tags_linkSumOrderByAggregateInput = {
    id_pho?: SortOrder
    id_tags?: SortOrder
  }

  export type photos_tags_rechercheOrderByRelevanceInput = {
    fields: photos_tags_rechercheOrderByRelevanceFieldEnum | photos_tags_rechercheOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type photos_tags_rechercheCountOrderByAggregateInput = {
    id_tags?: SortOrder
    titre?: SortOrder
    important?: SortOrder
  }

  export type photos_tags_rechercheAvgOrderByAggregateInput = {
    id_tags?: SortOrder
  }

  export type photos_tags_rechercheMaxOrderByAggregateInput = {
    id_tags?: SortOrder
    titre?: SortOrder
    important?: SortOrder
  }

  export type photos_tags_rechercheMinOrderByAggregateInput = {
    id_tags?: SortOrder
    titre?: SortOrder
    important?: SortOrder
  }

  export type photos_tags_rechercheSumOrderByAggregateInput = {
    id_tags?: SortOrder
  }

  export type Photos_tags_rechercheScalarRelationFilter = {
    is?: photos_tags_rechercheWhereInput
    isNot?: photos_tags_rechercheWhereInput
  }

  export type photos_tags_recherche_linkId_phoId_tagsCompoundUniqueInput = {
    id_pho: number
    id_tags: number
  }

  export type photos_tags_recherche_linkCountOrderByAggregateInput = {
    id_pho?: SortOrder
    id_tags?: SortOrder
  }

  export type photos_tags_recherche_linkAvgOrderByAggregateInput = {
    id_pho?: SortOrder
    id_tags?: SortOrder
  }

  export type photos_tags_recherche_linkMaxOrderByAggregateInput = {
    id_pho?: SortOrder
    id_tags?: SortOrder
  }

  export type photos_tags_recherche_linkMinOrderByAggregateInput = {
    id_pho?: SortOrder
    id_tags?: SortOrder
  }

  export type photos_tags_recherche_linkSumOrderByAggregateInput = {
    id_pho?: SortOrder
    id_tags?: SortOrder
  }

  export type sessionOrderByRelevanceInput = {
    fields: sessionOrderByRelevanceFieldEnum | sessionOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type sessionCountOrderByAggregateInput = {
    id?: SortOrder
    expiresAt?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    userId?: SortOrder
  }

  export type sessionMaxOrderByAggregateInput = {
    id?: SortOrder
    expiresAt?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    userId?: SortOrder
  }

  export type sessionMinOrderByAggregateInput = {
    id?: SortOrder
    expiresAt?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    userId?: SortOrder
  }

  export type userOrderByRelevanceInput = {
    fields: userOrderByRelevanceFieldEnum | userOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type userCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type userMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type userMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type utilisateursOrderByRelevanceInput = {
    fields: utilisateursOrderByRelevanceFieldEnum | utilisateursOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type utilisateursCountOrderByAggregateInput = {
    id_user?: SortOrder
    img?: SortOrder
    email?: SortOrder
    username?: SortOrder
    password?: SortOrder
    role?: SortOrder
  }

  export type utilisateursAvgOrderByAggregateInput = {
    id_user?: SortOrder
  }

  export type utilisateursMaxOrderByAggregateInput = {
    id_user?: SortOrder
    img?: SortOrder
    email?: SortOrder
    username?: SortOrder
    password?: SortOrder
    role?: SortOrder
  }

  export type utilisateursMinOrderByAggregateInput = {
    id_user?: SortOrder
    img?: SortOrder
    email?: SortOrder
    username?: SortOrder
    password?: SortOrder
    role?: SortOrder
  }

  export type utilisateursSumOrderByAggregateInput = {
    id_user?: SortOrder
  }

  export type verificationOrderByRelevanceInput = {
    fields: verificationOrderByRelevanceFieldEnum | verificationOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type verificationCountOrderByAggregateInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type verificationMaxOrderByAggregateInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type verificationMinOrderByAggregateInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type Videos_tags_linkListRelationFilter = {
    every?: videos_tags_linkWhereInput
    some?: videos_tags_linkWhereInput
    none?: videos_tags_linkWhereInput
  }

  export type videos_tags_linkOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type videosOrderByRelevanceInput = {
    fields: videosOrderByRelevanceFieldEnum | videosOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type videosCountOrderByAggregateInput = {
    id_vid?: SortOrder
    titre?: SortOrder
    lien?: SortOrder
    date?: SortOrder
    afficher_carrousel_main?: SortOrder
    afficher_section_videos?: SortOrder
    tag_section_videos?: SortOrder
    afficher?: SortOrder
    derniere_modification?: SortOrder
  }

  export type videosAvgOrderByAggregateInput = {
    id_vid?: SortOrder
    tag_section_videos?: SortOrder
  }

  export type videosMaxOrderByAggregateInput = {
    id_vid?: SortOrder
    titre?: SortOrder
    lien?: SortOrder
    date?: SortOrder
    afficher_carrousel_main?: SortOrder
    afficher_section_videos?: SortOrder
    tag_section_videos?: SortOrder
    afficher?: SortOrder
    derniere_modification?: SortOrder
  }

  export type videosMinOrderByAggregateInput = {
    id_vid?: SortOrder
    titre?: SortOrder
    lien?: SortOrder
    date?: SortOrder
    afficher_carrousel_main?: SortOrder
    afficher_section_videos?: SortOrder
    tag_section_videos?: SortOrder
    afficher?: SortOrder
    derniere_modification?: SortOrder
  }

  export type videosSumOrderByAggregateInput = {
    id_vid?: SortOrder
    tag_section_videos?: SortOrder
  }

  export type videos_tagsOrderByRelevanceInput = {
    fields: videos_tagsOrderByRelevanceFieldEnum | videos_tagsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type videos_tagsCountOrderByAggregateInput = {
    id_tags?: SortOrder
    titre?: SortOrder
    important?: SortOrder
  }

  export type videos_tagsAvgOrderByAggregateInput = {
    id_tags?: SortOrder
  }

  export type videos_tagsMaxOrderByAggregateInput = {
    id_tags?: SortOrder
    titre?: SortOrder
    important?: SortOrder
  }

  export type videos_tagsMinOrderByAggregateInput = {
    id_tags?: SortOrder
    titre?: SortOrder
    important?: SortOrder
  }

  export type videos_tagsSumOrderByAggregateInput = {
    id_tags?: SortOrder
  }

  export type VideosScalarRelationFilter = {
    is?: videosWhereInput
    isNot?: videosWhereInput
  }

  export type Videos_tagsScalarRelationFilter = {
    is?: videos_tagsWhereInput
    isNot?: videos_tagsWhereInput
  }

  export type videos_tags_linkId_vidId_tagsCompoundUniqueInput = {
    id_vid: number
    id_tags: number
  }

  export type videos_tags_linkCountOrderByAggregateInput = {
    id_vid?: SortOrder
    id_tags?: SortOrder
  }

  export type videos_tags_linkAvgOrderByAggregateInput = {
    id_vid?: SortOrder
    id_tags?: SortOrder
  }

  export type videos_tags_linkMaxOrderByAggregateInput = {
    id_vid?: SortOrder
    id_tags?: SortOrder
  }

  export type videos_tags_linkMinOrderByAggregateInput = {
    id_vid?: SortOrder
    id_tags?: SortOrder
  }

  export type videos_tags_linkSumOrderByAggregateInput = {
    id_vid?: SortOrder
    id_tags?: SortOrder
  }

  export type accueil_clientsOrderByRelevanceInput = {
    fields: accueil_clientsOrderByRelevanceFieldEnum | accueil_clientsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type accueil_clientsCountOrderByAggregateInput = {
    id_client?: SortOrder
    client?: SortOrder
    logo?: SortOrder
    alt_logo?: SortOrder
    lien_client?: SortOrder
    ordre?: SortOrder
    afficher?: SortOrder
  }

  export type accueil_clientsAvgOrderByAggregateInput = {
    id_client?: SortOrder
    ordre?: SortOrder
  }

  export type accueil_clientsMaxOrderByAggregateInput = {
    id_client?: SortOrder
    client?: SortOrder
    logo?: SortOrder
    alt_logo?: SortOrder
    lien_client?: SortOrder
    ordre?: SortOrder
    afficher?: SortOrder
  }

  export type accueil_clientsMinOrderByAggregateInput = {
    id_client?: SortOrder
    client?: SortOrder
    logo?: SortOrder
    alt_logo?: SortOrder
    lien_client?: SortOrder
    ordre?: SortOrder
    afficher?: SortOrder
  }

  export type accueil_clientsSumOrderByAggregateInput = {
    id_client?: SortOrder
    ordre?: SortOrder
  }

  export type accueil_faqOrderByRelevanceInput = {
    fields: accueil_faqOrderByRelevanceFieldEnum | accueil_faqOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type accueil_faqCountOrderByAggregateInput = {
    id_faq?: SortOrder
    titre?: SortOrder
    contenu?: SortOrder
    ordre?: SortOrder
    afficher?: SortOrder
  }

  export type accueil_faqAvgOrderByAggregateInput = {
    id_faq?: SortOrder
    ordre?: SortOrder
  }

  export type accueil_faqMaxOrderByAggregateInput = {
    id_faq?: SortOrder
    titre?: SortOrder
    contenu?: SortOrder
    ordre?: SortOrder
    afficher?: SortOrder
  }

  export type accueil_faqMinOrderByAggregateInput = {
    id_faq?: SortOrder
    titre?: SortOrder
    contenu?: SortOrder
    ordre?: SortOrder
    afficher?: SortOrder
  }

  export type accueil_faqSumOrderByAggregateInput = {
    id_faq?: SortOrder
    ordre?: SortOrder
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type photos_albums_linkCreateNestedManyWithoutPhotosInput = {
    create?: XOR<photos_albums_linkCreateWithoutPhotosInput, photos_albums_linkUncheckedCreateWithoutPhotosInput> | photos_albums_linkCreateWithoutPhotosInput[] | photos_albums_linkUncheckedCreateWithoutPhotosInput[]
    connectOrCreate?: photos_albums_linkCreateOrConnectWithoutPhotosInput | photos_albums_linkCreateOrConnectWithoutPhotosInput[]
    createMany?: photos_albums_linkCreateManyPhotosInputEnvelope
    connect?: photos_albums_linkWhereUniqueInput | photos_albums_linkWhereUniqueInput[]
  }

  export type photos_tags_linkCreateNestedManyWithoutPhotosInput = {
    create?: XOR<photos_tags_linkCreateWithoutPhotosInput, photos_tags_linkUncheckedCreateWithoutPhotosInput> | photos_tags_linkCreateWithoutPhotosInput[] | photos_tags_linkUncheckedCreateWithoutPhotosInput[]
    connectOrCreate?: photos_tags_linkCreateOrConnectWithoutPhotosInput | photos_tags_linkCreateOrConnectWithoutPhotosInput[]
    createMany?: photos_tags_linkCreateManyPhotosInputEnvelope
    connect?: photos_tags_linkWhereUniqueInput | photos_tags_linkWhereUniqueInput[]
  }

  export type photos_tags_recherche_linkCreateNestedManyWithoutPhotosInput = {
    create?: XOR<photos_tags_recherche_linkCreateWithoutPhotosInput, photos_tags_recherche_linkUncheckedCreateWithoutPhotosInput> | photos_tags_recherche_linkCreateWithoutPhotosInput[] | photos_tags_recherche_linkUncheckedCreateWithoutPhotosInput[]
    connectOrCreate?: photos_tags_recherche_linkCreateOrConnectWithoutPhotosInput | photos_tags_recherche_linkCreateOrConnectWithoutPhotosInput[]
    createMany?: photos_tags_recherche_linkCreateManyPhotosInputEnvelope
    connect?: photos_tags_recherche_linkWhereUniqueInput | photos_tags_recherche_linkWhereUniqueInput[]
  }

  export type photos_albums_linkUncheckedCreateNestedManyWithoutPhotosInput = {
    create?: XOR<photos_albums_linkCreateWithoutPhotosInput, photos_albums_linkUncheckedCreateWithoutPhotosInput> | photos_albums_linkCreateWithoutPhotosInput[] | photos_albums_linkUncheckedCreateWithoutPhotosInput[]
    connectOrCreate?: photos_albums_linkCreateOrConnectWithoutPhotosInput | photos_albums_linkCreateOrConnectWithoutPhotosInput[]
    createMany?: photos_albums_linkCreateManyPhotosInputEnvelope
    connect?: photos_albums_linkWhereUniqueInput | photos_albums_linkWhereUniqueInput[]
  }

  export type photos_tags_linkUncheckedCreateNestedManyWithoutPhotosInput = {
    create?: XOR<photos_tags_linkCreateWithoutPhotosInput, photos_tags_linkUncheckedCreateWithoutPhotosInput> | photos_tags_linkCreateWithoutPhotosInput[] | photos_tags_linkUncheckedCreateWithoutPhotosInput[]
    connectOrCreate?: photos_tags_linkCreateOrConnectWithoutPhotosInput | photos_tags_linkCreateOrConnectWithoutPhotosInput[]
    createMany?: photos_tags_linkCreateManyPhotosInputEnvelope
    connect?: photos_tags_linkWhereUniqueInput | photos_tags_linkWhereUniqueInput[]
  }

  export type photos_tags_recherche_linkUncheckedCreateNestedManyWithoutPhotosInput = {
    create?: XOR<photos_tags_recherche_linkCreateWithoutPhotosInput, photos_tags_recherche_linkUncheckedCreateWithoutPhotosInput> | photos_tags_recherche_linkCreateWithoutPhotosInput[] | photos_tags_recherche_linkUncheckedCreateWithoutPhotosInput[]
    connectOrCreate?: photos_tags_recherche_linkCreateOrConnectWithoutPhotosInput | photos_tags_recherche_linkCreateOrConnectWithoutPhotosInput[]
    createMany?: photos_tags_recherche_linkCreateManyPhotosInputEnvelope
    connect?: photos_tags_recherche_linkWhereUniqueInput | photos_tags_recherche_linkWhereUniqueInput[]
  }

  export type photos_albums_linkUpdateManyWithoutPhotosNestedInput = {
    create?: XOR<photos_albums_linkCreateWithoutPhotosInput, photos_albums_linkUncheckedCreateWithoutPhotosInput> | photos_albums_linkCreateWithoutPhotosInput[] | photos_albums_linkUncheckedCreateWithoutPhotosInput[]
    connectOrCreate?: photos_albums_linkCreateOrConnectWithoutPhotosInput | photos_albums_linkCreateOrConnectWithoutPhotosInput[]
    upsert?: photos_albums_linkUpsertWithWhereUniqueWithoutPhotosInput | photos_albums_linkUpsertWithWhereUniqueWithoutPhotosInput[]
    createMany?: photos_albums_linkCreateManyPhotosInputEnvelope
    set?: photos_albums_linkWhereUniqueInput | photos_albums_linkWhereUniqueInput[]
    disconnect?: photos_albums_linkWhereUniqueInput | photos_albums_linkWhereUniqueInput[]
    delete?: photos_albums_linkWhereUniqueInput | photos_albums_linkWhereUniqueInput[]
    connect?: photos_albums_linkWhereUniqueInput | photos_albums_linkWhereUniqueInput[]
    update?: photos_albums_linkUpdateWithWhereUniqueWithoutPhotosInput | photos_albums_linkUpdateWithWhereUniqueWithoutPhotosInput[]
    updateMany?: photos_albums_linkUpdateManyWithWhereWithoutPhotosInput | photos_albums_linkUpdateManyWithWhereWithoutPhotosInput[]
    deleteMany?: photos_albums_linkScalarWhereInput | photos_albums_linkScalarWhereInput[]
  }

  export type photos_tags_linkUpdateManyWithoutPhotosNestedInput = {
    create?: XOR<photos_tags_linkCreateWithoutPhotosInput, photos_tags_linkUncheckedCreateWithoutPhotosInput> | photos_tags_linkCreateWithoutPhotosInput[] | photos_tags_linkUncheckedCreateWithoutPhotosInput[]
    connectOrCreate?: photos_tags_linkCreateOrConnectWithoutPhotosInput | photos_tags_linkCreateOrConnectWithoutPhotosInput[]
    upsert?: photos_tags_linkUpsertWithWhereUniqueWithoutPhotosInput | photos_tags_linkUpsertWithWhereUniqueWithoutPhotosInput[]
    createMany?: photos_tags_linkCreateManyPhotosInputEnvelope
    set?: photos_tags_linkWhereUniqueInput | photos_tags_linkWhereUniqueInput[]
    disconnect?: photos_tags_linkWhereUniqueInput | photos_tags_linkWhereUniqueInput[]
    delete?: photos_tags_linkWhereUniqueInput | photos_tags_linkWhereUniqueInput[]
    connect?: photos_tags_linkWhereUniqueInput | photos_tags_linkWhereUniqueInput[]
    update?: photos_tags_linkUpdateWithWhereUniqueWithoutPhotosInput | photos_tags_linkUpdateWithWhereUniqueWithoutPhotosInput[]
    updateMany?: photos_tags_linkUpdateManyWithWhereWithoutPhotosInput | photos_tags_linkUpdateManyWithWhereWithoutPhotosInput[]
    deleteMany?: photos_tags_linkScalarWhereInput | photos_tags_linkScalarWhereInput[]
  }

  export type photos_tags_recherche_linkUpdateManyWithoutPhotosNestedInput = {
    create?: XOR<photos_tags_recherche_linkCreateWithoutPhotosInput, photos_tags_recherche_linkUncheckedCreateWithoutPhotosInput> | photos_tags_recherche_linkCreateWithoutPhotosInput[] | photos_tags_recherche_linkUncheckedCreateWithoutPhotosInput[]
    connectOrCreate?: photos_tags_recherche_linkCreateOrConnectWithoutPhotosInput | photos_tags_recherche_linkCreateOrConnectWithoutPhotosInput[]
    upsert?: photos_tags_recherche_linkUpsertWithWhereUniqueWithoutPhotosInput | photos_tags_recherche_linkUpsertWithWhereUniqueWithoutPhotosInput[]
    createMany?: photos_tags_recherche_linkCreateManyPhotosInputEnvelope
    set?: photos_tags_recherche_linkWhereUniqueInput | photos_tags_recherche_linkWhereUniqueInput[]
    disconnect?: photos_tags_recherche_linkWhereUniqueInput | photos_tags_recherche_linkWhereUniqueInput[]
    delete?: photos_tags_recherche_linkWhereUniqueInput | photos_tags_recherche_linkWhereUniqueInput[]
    connect?: photos_tags_recherche_linkWhereUniqueInput | photos_tags_recherche_linkWhereUniqueInput[]
    update?: photos_tags_recherche_linkUpdateWithWhereUniqueWithoutPhotosInput | photos_tags_recherche_linkUpdateWithWhereUniqueWithoutPhotosInput[]
    updateMany?: photos_tags_recherche_linkUpdateManyWithWhereWithoutPhotosInput | photos_tags_recherche_linkUpdateManyWithWhereWithoutPhotosInput[]
    deleteMany?: photos_tags_recherche_linkScalarWhereInput | photos_tags_recherche_linkScalarWhereInput[]
  }

  export type photos_albums_linkUncheckedUpdateManyWithoutPhotosNestedInput = {
    create?: XOR<photos_albums_linkCreateWithoutPhotosInput, photos_albums_linkUncheckedCreateWithoutPhotosInput> | photos_albums_linkCreateWithoutPhotosInput[] | photos_albums_linkUncheckedCreateWithoutPhotosInput[]
    connectOrCreate?: photos_albums_linkCreateOrConnectWithoutPhotosInput | photos_albums_linkCreateOrConnectWithoutPhotosInput[]
    upsert?: photos_albums_linkUpsertWithWhereUniqueWithoutPhotosInput | photos_albums_linkUpsertWithWhereUniqueWithoutPhotosInput[]
    createMany?: photos_albums_linkCreateManyPhotosInputEnvelope
    set?: photos_albums_linkWhereUniqueInput | photos_albums_linkWhereUniqueInput[]
    disconnect?: photos_albums_linkWhereUniqueInput | photos_albums_linkWhereUniqueInput[]
    delete?: photos_albums_linkWhereUniqueInput | photos_albums_linkWhereUniqueInput[]
    connect?: photos_albums_linkWhereUniqueInput | photos_albums_linkWhereUniqueInput[]
    update?: photos_albums_linkUpdateWithWhereUniqueWithoutPhotosInput | photos_albums_linkUpdateWithWhereUniqueWithoutPhotosInput[]
    updateMany?: photos_albums_linkUpdateManyWithWhereWithoutPhotosInput | photos_albums_linkUpdateManyWithWhereWithoutPhotosInput[]
    deleteMany?: photos_albums_linkScalarWhereInput | photos_albums_linkScalarWhereInput[]
  }

  export type photos_tags_linkUncheckedUpdateManyWithoutPhotosNestedInput = {
    create?: XOR<photos_tags_linkCreateWithoutPhotosInput, photos_tags_linkUncheckedCreateWithoutPhotosInput> | photos_tags_linkCreateWithoutPhotosInput[] | photos_tags_linkUncheckedCreateWithoutPhotosInput[]
    connectOrCreate?: photos_tags_linkCreateOrConnectWithoutPhotosInput | photos_tags_linkCreateOrConnectWithoutPhotosInput[]
    upsert?: photos_tags_linkUpsertWithWhereUniqueWithoutPhotosInput | photos_tags_linkUpsertWithWhereUniqueWithoutPhotosInput[]
    createMany?: photos_tags_linkCreateManyPhotosInputEnvelope
    set?: photos_tags_linkWhereUniqueInput | photos_tags_linkWhereUniqueInput[]
    disconnect?: photos_tags_linkWhereUniqueInput | photos_tags_linkWhereUniqueInput[]
    delete?: photos_tags_linkWhereUniqueInput | photos_tags_linkWhereUniqueInput[]
    connect?: photos_tags_linkWhereUniqueInput | photos_tags_linkWhereUniqueInput[]
    update?: photos_tags_linkUpdateWithWhereUniqueWithoutPhotosInput | photos_tags_linkUpdateWithWhereUniqueWithoutPhotosInput[]
    updateMany?: photos_tags_linkUpdateManyWithWhereWithoutPhotosInput | photos_tags_linkUpdateManyWithWhereWithoutPhotosInput[]
    deleteMany?: photos_tags_linkScalarWhereInput | photos_tags_linkScalarWhereInput[]
  }

  export type photos_tags_recherche_linkUncheckedUpdateManyWithoutPhotosNestedInput = {
    create?: XOR<photos_tags_recherche_linkCreateWithoutPhotosInput, photos_tags_recherche_linkUncheckedCreateWithoutPhotosInput> | photos_tags_recherche_linkCreateWithoutPhotosInput[] | photos_tags_recherche_linkUncheckedCreateWithoutPhotosInput[]
    connectOrCreate?: photos_tags_recherche_linkCreateOrConnectWithoutPhotosInput | photos_tags_recherche_linkCreateOrConnectWithoutPhotosInput[]
    upsert?: photos_tags_recherche_linkUpsertWithWhereUniqueWithoutPhotosInput | photos_tags_recherche_linkUpsertWithWhereUniqueWithoutPhotosInput[]
    createMany?: photos_tags_recherche_linkCreateManyPhotosInputEnvelope
    set?: photos_tags_recherche_linkWhereUniqueInput | photos_tags_recherche_linkWhereUniqueInput[]
    disconnect?: photos_tags_recherche_linkWhereUniqueInput | photos_tags_recherche_linkWhereUniqueInput[]
    delete?: photos_tags_recherche_linkWhereUniqueInput | photos_tags_recherche_linkWhereUniqueInput[]
    connect?: photos_tags_recherche_linkWhereUniqueInput | photos_tags_recherche_linkWhereUniqueInput[]
    update?: photos_tags_recherche_linkUpdateWithWhereUniqueWithoutPhotosInput | photos_tags_recherche_linkUpdateWithWhereUniqueWithoutPhotosInput[]
    updateMany?: photos_tags_recherche_linkUpdateManyWithWhereWithoutPhotosInput | photos_tags_recherche_linkUpdateManyWithWhereWithoutPhotosInput[]
    deleteMany?: photos_tags_recherche_linkScalarWhereInput | photos_tags_recherche_linkScalarWhereInput[]
  }

  export type photos_albums_linkCreateNestedManyWithoutPhotos_albumsInput = {
    create?: XOR<photos_albums_linkCreateWithoutPhotos_albumsInput, photos_albums_linkUncheckedCreateWithoutPhotos_albumsInput> | photos_albums_linkCreateWithoutPhotos_albumsInput[] | photos_albums_linkUncheckedCreateWithoutPhotos_albumsInput[]
    connectOrCreate?: photos_albums_linkCreateOrConnectWithoutPhotos_albumsInput | photos_albums_linkCreateOrConnectWithoutPhotos_albumsInput[]
    createMany?: photos_albums_linkCreateManyPhotos_albumsInputEnvelope
    connect?: photos_albums_linkWhereUniqueInput | photos_albums_linkWhereUniqueInput[]
  }

  export type photos_albums_tags_linkCreateNestedManyWithoutPhotos_albumsInput = {
    create?: XOR<photos_albums_tags_linkCreateWithoutPhotos_albumsInput, photos_albums_tags_linkUncheckedCreateWithoutPhotos_albumsInput> | photos_albums_tags_linkCreateWithoutPhotos_albumsInput[] | photos_albums_tags_linkUncheckedCreateWithoutPhotos_albumsInput[]
    connectOrCreate?: photos_albums_tags_linkCreateOrConnectWithoutPhotos_albumsInput | photos_albums_tags_linkCreateOrConnectWithoutPhotos_albumsInput[]
    createMany?: photos_albums_tags_linkCreateManyPhotos_albumsInputEnvelope
    connect?: photos_albums_tags_linkWhereUniqueInput | photos_albums_tags_linkWhereUniqueInput[]
  }

  export type photos_albums_linkUncheckedCreateNestedManyWithoutPhotos_albumsInput = {
    create?: XOR<photos_albums_linkCreateWithoutPhotos_albumsInput, photos_albums_linkUncheckedCreateWithoutPhotos_albumsInput> | photos_albums_linkCreateWithoutPhotos_albumsInput[] | photos_albums_linkUncheckedCreateWithoutPhotos_albumsInput[]
    connectOrCreate?: photos_albums_linkCreateOrConnectWithoutPhotos_albumsInput | photos_albums_linkCreateOrConnectWithoutPhotos_albumsInput[]
    createMany?: photos_albums_linkCreateManyPhotos_albumsInputEnvelope
    connect?: photos_albums_linkWhereUniqueInput | photos_albums_linkWhereUniqueInput[]
  }

  export type photos_albums_tags_linkUncheckedCreateNestedManyWithoutPhotos_albumsInput = {
    create?: XOR<photos_albums_tags_linkCreateWithoutPhotos_albumsInput, photos_albums_tags_linkUncheckedCreateWithoutPhotos_albumsInput> | photos_albums_tags_linkCreateWithoutPhotos_albumsInput[] | photos_albums_tags_linkUncheckedCreateWithoutPhotos_albumsInput[]
    connectOrCreate?: photos_albums_tags_linkCreateOrConnectWithoutPhotos_albumsInput | photos_albums_tags_linkCreateOrConnectWithoutPhotos_albumsInput[]
    createMany?: photos_albums_tags_linkCreateManyPhotos_albumsInputEnvelope
    connect?: photos_albums_tags_linkWhereUniqueInput | photos_albums_tags_linkWhereUniqueInput[]
  }

  export type photos_albums_linkUpdateManyWithoutPhotos_albumsNestedInput = {
    create?: XOR<photos_albums_linkCreateWithoutPhotos_albumsInput, photos_albums_linkUncheckedCreateWithoutPhotos_albumsInput> | photos_albums_linkCreateWithoutPhotos_albumsInput[] | photos_albums_linkUncheckedCreateWithoutPhotos_albumsInput[]
    connectOrCreate?: photos_albums_linkCreateOrConnectWithoutPhotos_albumsInput | photos_albums_linkCreateOrConnectWithoutPhotos_albumsInput[]
    upsert?: photos_albums_linkUpsertWithWhereUniqueWithoutPhotos_albumsInput | photos_albums_linkUpsertWithWhereUniqueWithoutPhotos_albumsInput[]
    createMany?: photos_albums_linkCreateManyPhotos_albumsInputEnvelope
    set?: photos_albums_linkWhereUniqueInput | photos_albums_linkWhereUniqueInput[]
    disconnect?: photos_albums_linkWhereUniqueInput | photos_albums_linkWhereUniqueInput[]
    delete?: photos_albums_linkWhereUniqueInput | photos_albums_linkWhereUniqueInput[]
    connect?: photos_albums_linkWhereUniqueInput | photos_albums_linkWhereUniqueInput[]
    update?: photos_albums_linkUpdateWithWhereUniqueWithoutPhotos_albumsInput | photos_albums_linkUpdateWithWhereUniqueWithoutPhotos_albumsInput[]
    updateMany?: photos_albums_linkUpdateManyWithWhereWithoutPhotos_albumsInput | photos_albums_linkUpdateManyWithWhereWithoutPhotos_albumsInput[]
    deleteMany?: photos_albums_linkScalarWhereInput | photos_albums_linkScalarWhereInput[]
  }

  export type photos_albums_tags_linkUpdateManyWithoutPhotos_albumsNestedInput = {
    create?: XOR<photos_albums_tags_linkCreateWithoutPhotos_albumsInput, photos_albums_tags_linkUncheckedCreateWithoutPhotos_albumsInput> | photos_albums_tags_linkCreateWithoutPhotos_albumsInput[] | photos_albums_tags_linkUncheckedCreateWithoutPhotos_albumsInput[]
    connectOrCreate?: photos_albums_tags_linkCreateOrConnectWithoutPhotos_albumsInput | photos_albums_tags_linkCreateOrConnectWithoutPhotos_albumsInput[]
    upsert?: photos_albums_tags_linkUpsertWithWhereUniqueWithoutPhotos_albumsInput | photos_albums_tags_linkUpsertWithWhereUniqueWithoutPhotos_albumsInput[]
    createMany?: photos_albums_tags_linkCreateManyPhotos_albumsInputEnvelope
    set?: photos_albums_tags_linkWhereUniqueInput | photos_albums_tags_linkWhereUniqueInput[]
    disconnect?: photos_albums_tags_linkWhereUniqueInput | photos_albums_tags_linkWhereUniqueInput[]
    delete?: photos_albums_tags_linkWhereUniqueInput | photos_albums_tags_linkWhereUniqueInput[]
    connect?: photos_albums_tags_linkWhereUniqueInput | photos_albums_tags_linkWhereUniqueInput[]
    update?: photos_albums_tags_linkUpdateWithWhereUniqueWithoutPhotos_albumsInput | photos_albums_tags_linkUpdateWithWhereUniqueWithoutPhotos_albumsInput[]
    updateMany?: photos_albums_tags_linkUpdateManyWithWhereWithoutPhotos_albumsInput | photos_albums_tags_linkUpdateManyWithWhereWithoutPhotos_albumsInput[]
    deleteMany?: photos_albums_tags_linkScalarWhereInput | photos_albums_tags_linkScalarWhereInput[]
  }

  export type photos_albums_linkUncheckedUpdateManyWithoutPhotos_albumsNestedInput = {
    create?: XOR<photos_albums_linkCreateWithoutPhotos_albumsInput, photos_albums_linkUncheckedCreateWithoutPhotos_albumsInput> | photos_albums_linkCreateWithoutPhotos_albumsInput[] | photos_albums_linkUncheckedCreateWithoutPhotos_albumsInput[]
    connectOrCreate?: photos_albums_linkCreateOrConnectWithoutPhotos_albumsInput | photos_albums_linkCreateOrConnectWithoutPhotos_albumsInput[]
    upsert?: photos_albums_linkUpsertWithWhereUniqueWithoutPhotos_albumsInput | photos_albums_linkUpsertWithWhereUniqueWithoutPhotos_albumsInput[]
    createMany?: photos_albums_linkCreateManyPhotos_albumsInputEnvelope
    set?: photos_albums_linkWhereUniqueInput | photos_albums_linkWhereUniqueInput[]
    disconnect?: photos_albums_linkWhereUniqueInput | photos_albums_linkWhereUniqueInput[]
    delete?: photos_albums_linkWhereUniqueInput | photos_albums_linkWhereUniqueInput[]
    connect?: photos_albums_linkWhereUniqueInput | photos_albums_linkWhereUniqueInput[]
    update?: photos_albums_linkUpdateWithWhereUniqueWithoutPhotos_albumsInput | photos_albums_linkUpdateWithWhereUniqueWithoutPhotos_albumsInput[]
    updateMany?: photos_albums_linkUpdateManyWithWhereWithoutPhotos_albumsInput | photos_albums_linkUpdateManyWithWhereWithoutPhotos_albumsInput[]
    deleteMany?: photos_albums_linkScalarWhereInput | photos_albums_linkScalarWhereInput[]
  }

  export type photos_albums_tags_linkUncheckedUpdateManyWithoutPhotos_albumsNestedInput = {
    create?: XOR<photos_albums_tags_linkCreateWithoutPhotos_albumsInput, photos_albums_tags_linkUncheckedCreateWithoutPhotos_albumsInput> | photos_albums_tags_linkCreateWithoutPhotos_albumsInput[] | photos_albums_tags_linkUncheckedCreateWithoutPhotos_albumsInput[]
    connectOrCreate?: photos_albums_tags_linkCreateOrConnectWithoutPhotos_albumsInput | photos_albums_tags_linkCreateOrConnectWithoutPhotos_albumsInput[]
    upsert?: photos_albums_tags_linkUpsertWithWhereUniqueWithoutPhotos_albumsInput | photos_albums_tags_linkUpsertWithWhereUniqueWithoutPhotos_albumsInput[]
    createMany?: photos_albums_tags_linkCreateManyPhotos_albumsInputEnvelope
    set?: photos_albums_tags_linkWhereUniqueInput | photos_albums_tags_linkWhereUniqueInput[]
    disconnect?: photos_albums_tags_linkWhereUniqueInput | photos_albums_tags_linkWhereUniqueInput[]
    delete?: photos_albums_tags_linkWhereUniqueInput | photos_albums_tags_linkWhereUniqueInput[]
    connect?: photos_albums_tags_linkWhereUniqueInput | photos_albums_tags_linkWhereUniqueInput[]
    update?: photos_albums_tags_linkUpdateWithWhereUniqueWithoutPhotos_albumsInput | photos_albums_tags_linkUpdateWithWhereUniqueWithoutPhotos_albumsInput[]
    updateMany?: photos_albums_tags_linkUpdateManyWithWhereWithoutPhotos_albumsInput | photos_albums_tags_linkUpdateManyWithWhereWithoutPhotos_albumsInput[]
    deleteMany?: photos_albums_tags_linkScalarWhereInput | photos_albums_tags_linkScalarWhereInput[]
  }

  export type photosCreateNestedOneWithoutPhotos_albums_linkInput = {
    create?: XOR<photosCreateWithoutPhotos_albums_linkInput, photosUncheckedCreateWithoutPhotos_albums_linkInput>
    connectOrCreate?: photosCreateOrConnectWithoutPhotos_albums_linkInput
    connect?: photosWhereUniqueInput
  }

  export type photos_albumsCreateNestedOneWithoutPhotos_albums_linkInput = {
    create?: XOR<photos_albumsCreateWithoutPhotos_albums_linkInput, photos_albumsUncheckedCreateWithoutPhotos_albums_linkInput>
    connectOrCreate?: photos_albumsCreateOrConnectWithoutPhotos_albums_linkInput
    connect?: photos_albumsWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type photosUpdateOneRequiredWithoutPhotos_albums_linkNestedInput = {
    create?: XOR<photosCreateWithoutPhotos_albums_linkInput, photosUncheckedCreateWithoutPhotos_albums_linkInput>
    connectOrCreate?: photosCreateOrConnectWithoutPhotos_albums_linkInput
    upsert?: photosUpsertWithoutPhotos_albums_linkInput
    connect?: photosWhereUniqueInput
    update?: XOR<XOR<photosUpdateToOneWithWhereWithoutPhotos_albums_linkInput, photosUpdateWithoutPhotos_albums_linkInput>, photosUncheckedUpdateWithoutPhotos_albums_linkInput>
  }

  export type photos_albumsUpdateOneRequiredWithoutPhotos_albums_linkNestedInput = {
    create?: XOR<photos_albumsCreateWithoutPhotos_albums_linkInput, photos_albumsUncheckedCreateWithoutPhotos_albums_linkInput>
    connectOrCreate?: photos_albumsCreateOrConnectWithoutPhotos_albums_linkInput
    upsert?: photos_albumsUpsertWithoutPhotos_albums_linkInput
    connect?: photos_albumsWhereUniqueInput
    update?: XOR<XOR<photos_albumsUpdateToOneWithWhereWithoutPhotos_albums_linkInput, photos_albumsUpdateWithoutPhotos_albums_linkInput>, photos_albumsUncheckedUpdateWithoutPhotos_albums_linkInput>
  }

  export type photos_albumsCreateNestedOneWithoutPhotos_albums_tags_linkInput = {
    create?: XOR<photos_albumsCreateWithoutPhotos_albums_tags_linkInput, photos_albumsUncheckedCreateWithoutPhotos_albums_tags_linkInput>
    connectOrCreate?: photos_albumsCreateOrConnectWithoutPhotos_albums_tags_linkInput
    connect?: photos_albumsWhereUniqueInput
  }

  export type photos_tagsCreateNestedOneWithoutPhotos_albums_tags_linkInput = {
    create?: XOR<photos_tagsCreateWithoutPhotos_albums_tags_linkInput, photos_tagsUncheckedCreateWithoutPhotos_albums_tags_linkInput>
    connectOrCreate?: photos_tagsCreateOrConnectWithoutPhotos_albums_tags_linkInput
    connect?: photos_tagsWhereUniqueInput
  }

  export type photos_albumsUpdateOneRequiredWithoutPhotos_albums_tags_linkNestedInput = {
    create?: XOR<photos_albumsCreateWithoutPhotos_albums_tags_linkInput, photos_albumsUncheckedCreateWithoutPhotos_albums_tags_linkInput>
    connectOrCreate?: photos_albumsCreateOrConnectWithoutPhotos_albums_tags_linkInput
    upsert?: photos_albumsUpsertWithoutPhotos_albums_tags_linkInput
    connect?: photos_albumsWhereUniqueInput
    update?: XOR<XOR<photos_albumsUpdateToOneWithWhereWithoutPhotos_albums_tags_linkInput, photos_albumsUpdateWithoutPhotos_albums_tags_linkInput>, photos_albumsUncheckedUpdateWithoutPhotos_albums_tags_linkInput>
  }

  export type photos_tagsUpdateOneRequiredWithoutPhotos_albums_tags_linkNestedInput = {
    create?: XOR<photos_tagsCreateWithoutPhotos_albums_tags_linkInput, photos_tagsUncheckedCreateWithoutPhotos_albums_tags_linkInput>
    connectOrCreate?: photos_tagsCreateOrConnectWithoutPhotos_albums_tags_linkInput
    upsert?: photos_tagsUpsertWithoutPhotos_albums_tags_linkInput
    connect?: photos_tagsWhereUniqueInput
    update?: XOR<XOR<photos_tagsUpdateToOneWithWhereWithoutPhotos_albums_tags_linkInput, photos_tagsUpdateWithoutPhotos_albums_tags_linkInput>, photos_tagsUncheckedUpdateWithoutPhotos_albums_tags_linkInput>
  }

  export type photos_albums_tags_linkCreateNestedManyWithoutPhotos_tagsInput = {
    create?: XOR<photos_albums_tags_linkCreateWithoutPhotos_tagsInput, photos_albums_tags_linkUncheckedCreateWithoutPhotos_tagsInput> | photos_albums_tags_linkCreateWithoutPhotos_tagsInput[] | photos_albums_tags_linkUncheckedCreateWithoutPhotos_tagsInput[]
    connectOrCreate?: photos_albums_tags_linkCreateOrConnectWithoutPhotos_tagsInput | photos_albums_tags_linkCreateOrConnectWithoutPhotos_tagsInput[]
    createMany?: photos_albums_tags_linkCreateManyPhotos_tagsInputEnvelope
    connect?: photos_albums_tags_linkWhereUniqueInput | photos_albums_tags_linkWhereUniqueInput[]
  }

  export type photos_tags_linkCreateNestedManyWithoutPhotos_tagsInput = {
    create?: XOR<photos_tags_linkCreateWithoutPhotos_tagsInput, photos_tags_linkUncheckedCreateWithoutPhotos_tagsInput> | photos_tags_linkCreateWithoutPhotos_tagsInput[] | photos_tags_linkUncheckedCreateWithoutPhotos_tagsInput[]
    connectOrCreate?: photos_tags_linkCreateOrConnectWithoutPhotos_tagsInput | photos_tags_linkCreateOrConnectWithoutPhotos_tagsInput[]
    createMany?: photos_tags_linkCreateManyPhotos_tagsInputEnvelope
    connect?: photos_tags_linkWhereUniqueInput | photos_tags_linkWhereUniqueInput[]
  }

  export type photos_albums_tags_linkUncheckedCreateNestedManyWithoutPhotos_tagsInput = {
    create?: XOR<photos_albums_tags_linkCreateWithoutPhotos_tagsInput, photos_albums_tags_linkUncheckedCreateWithoutPhotos_tagsInput> | photos_albums_tags_linkCreateWithoutPhotos_tagsInput[] | photos_albums_tags_linkUncheckedCreateWithoutPhotos_tagsInput[]
    connectOrCreate?: photos_albums_tags_linkCreateOrConnectWithoutPhotos_tagsInput | photos_albums_tags_linkCreateOrConnectWithoutPhotos_tagsInput[]
    createMany?: photos_albums_tags_linkCreateManyPhotos_tagsInputEnvelope
    connect?: photos_albums_tags_linkWhereUniqueInput | photos_albums_tags_linkWhereUniqueInput[]
  }

  export type photos_tags_linkUncheckedCreateNestedManyWithoutPhotos_tagsInput = {
    create?: XOR<photos_tags_linkCreateWithoutPhotos_tagsInput, photos_tags_linkUncheckedCreateWithoutPhotos_tagsInput> | photos_tags_linkCreateWithoutPhotos_tagsInput[] | photos_tags_linkUncheckedCreateWithoutPhotos_tagsInput[]
    connectOrCreate?: photos_tags_linkCreateOrConnectWithoutPhotos_tagsInput | photos_tags_linkCreateOrConnectWithoutPhotos_tagsInput[]
    createMany?: photos_tags_linkCreateManyPhotos_tagsInputEnvelope
    connect?: photos_tags_linkWhereUniqueInput | photos_tags_linkWhereUniqueInput[]
  }

  export type photos_albums_tags_linkUpdateManyWithoutPhotos_tagsNestedInput = {
    create?: XOR<photos_albums_tags_linkCreateWithoutPhotos_tagsInput, photos_albums_tags_linkUncheckedCreateWithoutPhotos_tagsInput> | photos_albums_tags_linkCreateWithoutPhotos_tagsInput[] | photos_albums_tags_linkUncheckedCreateWithoutPhotos_tagsInput[]
    connectOrCreate?: photos_albums_tags_linkCreateOrConnectWithoutPhotos_tagsInput | photos_albums_tags_linkCreateOrConnectWithoutPhotos_tagsInput[]
    upsert?: photos_albums_tags_linkUpsertWithWhereUniqueWithoutPhotos_tagsInput | photos_albums_tags_linkUpsertWithWhereUniqueWithoutPhotos_tagsInput[]
    createMany?: photos_albums_tags_linkCreateManyPhotos_tagsInputEnvelope
    set?: photos_albums_tags_linkWhereUniqueInput | photos_albums_tags_linkWhereUniqueInput[]
    disconnect?: photos_albums_tags_linkWhereUniqueInput | photos_albums_tags_linkWhereUniqueInput[]
    delete?: photos_albums_tags_linkWhereUniqueInput | photos_albums_tags_linkWhereUniqueInput[]
    connect?: photos_albums_tags_linkWhereUniqueInput | photos_albums_tags_linkWhereUniqueInput[]
    update?: photos_albums_tags_linkUpdateWithWhereUniqueWithoutPhotos_tagsInput | photos_albums_tags_linkUpdateWithWhereUniqueWithoutPhotos_tagsInput[]
    updateMany?: photos_albums_tags_linkUpdateManyWithWhereWithoutPhotos_tagsInput | photos_albums_tags_linkUpdateManyWithWhereWithoutPhotos_tagsInput[]
    deleteMany?: photos_albums_tags_linkScalarWhereInput | photos_albums_tags_linkScalarWhereInput[]
  }

  export type photos_tags_linkUpdateManyWithoutPhotos_tagsNestedInput = {
    create?: XOR<photos_tags_linkCreateWithoutPhotos_tagsInput, photos_tags_linkUncheckedCreateWithoutPhotos_tagsInput> | photos_tags_linkCreateWithoutPhotos_tagsInput[] | photos_tags_linkUncheckedCreateWithoutPhotos_tagsInput[]
    connectOrCreate?: photos_tags_linkCreateOrConnectWithoutPhotos_tagsInput | photos_tags_linkCreateOrConnectWithoutPhotos_tagsInput[]
    upsert?: photos_tags_linkUpsertWithWhereUniqueWithoutPhotos_tagsInput | photos_tags_linkUpsertWithWhereUniqueWithoutPhotos_tagsInput[]
    createMany?: photos_tags_linkCreateManyPhotos_tagsInputEnvelope
    set?: photos_tags_linkWhereUniqueInput | photos_tags_linkWhereUniqueInput[]
    disconnect?: photos_tags_linkWhereUniqueInput | photos_tags_linkWhereUniqueInput[]
    delete?: photos_tags_linkWhereUniqueInput | photos_tags_linkWhereUniqueInput[]
    connect?: photos_tags_linkWhereUniqueInput | photos_tags_linkWhereUniqueInput[]
    update?: photos_tags_linkUpdateWithWhereUniqueWithoutPhotos_tagsInput | photos_tags_linkUpdateWithWhereUniqueWithoutPhotos_tagsInput[]
    updateMany?: photos_tags_linkUpdateManyWithWhereWithoutPhotos_tagsInput | photos_tags_linkUpdateManyWithWhereWithoutPhotos_tagsInput[]
    deleteMany?: photos_tags_linkScalarWhereInput | photos_tags_linkScalarWhereInput[]
  }

  export type photos_albums_tags_linkUncheckedUpdateManyWithoutPhotos_tagsNestedInput = {
    create?: XOR<photos_albums_tags_linkCreateWithoutPhotos_tagsInput, photos_albums_tags_linkUncheckedCreateWithoutPhotos_tagsInput> | photos_albums_tags_linkCreateWithoutPhotos_tagsInput[] | photos_albums_tags_linkUncheckedCreateWithoutPhotos_tagsInput[]
    connectOrCreate?: photos_albums_tags_linkCreateOrConnectWithoutPhotos_tagsInput | photos_albums_tags_linkCreateOrConnectWithoutPhotos_tagsInput[]
    upsert?: photos_albums_tags_linkUpsertWithWhereUniqueWithoutPhotos_tagsInput | photos_albums_tags_linkUpsertWithWhereUniqueWithoutPhotos_tagsInput[]
    createMany?: photos_albums_tags_linkCreateManyPhotos_tagsInputEnvelope
    set?: photos_albums_tags_linkWhereUniqueInput | photos_albums_tags_linkWhereUniqueInput[]
    disconnect?: photos_albums_tags_linkWhereUniqueInput | photos_albums_tags_linkWhereUniqueInput[]
    delete?: photos_albums_tags_linkWhereUniqueInput | photos_albums_tags_linkWhereUniqueInput[]
    connect?: photos_albums_tags_linkWhereUniqueInput | photos_albums_tags_linkWhereUniqueInput[]
    update?: photos_albums_tags_linkUpdateWithWhereUniqueWithoutPhotos_tagsInput | photos_albums_tags_linkUpdateWithWhereUniqueWithoutPhotos_tagsInput[]
    updateMany?: photos_albums_tags_linkUpdateManyWithWhereWithoutPhotos_tagsInput | photos_albums_tags_linkUpdateManyWithWhereWithoutPhotos_tagsInput[]
    deleteMany?: photos_albums_tags_linkScalarWhereInput | photos_albums_tags_linkScalarWhereInput[]
  }

  export type photos_tags_linkUncheckedUpdateManyWithoutPhotos_tagsNestedInput = {
    create?: XOR<photos_tags_linkCreateWithoutPhotos_tagsInput, photos_tags_linkUncheckedCreateWithoutPhotos_tagsInput> | photos_tags_linkCreateWithoutPhotos_tagsInput[] | photos_tags_linkUncheckedCreateWithoutPhotos_tagsInput[]
    connectOrCreate?: photos_tags_linkCreateOrConnectWithoutPhotos_tagsInput | photos_tags_linkCreateOrConnectWithoutPhotos_tagsInput[]
    upsert?: photos_tags_linkUpsertWithWhereUniqueWithoutPhotos_tagsInput | photos_tags_linkUpsertWithWhereUniqueWithoutPhotos_tagsInput[]
    createMany?: photos_tags_linkCreateManyPhotos_tagsInputEnvelope
    set?: photos_tags_linkWhereUniqueInput | photos_tags_linkWhereUniqueInput[]
    disconnect?: photos_tags_linkWhereUniqueInput | photos_tags_linkWhereUniqueInput[]
    delete?: photos_tags_linkWhereUniqueInput | photos_tags_linkWhereUniqueInput[]
    connect?: photos_tags_linkWhereUniqueInput | photos_tags_linkWhereUniqueInput[]
    update?: photos_tags_linkUpdateWithWhereUniqueWithoutPhotos_tagsInput | photos_tags_linkUpdateWithWhereUniqueWithoutPhotos_tagsInput[]
    updateMany?: photos_tags_linkUpdateManyWithWhereWithoutPhotos_tagsInput | photos_tags_linkUpdateManyWithWhereWithoutPhotos_tagsInput[]
    deleteMany?: photos_tags_linkScalarWhereInput | photos_tags_linkScalarWhereInput[]
  }

  export type photosCreateNestedOneWithoutPhotos_tags_linkInput = {
    create?: XOR<photosCreateWithoutPhotos_tags_linkInput, photosUncheckedCreateWithoutPhotos_tags_linkInput>
    connectOrCreate?: photosCreateOrConnectWithoutPhotos_tags_linkInput
    connect?: photosWhereUniqueInput
  }

  export type photos_tagsCreateNestedOneWithoutPhotos_tags_linkInput = {
    create?: XOR<photos_tagsCreateWithoutPhotos_tags_linkInput, photos_tagsUncheckedCreateWithoutPhotos_tags_linkInput>
    connectOrCreate?: photos_tagsCreateOrConnectWithoutPhotos_tags_linkInput
    connect?: photos_tagsWhereUniqueInput
  }

  export type photosUpdateOneRequiredWithoutPhotos_tags_linkNestedInput = {
    create?: XOR<photosCreateWithoutPhotos_tags_linkInput, photosUncheckedCreateWithoutPhotos_tags_linkInput>
    connectOrCreate?: photosCreateOrConnectWithoutPhotos_tags_linkInput
    upsert?: photosUpsertWithoutPhotos_tags_linkInput
    connect?: photosWhereUniqueInput
    update?: XOR<XOR<photosUpdateToOneWithWhereWithoutPhotos_tags_linkInput, photosUpdateWithoutPhotos_tags_linkInput>, photosUncheckedUpdateWithoutPhotos_tags_linkInput>
  }

  export type photos_tagsUpdateOneRequiredWithoutPhotos_tags_linkNestedInput = {
    create?: XOR<photos_tagsCreateWithoutPhotos_tags_linkInput, photos_tagsUncheckedCreateWithoutPhotos_tags_linkInput>
    connectOrCreate?: photos_tagsCreateOrConnectWithoutPhotos_tags_linkInput
    upsert?: photos_tagsUpsertWithoutPhotos_tags_linkInput
    connect?: photos_tagsWhereUniqueInput
    update?: XOR<XOR<photos_tagsUpdateToOneWithWhereWithoutPhotos_tags_linkInput, photos_tagsUpdateWithoutPhotos_tags_linkInput>, photos_tagsUncheckedUpdateWithoutPhotos_tags_linkInput>
  }

  export type photos_tags_recherche_linkCreateNestedManyWithoutPhotos_tags_rechercheInput = {
    create?: XOR<photos_tags_recherche_linkCreateWithoutPhotos_tags_rechercheInput, photos_tags_recherche_linkUncheckedCreateWithoutPhotos_tags_rechercheInput> | photos_tags_recherche_linkCreateWithoutPhotos_tags_rechercheInput[] | photos_tags_recherche_linkUncheckedCreateWithoutPhotos_tags_rechercheInput[]
    connectOrCreate?: photos_tags_recherche_linkCreateOrConnectWithoutPhotos_tags_rechercheInput | photos_tags_recherche_linkCreateOrConnectWithoutPhotos_tags_rechercheInput[]
    createMany?: photos_tags_recherche_linkCreateManyPhotos_tags_rechercheInputEnvelope
    connect?: photos_tags_recherche_linkWhereUniqueInput | photos_tags_recherche_linkWhereUniqueInput[]
  }

  export type photos_tags_recherche_linkUncheckedCreateNestedManyWithoutPhotos_tags_rechercheInput = {
    create?: XOR<photos_tags_recherche_linkCreateWithoutPhotos_tags_rechercheInput, photos_tags_recherche_linkUncheckedCreateWithoutPhotos_tags_rechercheInput> | photos_tags_recherche_linkCreateWithoutPhotos_tags_rechercheInput[] | photos_tags_recherche_linkUncheckedCreateWithoutPhotos_tags_rechercheInput[]
    connectOrCreate?: photos_tags_recherche_linkCreateOrConnectWithoutPhotos_tags_rechercheInput | photos_tags_recherche_linkCreateOrConnectWithoutPhotos_tags_rechercheInput[]
    createMany?: photos_tags_recherche_linkCreateManyPhotos_tags_rechercheInputEnvelope
    connect?: photos_tags_recherche_linkWhereUniqueInput | photos_tags_recherche_linkWhereUniqueInput[]
  }

  export type photos_tags_recherche_linkUpdateManyWithoutPhotos_tags_rechercheNestedInput = {
    create?: XOR<photos_tags_recherche_linkCreateWithoutPhotos_tags_rechercheInput, photos_tags_recherche_linkUncheckedCreateWithoutPhotos_tags_rechercheInput> | photos_tags_recherche_linkCreateWithoutPhotos_tags_rechercheInput[] | photos_tags_recherche_linkUncheckedCreateWithoutPhotos_tags_rechercheInput[]
    connectOrCreate?: photos_tags_recherche_linkCreateOrConnectWithoutPhotos_tags_rechercheInput | photos_tags_recherche_linkCreateOrConnectWithoutPhotos_tags_rechercheInput[]
    upsert?: photos_tags_recherche_linkUpsertWithWhereUniqueWithoutPhotos_tags_rechercheInput | photos_tags_recherche_linkUpsertWithWhereUniqueWithoutPhotos_tags_rechercheInput[]
    createMany?: photos_tags_recherche_linkCreateManyPhotos_tags_rechercheInputEnvelope
    set?: photos_tags_recherche_linkWhereUniqueInput | photos_tags_recherche_linkWhereUniqueInput[]
    disconnect?: photos_tags_recherche_linkWhereUniqueInput | photos_tags_recherche_linkWhereUniqueInput[]
    delete?: photos_tags_recherche_linkWhereUniqueInput | photos_tags_recherche_linkWhereUniqueInput[]
    connect?: photos_tags_recherche_linkWhereUniqueInput | photos_tags_recherche_linkWhereUniqueInput[]
    update?: photos_tags_recherche_linkUpdateWithWhereUniqueWithoutPhotos_tags_rechercheInput | photos_tags_recherche_linkUpdateWithWhereUniqueWithoutPhotos_tags_rechercheInput[]
    updateMany?: photos_tags_recherche_linkUpdateManyWithWhereWithoutPhotos_tags_rechercheInput | photos_tags_recherche_linkUpdateManyWithWhereWithoutPhotos_tags_rechercheInput[]
    deleteMany?: photos_tags_recherche_linkScalarWhereInput | photos_tags_recherche_linkScalarWhereInput[]
  }

  export type photos_tags_recherche_linkUncheckedUpdateManyWithoutPhotos_tags_rechercheNestedInput = {
    create?: XOR<photos_tags_recherche_linkCreateWithoutPhotos_tags_rechercheInput, photos_tags_recherche_linkUncheckedCreateWithoutPhotos_tags_rechercheInput> | photos_tags_recherche_linkCreateWithoutPhotos_tags_rechercheInput[] | photos_tags_recherche_linkUncheckedCreateWithoutPhotos_tags_rechercheInput[]
    connectOrCreate?: photos_tags_recherche_linkCreateOrConnectWithoutPhotos_tags_rechercheInput | photos_tags_recherche_linkCreateOrConnectWithoutPhotos_tags_rechercheInput[]
    upsert?: photos_tags_recherche_linkUpsertWithWhereUniqueWithoutPhotos_tags_rechercheInput | photos_tags_recherche_linkUpsertWithWhereUniqueWithoutPhotos_tags_rechercheInput[]
    createMany?: photos_tags_recherche_linkCreateManyPhotos_tags_rechercheInputEnvelope
    set?: photos_tags_recherche_linkWhereUniqueInput | photos_tags_recherche_linkWhereUniqueInput[]
    disconnect?: photos_tags_recherche_linkWhereUniqueInput | photos_tags_recherche_linkWhereUniqueInput[]
    delete?: photos_tags_recherche_linkWhereUniqueInput | photos_tags_recherche_linkWhereUniqueInput[]
    connect?: photos_tags_recherche_linkWhereUniqueInput | photos_tags_recherche_linkWhereUniqueInput[]
    update?: photos_tags_recherche_linkUpdateWithWhereUniqueWithoutPhotos_tags_rechercheInput | photos_tags_recherche_linkUpdateWithWhereUniqueWithoutPhotos_tags_rechercheInput[]
    updateMany?: photos_tags_recherche_linkUpdateManyWithWhereWithoutPhotos_tags_rechercheInput | photos_tags_recherche_linkUpdateManyWithWhereWithoutPhotos_tags_rechercheInput[]
    deleteMany?: photos_tags_recherche_linkScalarWhereInput | photos_tags_recherche_linkScalarWhereInput[]
  }

  export type photosCreateNestedOneWithoutPhotos_tags_recherche_linkInput = {
    create?: XOR<photosCreateWithoutPhotos_tags_recherche_linkInput, photosUncheckedCreateWithoutPhotos_tags_recherche_linkInput>
    connectOrCreate?: photosCreateOrConnectWithoutPhotos_tags_recherche_linkInput
    connect?: photosWhereUniqueInput
  }

  export type photos_tags_rechercheCreateNestedOneWithoutPhotos_tags_recherche_linkInput = {
    create?: XOR<photos_tags_rechercheCreateWithoutPhotos_tags_recherche_linkInput, photos_tags_rechercheUncheckedCreateWithoutPhotos_tags_recherche_linkInput>
    connectOrCreate?: photos_tags_rechercheCreateOrConnectWithoutPhotos_tags_recherche_linkInput
    connect?: photos_tags_rechercheWhereUniqueInput
  }

  export type photosUpdateOneRequiredWithoutPhotos_tags_recherche_linkNestedInput = {
    create?: XOR<photosCreateWithoutPhotos_tags_recherche_linkInput, photosUncheckedCreateWithoutPhotos_tags_recherche_linkInput>
    connectOrCreate?: photosCreateOrConnectWithoutPhotos_tags_recherche_linkInput
    upsert?: photosUpsertWithoutPhotos_tags_recherche_linkInput
    connect?: photosWhereUniqueInput
    update?: XOR<XOR<photosUpdateToOneWithWhereWithoutPhotos_tags_recherche_linkInput, photosUpdateWithoutPhotos_tags_recherche_linkInput>, photosUncheckedUpdateWithoutPhotos_tags_recherche_linkInput>
  }

  export type photos_tags_rechercheUpdateOneRequiredWithoutPhotos_tags_recherche_linkNestedInput = {
    create?: XOR<photos_tags_rechercheCreateWithoutPhotos_tags_recherche_linkInput, photos_tags_rechercheUncheckedCreateWithoutPhotos_tags_recherche_linkInput>
    connectOrCreate?: photos_tags_rechercheCreateOrConnectWithoutPhotos_tags_recherche_linkInput
    upsert?: photos_tags_rechercheUpsertWithoutPhotos_tags_recherche_linkInput
    connect?: photos_tags_rechercheWhereUniqueInput
    update?: XOR<XOR<photos_tags_rechercheUpdateToOneWithWhereWithoutPhotos_tags_recherche_linkInput, photos_tags_rechercheUpdateWithoutPhotos_tags_recherche_linkInput>, photos_tags_rechercheUncheckedUpdateWithoutPhotos_tags_recherche_linkInput>
  }

  export type videos_tags_linkCreateNestedManyWithoutVideosInput = {
    create?: XOR<videos_tags_linkCreateWithoutVideosInput, videos_tags_linkUncheckedCreateWithoutVideosInput> | videos_tags_linkCreateWithoutVideosInput[] | videos_tags_linkUncheckedCreateWithoutVideosInput[]
    connectOrCreate?: videos_tags_linkCreateOrConnectWithoutVideosInput | videos_tags_linkCreateOrConnectWithoutVideosInput[]
    createMany?: videos_tags_linkCreateManyVideosInputEnvelope
    connect?: videos_tags_linkWhereUniqueInput | videos_tags_linkWhereUniqueInput[]
  }

  export type videos_tags_linkUncheckedCreateNestedManyWithoutVideosInput = {
    create?: XOR<videos_tags_linkCreateWithoutVideosInput, videos_tags_linkUncheckedCreateWithoutVideosInput> | videos_tags_linkCreateWithoutVideosInput[] | videos_tags_linkUncheckedCreateWithoutVideosInput[]
    connectOrCreate?: videos_tags_linkCreateOrConnectWithoutVideosInput | videos_tags_linkCreateOrConnectWithoutVideosInput[]
    createMany?: videos_tags_linkCreateManyVideosInputEnvelope
    connect?: videos_tags_linkWhereUniqueInput | videos_tags_linkWhereUniqueInput[]
  }

  export type videos_tags_linkUpdateManyWithoutVideosNestedInput = {
    create?: XOR<videos_tags_linkCreateWithoutVideosInput, videos_tags_linkUncheckedCreateWithoutVideosInput> | videos_tags_linkCreateWithoutVideosInput[] | videos_tags_linkUncheckedCreateWithoutVideosInput[]
    connectOrCreate?: videos_tags_linkCreateOrConnectWithoutVideosInput | videos_tags_linkCreateOrConnectWithoutVideosInput[]
    upsert?: videos_tags_linkUpsertWithWhereUniqueWithoutVideosInput | videos_tags_linkUpsertWithWhereUniqueWithoutVideosInput[]
    createMany?: videos_tags_linkCreateManyVideosInputEnvelope
    set?: videos_tags_linkWhereUniqueInput | videos_tags_linkWhereUniqueInput[]
    disconnect?: videos_tags_linkWhereUniqueInput | videos_tags_linkWhereUniqueInput[]
    delete?: videos_tags_linkWhereUniqueInput | videos_tags_linkWhereUniqueInput[]
    connect?: videos_tags_linkWhereUniqueInput | videos_tags_linkWhereUniqueInput[]
    update?: videos_tags_linkUpdateWithWhereUniqueWithoutVideosInput | videos_tags_linkUpdateWithWhereUniqueWithoutVideosInput[]
    updateMany?: videos_tags_linkUpdateManyWithWhereWithoutVideosInput | videos_tags_linkUpdateManyWithWhereWithoutVideosInput[]
    deleteMany?: videos_tags_linkScalarWhereInput | videos_tags_linkScalarWhereInput[]
  }

  export type videos_tags_linkUncheckedUpdateManyWithoutVideosNestedInput = {
    create?: XOR<videos_tags_linkCreateWithoutVideosInput, videos_tags_linkUncheckedCreateWithoutVideosInput> | videos_tags_linkCreateWithoutVideosInput[] | videos_tags_linkUncheckedCreateWithoutVideosInput[]
    connectOrCreate?: videos_tags_linkCreateOrConnectWithoutVideosInput | videos_tags_linkCreateOrConnectWithoutVideosInput[]
    upsert?: videos_tags_linkUpsertWithWhereUniqueWithoutVideosInput | videos_tags_linkUpsertWithWhereUniqueWithoutVideosInput[]
    createMany?: videos_tags_linkCreateManyVideosInputEnvelope
    set?: videos_tags_linkWhereUniqueInput | videos_tags_linkWhereUniqueInput[]
    disconnect?: videos_tags_linkWhereUniqueInput | videos_tags_linkWhereUniqueInput[]
    delete?: videos_tags_linkWhereUniqueInput | videos_tags_linkWhereUniqueInput[]
    connect?: videos_tags_linkWhereUniqueInput | videos_tags_linkWhereUniqueInput[]
    update?: videos_tags_linkUpdateWithWhereUniqueWithoutVideosInput | videos_tags_linkUpdateWithWhereUniqueWithoutVideosInput[]
    updateMany?: videos_tags_linkUpdateManyWithWhereWithoutVideosInput | videos_tags_linkUpdateManyWithWhereWithoutVideosInput[]
    deleteMany?: videos_tags_linkScalarWhereInput | videos_tags_linkScalarWhereInput[]
  }

  export type videos_tags_linkCreateNestedManyWithoutVideos_tagsInput = {
    create?: XOR<videos_tags_linkCreateWithoutVideos_tagsInput, videos_tags_linkUncheckedCreateWithoutVideos_tagsInput> | videos_tags_linkCreateWithoutVideos_tagsInput[] | videos_tags_linkUncheckedCreateWithoutVideos_tagsInput[]
    connectOrCreate?: videos_tags_linkCreateOrConnectWithoutVideos_tagsInput | videos_tags_linkCreateOrConnectWithoutVideos_tagsInput[]
    createMany?: videos_tags_linkCreateManyVideos_tagsInputEnvelope
    connect?: videos_tags_linkWhereUniqueInput | videos_tags_linkWhereUniqueInput[]
  }

  export type videos_tags_linkUncheckedCreateNestedManyWithoutVideos_tagsInput = {
    create?: XOR<videos_tags_linkCreateWithoutVideos_tagsInput, videos_tags_linkUncheckedCreateWithoutVideos_tagsInput> | videos_tags_linkCreateWithoutVideos_tagsInput[] | videos_tags_linkUncheckedCreateWithoutVideos_tagsInput[]
    connectOrCreate?: videos_tags_linkCreateOrConnectWithoutVideos_tagsInput | videos_tags_linkCreateOrConnectWithoutVideos_tagsInput[]
    createMany?: videos_tags_linkCreateManyVideos_tagsInputEnvelope
    connect?: videos_tags_linkWhereUniqueInput | videos_tags_linkWhereUniqueInput[]
  }

  export type videos_tags_linkUpdateManyWithoutVideos_tagsNestedInput = {
    create?: XOR<videos_tags_linkCreateWithoutVideos_tagsInput, videos_tags_linkUncheckedCreateWithoutVideos_tagsInput> | videos_tags_linkCreateWithoutVideos_tagsInput[] | videos_tags_linkUncheckedCreateWithoutVideos_tagsInput[]
    connectOrCreate?: videos_tags_linkCreateOrConnectWithoutVideos_tagsInput | videos_tags_linkCreateOrConnectWithoutVideos_tagsInput[]
    upsert?: videos_tags_linkUpsertWithWhereUniqueWithoutVideos_tagsInput | videos_tags_linkUpsertWithWhereUniqueWithoutVideos_tagsInput[]
    createMany?: videos_tags_linkCreateManyVideos_tagsInputEnvelope
    set?: videos_tags_linkWhereUniqueInput | videos_tags_linkWhereUniqueInput[]
    disconnect?: videos_tags_linkWhereUniqueInput | videos_tags_linkWhereUniqueInput[]
    delete?: videos_tags_linkWhereUniqueInput | videos_tags_linkWhereUniqueInput[]
    connect?: videos_tags_linkWhereUniqueInput | videos_tags_linkWhereUniqueInput[]
    update?: videos_tags_linkUpdateWithWhereUniqueWithoutVideos_tagsInput | videos_tags_linkUpdateWithWhereUniqueWithoutVideos_tagsInput[]
    updateMany?: videos_tags_linkUpdateManyWithWhereWithoutVideos_tagsInput | videos_tags_linkUpdateManyWithWhereWithoutVideos_tagsInput[]
    deleteMany?: videos_tags_linkScalarWhereInput | videos_tags_linkScalarWhereInput[]
  }

  export type videos_tags_linkUncheckedUpdateManyWithoutVideos_tagsNestedInput = {
    create?: XOR<videos_tags_linkCreateWithoutVideos_tagsInput, videos_tags_linkUncheckedCreateWithoutVideos_tagsInput> | videos_tags_linkCreateWithoutVideos_tagsInput[] | videos_tags_linkUncheckedCreateWithoutVideos_tagsInput[]
    connectOrCreate?: videos_tags_linkCreateOrConnectWithoutVideos_tagsInput | videos_tags_linkCreateOrConnectWithoutVideos_tagsInput[]
    upsert?: videos_tags_linkUpsertWithWhereUniqueWithoutVideos_tagsInput | videos_tags_linkUpsertWithWhereUniqueWithoutVideos_tagsInput[]
    createMany?: videos_tags_linkCreateManyVideos_tagsInputEnvelope
    set?: videos_tags_linkWhereUniqueInput | videos_tags_linkWhereUniqueInput[]
    disconnect?: videos_tags_linkWhereUniqueInput | videos_tags_linkWhereUniqueInput[]
    delete?: videos_tags_linkWhereUniqueInput | videos_tags_linkWhereUniqueInput[]
    connect?: videos_tags_linkWhereUniqueInput | videos_tags_linkWhereUniqueInput[]
    update?: videos_tags_linkUpdateWithWhereUniqueWithoutVideos_tagsInput | videos_tags_linkUpdateWithWhereUniqueWithoutVideos_tagsInput[]
    updateMany?: videos_tags_linkUpdateManyWithWhereWithoutVideos_tagsInput | videos_tags_linkUpdateManyWithWhereWithoutVideos_tagsInput[]
    deleteMany?: videos_tags_linkScalarWhereInput | videos_tags_linkScalarWhereInput[]
  }

  export type videosCreateNestedOneWithoutVideos_tags_linkInput = {
    create?: XOR<videosCreateWithoutVideos_tags_linkInput, videosUncheckedCreateWithoutVideos_tags_linkInput>
    connectOrCreate?: videosCreateOrConnectWithoutVideos_tags_linkInput
    connect?: videosWhereUniqueInput
  }

  export type videos_tagsCreateNestedOneWithoutVideos_tags_linkInput = {
    create?: XOR<videos_tagsCreateWithoutVideos_tags_linkInput, videos_tagsUncheckedCreateWithoutVideos_tags_linkInput>
    connectOrCreate?: videos_tagsCreateOrConnectWithoutVideos_tags_linkInput
    connect?: videos_tagsWhereUniqueInput
  }

  export type videosUpdateOneRequiredWithoutVideos_tags_linkNestedInput = {
    create?: XOR<videosCreateWithoutVideos_tags_linkInput, videosUncheckedCreateWithoutVideos_tags_linkInput>
    connectOrCreate?: videosCreateOrConnectWithoutVideos_tags_linkInput
    upsert?: videosUpsertWithoutVideos_tags_linkInput
    connect?: videosWhereUniqueInput
    update?: XOR<XOR<videosUpdateToOneWithWhereWithoutVideos_tags_linkInput, videosUpdateWithoutVideos_tags_linkInput>, videosUncheckedUpdateWithoutVideos_tags_linkInput>
  }

  export type videos_tagsUpdateOneRequiredWithoutVideos_tags_linkNestedInput = {
    create?: XOR<videos_tagsCreateWithoutVideos_tags_linkInput, videos_tagsUncheckedCreateWithoutVideos_tags_linkInput>
    connectOrCreate?: videos_tagsCreateOrConnectWithoutVideos_tags_linkInput
    upsert?: videos_tagsUpsertWithoutVideos_tags_linkInput
    connect?: videos_tagsWhereUniqueInput
    update?: XOR<XOR<videos_tagsUpdateToOneWithWhereWithoutVideos_tags_linkInput, videos_tagsUpdateWithoutVideos_tags_linkInput>, videos_tagsUncheckedUpdateWithoutVideos_tags_linkInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type photos_albums_linkCreateWithoutPhotosInput = {
    position?: number | null
    photos_albums: photos_albumsCreateNestedOneWithoutPhotos_albums_linkInput
  }

  export type photos_albums_linkUncheckedCreateWithoutPhotosInput = {
    id_alb: number
    position?: number | null
  }

  export type photos_albums_linkCreateOrConnectWithoutPhotosInput = {
    where: photos_albums_linkWhereUniqueInput
    create: XOR<photos_albums_linkCreateWithoutPhotosInput, photos_albums_linkUncheckedCreateWithoutPhotosInput>
  }

  export type photos_albums_linkCreateManyPhotosInputEnvelope = {
    data: photos_albums_linkCreateManyPhotosInput | photos_albums_linkCreateManyPhotosInput[]
    skipDuplicates?: boolean
  }

  export type photos_tags_linkCreateWithoutPhotosInput = {
    photos_tags: photos_tagsCreateNestedOneWithoutPhotos_tags_linkInput
  }

  export type photos_tags_linkUncheckedCreateWithoutPhotosInput = {
    id_tags: number
  }

  export type photos_tags_linkCreateOrConnectWithoutPhotosInput = {
    where: photos_tags_linkWhereUniqueInput
    create: XOR<photos_tags_linkCreateWithoutPhotosInput, photos_tags_linkUncheckedCreateWithoutPhotosInput>
  }

  export type photos_tags_linkCreateManyPhotosInputEnvelope = {
    data: photos_tags_linkCreateManyPhotosInput | photos_tags_linkCreateManyPhotosInput[]
    skipDuplicates?: boolean
  }

  export type photos_tags_recherche_linkCreateWithoutPhotosInput = {
    photos_tags_recherche: photos_tags_rechercheCreateNestedOneWithoutPhotos_tags_recherche_linkInput
  }

  export type photos_tags_recherche_linkUncheckedCreateWithoutPhotosInput = {
    id_tags: number
  }

  export type photos_tags_recherche_linkCreateOrConnectWithoutPhotosInput = {
    where: photos_tags_recherche_linkWhereUniqueInput
    create: XOR<photos_tags_recherche_linkCreateWithoutPhotosInput, photos_tags_recherche_linkUncheckedCreateWithoutPhotosInput>
  }

  export type photos_tags_recherche_linkCreateManyPhotosInputEnvelope = {
    data: photos_tags_recherche_linkCreateManyPhotosInput | photos_tags_recherche_linkCreateManyPhotosInput[]
    skipDuplicates?: boolean
  }

  export type photos_albums_linkUpsertWithWhereUniqueWithoutPhotosInput = {
    where: photos_albums_linkWhereUniqueInput
    update: XOR<photos_albums_linkUpdateWithoutPhotosInput, photos_albums_linkUncheckedUpdateWithoutPhotosInput>
    create: XOR<photos_albums_linkCreateWithoutPhotosInput, photos_albums_linkUncheckedCreateWithoutPhotosInput>
  }

  export type photos_albums_linkUpdateWithWhereUniqueWithoutPhotosInput = {
    where: photos_albums_linkWhereUniqueInput
    data: XOR<photos_albums_linkUpdateWithoutPhotosInput, photos_albums_linkUncheckedUpdateWithoutPhotosInput>
  }

  export type photos_albums_linkUpdateManyWithWhereWithoutPhotosInput = {
    where: photos_albums_linkScalarWhereInput
    data: XOR<photos_albums_linkUpdateManyMutationInput, photos_albums_linkUncheckedUpdateManyWithoutPhotosInput>
  }

  export type photos_albums_linkScalarWhereInput = {
    AND?: photos_albums_linkScalarWhereInput | photos_albums_linkScalarWhereInput[]
    OR?: photos_albums_linkScalarWhereInput[]
    NOT?: photos_albums_linkScalarWhereInput | photos_albums_linkScalarWhereInput[]
    id_pho?: IntFilter<"photos_albums_link"> | number
    id_alb?: IntFilter<"photos_albums_link"> | number
    position?: IntNullableFilter<"photos_albums_link"> | number | null
  }

  export type photos_tags_linkUpsertWithWhereUniqueWithoutPhotosInput = {
    where: photos_tags_linkWhereUniqueInput
    update: XOR<photos_tags_linkUpdateWithoutPhotosInput, photos_tags_linkUncheckedUpdateWithoutPhotosInput>
    create: XOR<photos_tags_linkCreateWithoutPhotosInput, photos_tags_linkUncheckedCreateWithoutPhotosInput>
  }

  export type photos_tags_linkUpdateWithWhereUniqueWithoutPhotosInput = {
    where: photos_tags_linkWhereUniqueInput
    data: XOR<photos_tags_linkUpdateWithoutPhotosInput, photos_tags_linkUncheckedUpdateWithoutPhotosInput>
  }

  export type photos_tags_linkUpdateManyWithWhereWithoutPhotosInput = {
    where: photos_tags_linkScalarWhereInput
    data: XOR<photos_tags_linkUpdateManyMutationInput, photos_tags_linkUncheckedUpdateManyWithoutPhotosInput>
  }

  export type photos_tags_linkScalarWhereInput = {
    AND?: photos_tags_linkScalarWhereInput | photos_tags_linkScalarWhereInput[]
    OR?: photos_tags_linkScalarWhereInput[]
    NOT?: photos_tags_linkScalarWhereInput | photos_tags_linkScalarWhereInput[]
    id_pho?: IntFilter<"photos_tags_link"> | number
    id_tags?: IntFilter<"photos_tags_link"> | number
  }

  export type photos_tags_recherche_linkUpsertWithWhereUniqueWithoutPhotosInput = {
    where: photos_tags_recherche_linkWhereUniqueInput
    update: XOR<photos_tags_recherche_linkUpdateWithoutPhotosInput, photos_tags_recherche_linkUncheckedUpdateWithoutPhotosInput>
    create: XOR<photos_tags_recherche_linkCreateWithoutPhotosInput, photos_tags_recherche_linkUncheckedCreateWithoutPhotosInput>
  }

  export type photos_tags_recherche_linkUpdateWithWhereUniqueWithoutPhotosInput = {
    where: photos_tags_recherche_linkWhereUniqueInput
    data: XOR<photos_tags_recherche_linkUpdateWithoutPhotosInput, photos_tags_recherche_linkUncheckedUpdateWithoutPhotosInput>
  }

  export type photos_tags_recherche_linkUpdateManyWithWhereWithoutPhotosInput = {
    where: photos_tags_recherche_linkScalarWhereInput
    data: XOR<photos_tags_recherche_linkUpdateManyMutationInput, photos_tags_recherche_linkUncheckedUpdateManyWithoutPhotosInput>
  }

  export type photos_tags_recherche_linkScalarWhereInput = {
    AND?: photos_tags_recherche_linkScalarWhereInput | photos_tags_recherche_linkScalarWhereInput[]
    OR?: photos_tags_recherche_linkScalarWhereInput[]
    NOT?: photos_tags_recherche_linkScalarWhereInput | photos_tags_recherche_linkScalarWhereInput[]
    id_pho?: IntFilter<"photos_tags_recherche_link"> | number
    id_tags?: IntFilter<"photos_tags_recherche_link"> | number
  }

  export type photos_albums_linkCreateWithoutPhotos_albumsInput = {
    position?: number | null
    photos: photosCreateNestedOneWithoutPhotos_albums_linkInput
  }

  export type photos_albums_linkUncheckedCreateWithoutPhotos_albumsInput = {
    id_pho: number
    position?: number | null
  }

  export type photos_albums_linkCreateOrConnectWithoutPhotos_albumsInput = {
    where: photos_albums_linkWhereUniqueInput
    create: XOR<photos_albums_linkCreateWithoutPhotos_albumsInput, photos_albums_linkUncheckedCreateWithoutPhotos_albumsInput>
  }

  export type photos_albums_linkCreateManyPhotos_albumsInputEnvelope = {
    data: photos_albums_linkCreateManyPhotos_albumsInput | photos_albums_linkCreateManyPhotos_albumsInput[]
    skipDuplicates?: boolean
  }

  export type photos_albums_tags_linkCreateWithoutPhotos_albumsInput = {
    photos_tags: photos_tagsCreateNestedOneWithoutPhotos_albums_tags_linkInput
  }

  export type photos_albums_tags_linkUncheckedCreateWithoutPhotos_albumsInput = {
    id_tags: number
  }

  export type photos_albums_tags_linkCreateOrConnectWithoutPhotos_albumsInput = {
    where: photos_albums_tags_linkWhereUniqueInput
    create: XOR<photos_albums_tags_linkCreateWithoutPhotos_albumsInput, photos_albums_tags_linkUncheckedCreateWithoutPhotos_albumsInput>
  }

  export type photos_albums_tags_linkCreateManyPhotos_albumsInputEnvelope = {
    data: photos_albums_tags_linkCreateManyPhotos_albumsInput | photos_albums_tags_linkCreateManyPhotos_albumsInput[]
    skipDuplicates?: boolean
  }

  export type photos_albums_linkUpsertWithWhereUniqueWithoutPhotos_albumsInput = {
    where: photos_albums_linkWhereUniqueInput
    update: XOR<photos_albums_linkUpdateWithoutPhotos_albumsInput, photos_albums_linkUncheckedUpdateWithoutPhotos_albumsInput>
    create: XOR<photos_albums_linkCreateWithoutPhotos_albumsInput, photos_albums_linkUncheckedCreateWithoutPhotos_albumsInput>
  }

  export type photos_albums_linkUpdateWithWhereUniqueWithoutPhotos_albumsInput = {
    where: photos_albums_linkWhereUniqueInput
    data: XOR<photos_albums_linkUpdateWithoutPhotos_albumsInput, photos_albums_linkUncheckedUpdateWithoutPhotos_albumsInput>
  }

  export type photos_albums_linkUpdateManyWithWhereWithoutPhotos_albumsInput = {
    where: photos_albums_linkScalarWhereInput
    data: XOR<photos_albums_linkUpdateManyMutationInput, photos_albums_linkUncheckedUpdateManyWithoutPhotos_albumsInput>
  }

  export type photos_albums_tags_linkUpsertWithWhereUniqueWithoutPhotos_albumsInput = {
    where: photos_albums_tags_linkWhereUniqueInput
    update: XOR<photos_albums_tags_linkUpdateWithoutPhotos_albumsInput, photos_albums_tags_linkUncheckedUpdateWithoutPhotos_albumsInput>
    create: XOR<photos_albums_tags_linkCreateWithoutPhotos_albumsInput, photos_albums_tags_linkUncheckedCreateWithoutPhotos_albumsInput>
  }

  export type photos_albums_tags_linkUpdateWithWhereUniqueWithoutPhotos_albumsInput = {
    where: photos_albums_tags_linkWhereUniqueInput
    data: XOR<photos_albums_tags_linkUpdateWithoutPhotos_albumsInput, photos_albums_tags_linkUncheckedUpdateWithoutPhotos_albumsInput>
  }

  export type photos_albums_tags_linkUpdateManyWithWhereWithoutPhotos_albumsInput = {
    where: photos_albums_tags_linkScalarWhereInput
    data: XOR<photos_albums_tags_linkUpdateManyMutationInput, photos_albums_tags_linkUncheckedUpdateManyWithoutPhotos_albumsInput>
  }

  export type photos_albums_tags_linkScalarWhereInput = {
    AND?: photos_albums_tags_linkScalarWhereInput | photos_albums_tags_linkScalarWhereInput[]
    OR?: photos_albums_tags_linkScalarWhereInput[]
    NOT?: photos_albums_tags_linkScalarWhereInput | photos_albums_tags_linkScalarWhereInput[]
    id_alb?: IntFilter<"photos_albums_tags_link"> | number
    id_tags?: IntFilter<"photos_albums_tags_link"> | number
  }

  export type photosCreateWithoutPhotos_albums_linkInput = {
    lien_high: string
    lien_low: string
    largeur: number
    hauteur: number
    alt: string
    date: Date | string
    afficher_carrousel_main?: boolean
    afficher_carrousel_photos?: boolean
    afficher: boolean
    derniere_modification: Date | string
    photos_tags_link?: photos_tags_linkCreateNestedManyWithoutPhotosInput
    photos_tags_recherche_link?: photos_tags_recherche_linkCreateNestedManyWithoutPhotosInput
  }

  export type photosUncheckedCreateWithoutPhotos_albums_linkInput = {
    id_pho?: number
    lien_high: string
    lien_low: string
    largeur: number
    hauteur: number
    alt: string
    date: Date | string
    afficher_carrousel_main?: boolean
    afficher_carrousel_photos?: boolean
    afficher: boolean
    derniere_modification: Date | string
    photos_tags_link?: photos_tags_linkUncheckedCreateNestedManyWithoutPhotosInput
    photos_tags_recherche_link?: photos_tags_recherche_linkUncheckedCreateNestedManyWithoutPhotosInput
  }

  export type photosCreateOrConnectWithoutPhotos_albums_linkInput = {
    where: photosWhereUniqueInput
    create: XOR<photosCreateWithoutPhotos_albums_linkInput, photosUncheckedCreateWithoutPhotos_albums_linkInput>
  }

  export type photos_albumsCreateWithoutPhotos_albums_linkInput = {
    titre: string
    lien_cover: string
    date: Date | string
    afficher: boolean
    derniere_modification: Date | string
    photos_albums_tags_link?: photos_albums_tags_linkCreateNestedManyWithoutPhotos_albumsInput
  }

  export type photos_albumsUncheckedCreateWithoutPhotos_albums_linkInput = {
    id_alb?: number
    titre: string
    lien_cover: string
    date: Date | string
    afficher: boolean
    derniere_modification: Date | string
    photos_albums_tags_link?: photos_albums_tags_linkUncheckedCreateNestedManyWithoutPhotos_albumsInput
  }

  export type photos_albumsCreateOrConnectWithoutPhotos_albums_linkInput = {
    where: photos_albumsWhereUniqueInput
    create: XOR<photos_albumsCreateWithoutPhotos_albums_linkInput, photos_albumsUncheckedCreateWithoutPhotos_albums_linkInput>
  }

  export type photosUpsertWithoutPhotos_albums_linkInput = {
    update: XOR<photosUpdateWithoutPhotos_albums_linkInput, photosUncheckedUpdateWithoutPhotos_albums_linkInput>
    create: XOR<photosCreateWithoutPhotos_albums_linkInput, photosUncheckedCreateWithoutPhotos_albums_linkInput>
    where?: photosWhereInput
  }

  export type photosUpdateToOneWithWhereWithoutPhotos_albums_linkInput = {
    where?: photosWhereInput
    data: XOR<photosUpdateWithoutPhotos_albums_linkInput, photosUncheckedUpdateWithoutPhotos_albums_linkInput>
  }

  export type photosUpdateWithoutPhotos_albums_linkInput = {
    lien_high?: StringFieldUpdateOperationsInput | string
    lien_low?: StringFieldUpdateOperationsInput | string
    largeur?: IntFieldUpdateOperationsInput | number
    hauteur?: IntFieldUpdateOperationsInput | number
    alt?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    afficher_carrousel_main?: BoolFieldUpdateOperationsInput | boolean
    afficher_carrousel_photos?: BoolFieldUpdateOperationsInput | boolean
    afficher?: BoolFieldUpdateOperationsInput | boolean
    derniere_modification?: DateTimeFieldUpdateOperationsInput | Date | string
    photos_tags_link?: photos_tags_linkUpdateManyWithoutPhotosNestedInput
    photos_tags_recherche_link?: photos_tags_recherche_linkUpdateManyWithoutPhotosNestedInput
  }

  export type photosUncheckedUpdateWithoutPhotos_albums_linkInput = {
    id_pho?: IntFieldUpdateOperationsInput | number
    lien_high?: StringFieldUpdateOperationsInput | string
    lien_low?: StringFieldUpdateOperationsInput | string
    largeur?: IntFieldUpdateOperationsInput | number
    hauteur?: IntFieldUpdateOperationsInput | number
    alt?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    afficher_carrousel_main?: BoolFieldUpdateOperationsInput | boolean
    afficher_carrousel_photos?: BoolFieldUpdateOperationsInput | boolean
    afficher?: BoolFieldUpdateOperationsInput | boolean
    derniere_modification?: DateTimeFieldUpdateOperationsInput | Date | string
    photos_tags_link?: photos_tags_linkUncheckedUpdateManyWithoutPhotosNestedInput
    photos_tags_recherche_link?: photos_tags_recherche_linkUncheckedUpdateManyWithoutPhotosNestedInput
  }

  export type photos_albumsUpsertWithoutPhotos_albums_linkInput = {
    update: XOR<photos_albumsUpdateWithoutPhotos_albums_linkInput, photos_albumsUncheckedUpdateWithoutPhotos_albums_linkInput>
    create: XOR<photos_albumsCreateWithoutPhotos_albums_linkInput, photos_albumsUncheckedCreateWithoutPhotos_albums_linkInput>
    where?: photos_albumsWhereInput
  }

  export type photos_albumsUpdateToOneWithWhereWithoutPhotos_albums_linkInput = {
    where?: photos_albumsWhereInput
    data: XOR<photos_albumsUpdateWithoutPhotos_albums_linkInput, photos_albumsUncheckedUpdateWithoutPhotos_albums_linkInput>
  }

  export type photos_albumsUpdateWithoutPhotos_albums_linkInput = {
    titre?: StringFieldUpdateOperationsInput | string
    lien_cover?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    afficher?: BoolFieldUpdateOperationsInput | boolean
    derniere_modification?: DateTimeFieldUpdateOperationsInput | Date | string
    photos_albums_tags_link?: photos_albums_tags_linkUpdateManyWithoutPhotos_albumsNestedInput
  }

  export type photos_albumsUncheckedUpdateWithoutPhotos_albums_linkInput = {
    id_alb?: IntFieldUpdateOperationsInput | number
    titre?: StringFieldUpdateOperationsInput | string
    lien_cover?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    afficher?: BoolFieldUpdateOperationsInput | boolean
    derniere_modification?: DateTimeFieldUpdateOperationsInput | Date | string
    photos_albums_tags_link?: photos_albums_tags_linkUncheckedUpdateManyWithoutPhotos_albumsNestedInput
  }

  export type photos_albumsCreateWithoutPhotos_albums_tags_linkInput = {
    titre: string
    lien_cover: string
    date: Date | string
    afficher: boolean
    derniere_modification: Date | string
    photos_albums_link?: photos_albums_linkCreateNestedManyWithoutPhotos_albumsInput
  }

  export type photos_albumsUncheckedCreateWithoutPhotos_albums_tags_linkInput = {
    id_alb?: number
    titre: string
    lien_cover: string
    date: Date | string
    afficher: boolean
    derniere_modification: Date | string
    photos_albums_link?: photos_albums_linkUncheckedCreateNestedManyWithoutPhotos_albumsInput
  }

  export type photos_albumsCreateOrConnectWithoutPhotos_albums_tags_linkInput = {
    where: photos_albumsWhereUniqueInput
    create: XOR<photos_albumsCreateWithoutPhotos_albums_tags_linkInput, photos_albumsUncheckedCreateWithoutPhotos_albums_tags_linkInput>
  }

  export type photos_tagsCreateWithoutPhotos_albums_tags_linkInput = {
    titre: string
    important: boolean
    photos_tags_link?: photos_tags_linkCreateNestedManyWithoutPhotos_tagsInput
  }

  export type photos_tagsUncheckedCreateWithoutPhotos_albums_tags_linkInput = {
    id_tags?: number
    titre: string
    important: boolean
    photos_tags_link?: photos_tags_linkUncheckedCreateNestedManyWithoutPhotos_tagsInput
  }

  export type photos_tagsCreateOrConnectWithoutPhotos_albums_tags_linkInput = {
    where: photos_tagsWhereUniqueInput
    create: XOR<photos_tagsCreateWithoutPhotos_albums_tags_linkInput, photos_tagsUncheckedCreateWithoutPhotos_albums_tags_linkInput>
  }

  export type photos_albumsUpsertWithoutPhotos_albums_tags_linkInput = {
    update: XOR<photos_albumsUpdateWithoutPhotos_albums_tags_linkInput, photos_albumsUncheckedUpdateWithoutPhotos_albums_tags_linkInput>
    create: XOR<photos_albumsCreateWithoutPhotos_albums_tags_linkInput, photos_albumsUncheckedCreateWithoutPhotos_albums_tags_linkInput>
    where?: photos_albumsWhereInput
  }

  export type photos_albumsUpdateToOneWithWhereWithoutPhotos_albums_tags_linkInput = {
    where?: photos_albumsWhereInput
    data: XOR<photos_albumsUpdateWithoutPhotos_albums_tags_linkInput, photos_albumsUncheckedUpdateWithoutPhotos_albums_tags_linkInput>
  }

  export type photos_albumsUpdateWithoutPhotos_albums_tags_linkInput = {
    titre?: StringFieldUpdateOperationsInput | string
    lien_cover?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    afficher?: BoolFieldUpdateOperationsInput | boolean
    derniere_modification?: DateTimeFieldUpdateOperationsInput | Date | string
    photos_albums_link?: photos_albums_linkUpdateManyWithoutPhotos_albumsNestedInput
  }

  export type photos_albumsUncheckedUpdateWithoutPhotos_albums_tags_linkInput = {
    id_alb?: IntFieldUpdateOperationsInput | number
    titre?: StringFieldUpdateOperationsInput | string
    lien_cover?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    afficher?: BoolFieldUpdateOperationsInput | boolean
    derniere_modification?: DateTimeFieldUpdateOperationsInput | Date | string
    photos_albums_link?: photos_albums_linkUncheckedUpdateManyWithoutPhotos_albumsNestedInput
  }

  export type photos_tagsUpsertWithoutPhotos_albums_tags_linkInput = {
    update: XOR<photos_tagsUpdateWithoutPhotos_albums_tags_linkInput, photos_tagsUncheckedUpdateWithoutPhotos_albums_tags_linkInput>
    create: XOR<photos_tagsCreateWithoutPhotos_albums_tags_linkInput, photos_tagsUncheckedCreateWithoutPhotos_albums_tags_linkInput>
    where?: photos_tagsWhereInput
  }

  export type photos_tagsUpdateToOneWithWhereWithoutPhotos_albums_tags_linkInput = {
    where?: photos_tagsWhereInput
    data: XOR<photos_tagsUpdateWithoutPhotos_albums_tags_linkInput, photos_tagsUncheckedUpdateWithoutPhotos_albums_tags_linkInput>
  }

  export type photos_tagsUpdateWithoutPhotos_albums_tags_linkInput = {
    titre?: StringFieldUpdateOperationsInput | string
    important?: BoolFieldUpdateOperationsInput | boolean
    photos_tags_link?: photos_tags_linkUpdateManyWithoutPhotos_tagsNestedInput
  }

  export type photos_tagsUncheckedUpdateWithoutPhotos_albums_tags_linkInput = {
    id_tags?: IntFieldUpdateOperationsInput | number
    titre?: StringFieldUpdateOperationsInput | string
    important?: BoolFieldUpdateOperationsInput | boolean
    photos_tags_link?: photos_tags_linkUncheckedUpdateManyWithoutPhotos_tagsNestedInput
  }

  export type photos_albums_tags_linkCreateWithoutPhotos_tagsInput = {
    photos_albums: photos_albumsCreateNestedOneWithoutPhotos_albums_tags_linkInput
  }

  export type photos_albums_tags_linkUncheckedCreateWithoutPhotos_tagsInput = {
    id_alb: number
  }

  export type photos_albums_tags_linkCreateOrConnectWithoutPhotos_tagsInput = {
    where: photos_albums_tags_linkWhereUniqueInput
    create: XOR<photos_albums_tags_linkCreateWithoutPhotos_tagsInput, photos_albums_tags_linkUncheckedCreateWithoutPhotos_tagsInput>
  }

  export type photos_albums_tags_linkCreateManyPhotos_tagsInputEnvelope = {
    data: photos_albums_tags_linkCreateManyPhotos_tagsInput | photos_albums_tags_linkCreateManyPhotos_tagsInput[]
    skipDuplicates?: boolean
  }

  export type photos_tags_linkCreateWithoutPhotos_tagsInput = {
    photos: photosCreateNestedOneWithoutPhotos_tags_linkInput
  }

  export type photos_tags_linkUncheckedCreateWithoutPhotos_tagsInput = {
    id_pho: number
  }

  export type photos_tags_linkCreateOrConnectWithoutPhotos_tagsInput = {
    where: photos_tags_linkWhereUniqueInput
    create: XOR<photos_tags_linkCreateWithoutPhotos_tagsInput, photos_tags_linkUncheckedCreateWithoutPhotos_tagsInput>
  }

  export type photos_tags_linkCreateManyPhotos_tagsInputEnvelope = {
    data: photos_tags_linkCreateManyPhotos_tagsInput | photos_tags_linkCreateManyPhotos_tagsInput[]
    skipDuplicates?: boolean
  }

  export type photos_albums_tags_linkUpsertWithWhereUniqueWithoutPhotos_tagsInput = {
    where: photos_albums_tags_linkWhereUniqueInput
    update: XOR<photos_albums_tags_linkUpdateWithoutPhotos_tagsInput, photos_albums_tags_linkUncheckedUpdateWithoutPhotos_tagsInput>
    create: XOR<photos_albums_tags_linkCreateWithoutPhotos_tagsInput, photos_albums_tags_linkUncheckedCreateWithoutPhotos_tagsInput>
  }

  export type photos_albums_tags_linkUpdateWithWhereUniqueWithoutPhotos_tagsInput = {
    where: photos_albums_tags_linkWhereUniqueInput
    data: XOR<photos_albums_tags_linkUpdateWithoutPhotos_tagsInput, photos_albums_tags_linkUncheckedUpdateWithoutPhotos_tagsInput>
  }

  export type photos_albums_tags_linkUpdateManyWithWhereWithoutPhotos_tagsInput = {
    where: photos_albums_tags_linkScalarWhereInput
    data: XOR<photos_albums_tags_linkUpdateManyMutationInput, photos_albums_tags_linkUncheckedUpdateManyWithoutPhotos_tagsInput>
  }

  export type photos_tags_linkUpsertWithWhereUniqueWithoutPhotos_tagsInput = {
    where: photos_tags_linkWhereUniqueInput
    update: XOR<photos_tags_linkUpdateWithoutPhotos_tagsInput, photos_tags_linkUncheckedUpdateWithoutPhotos_tagsInput>
    create: XOR<photos_tags_linkCreateWithoutPhotos_tagsInput, photos_tags_linkUncheckedCreateWithoutPhotos_tagsInput>
  }

  export type photos_tags_linkUpdateWithWhereUniqueWithoutPhotos_tagsInput = {
    where: photos_tags_linkWhereUniqueInput
    data: XOR<photos_tags_linkUpdateWithoutPhotos_tagsInput, photos_tags_linkUncheckedUpdateWithoutPhotos_tagsInput>
  }

  export type photos_tags_linkUpdateManyWithWhereWithoutPhotos_tagsInput = {
    where: photos_tags_linkScalarWhereInput
    data: XOR<photos_tags_linkUpdateManyMutationInput, photos_tags_linkUncheckedUpdateManyWithoutPhotos_tagsInput>
  }

  export type photosCreateWithoutPhotos_tags_linkInput = {
    lien_high: string
    lien_low: string
    largeur: number
    hauteur: number
    alt: string
    date: Date | string
    afficher_carrousel_main?: boolean
    afficher_carrousel_photos?: boolean
    afficher: boolean
    derniere_modification: Date | string
    photos_albums_link?: photos_albums_linkCreateNestedManyWithoutPhotosInput
    photos_tags_recherche_link?: photos_tags_recherche_linkCreateNestedManyWithoutPhotosInput
  }

  export type photosUncheckedCreateWithoutPhotos_tags_linkInput = {
    id_pho?: number
    lien_high: string
    lien_low: string
    largeur: number
    hauteur: number
    alt: string
    date: Date | string
    afficher_carrousel_main?: boolean
    afficher_carrousel_photos?: boolean
    afficher: boolean
    derniere_modification: Date | string
    photos_albums_link?: photos_albums_linkUncheckedCreateNestedManyWithoutPhotosInput
    photos_tags_recherche_link?: photos_tags_recherche_linkUncheckedCreateNestedManyWithoutPhotosInput
  }

  export type photosCreateOrConnectWithoutPhotos_tags_linkInput = {
    where: photosWhereUniqueInput
    create: XOR<photosCreateWithoutPhotos_tags_linkInput, photosUncheckedCreateWithoutPhotos_tags_linkInput>
  }

  export type photos_tagsCreateWithoutPhotos_tags_linkInput = {
    titre: string
    important: boolean
    photos_albums_tags_link?: photos_albums_tags_linkCreateNestedManyWithoutPhotos_tagsInput
  }

  export type photos_tagsUncheckedCreateWithoutPhotos_tags_linkInput = {
    id_tags?: number
    titre: string
    important: boolean
    photos_albums_tags_link?: photos_albums_tags_linkUncheckedCreateNestedManyWithoutPhotos_tagsInput
  }

  export type photos_tagsCreateOrConnectWithoutPhotos_tags_linkInput = {
    where: photos_tagsWhereUniqueInput
    create: XOR<photos_tagsCreateWithoutPhotos_tags_linkInput, photos_tagsUncheckedCreateWithoutPhotos_tags_linkInput>
  }

  export type photosUpsertWithoutPhotos_tags_linkInput = {
    update: XOR<photosUpdateWithoutPhotos_tags_linkInput, photosUncheckedUpdateWithoutPhotos_tags_linkInput>
    create: XOR<photosCreateWithoutPhotos_tags_linkInput, photosUncheckedCreateWithoutPhotos_tags_linkInput>
    where?: photosWhereInput
  }

  export type photosUpdateToOneWithWhereWithoutPhotos_tags_linkInput = {
    where?: photosWhereInput
    data: XOR<photosUpdateWithoutPhotos_tags_linkInput, photosUncheckedUpdateWithoutPhotos_tags_linkInput>
  }

  export type photosUpdateWithoutPhotos_tags_linkInput = {
    lien_high?: StringFieldUpdateOperationsInput | string
    lien_low?: StringFieldUpdateOperationsInput | string
    largeur?: IntFieldUpdateOperationsInput | number
    hauteur?: IntFieldUpdateOperationsInput | number
    alt?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    afficher_carrousel_main?: BoolFieldUpdateOperationsInput | boolean
    afficher_carrousel_photos?: BoolFieldUpdateOperationsInput | boolean
    afficher?: BoolFieldUpdateOperationsInput | boolean
    derniere_modification?: DateTimeFieldUpdateOperationsInput | Date | string
    photos_albums_link?: photos_albums_linkUpdateManyWithoutPhotosNestedInput
    photos_tags_recherche_link?: photos_tags_recherche_linkUpdateManyWithoutPhotosNestedInput
  }

  export type photosUncheckedUpdateWithoutPhotos_tags_linkInput = {
    id_pho?: IntFieldUpdateOperationsInput | number
    lien_high?: StringFieldUpdateOperationsInput | string
    lien_low?: StringFieldUpdateOperationsInput | string
    largeur?: IntFieldUpdateOperationsInput | number
    hauteur?: IntFieldUpdateOperationsInput | number
    alt?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    afficher_carrousel_main?: BoolFieldUpdateOperationsInput | boolean
    afficher_carrousel_photos?: BoolFieldUpdateOperationsInput | boolean
    afficher?: BoolFieldUpdateOperationsInput | boolean
    derniere_modification?: DateTimeFieldUpdateOperationsInput | Date | string
    photos_albums_link?: photos_albums_linkUncheckedUpdateManyWithoutPhotosNestedInput
    photos_tags_recherche_link?: photos_tags_recherche_linkUncheckedUpdateManyWithoutPhotosNestedInput
  }

  export type photos_tagsUpsertWithoutPhotos_tags_linkInput = {
    update: XOR<photos_tagsUpdateWithoutPhotos_tags_linkInput, photos_tagsUncheckedUpdateWithoutPhotos_tags_linkInput>
    create: XOR<photos_tagsCreateWithoutPhotos_tags_linkInput, photos_tagsUncheckedCreateWithoutPhotos_tags_linkInput>
    where?: photos_tagsWhereInput
  }

  export type photos_tagsUpdateToOneWithWhereWithoutPhotos_tags_linkInput = {
    where?: photos_tagsWhereInput
    data: XOR<photos_tagsUpdateWithoutPhotos_tags_linkInput, photos_tagsUncheckedUpdateWithoutPhotos_tags_linkInput>
  }

  export type photos_tagsUpdateWithoutPhotos_tags_linkInput = {
    titre?: StringFieldUpdateOperationsInput | string
    important?: BoolFieldUpdateOperationsInput | boolean
    photos_albums_tags_link?: photos_albums_tags_linkUpdateManyWithoutPhotos_tagsNestedInput
  }

  export type photos_tagsUncheckedUpdateWithoutPhotos_tags_linkInput = {
    id_tags?: IntFieldUpdateOperationsInput | number
    titre?: StringFieldUpdateOperationsInput | string
    important?: BoolFieldUpdateOperationsInput | boolean
    photos_albums_tags_link?: photos_albums_tags_linkUncheckedUpdateManyWithoutPhotos_tagsNestedInput
  }

  export type photos_tags_recherche_linkCreateWithoutPhotos_tags_rechercheInput = {
    photos: photosCreateNestedOneWithoutPhotos_tags_recherche_linkInput
  }

  export type photos_tags_recherche_linkUncheckedCreateWithoutPhotos_tags_rechercheInput = {
    id_pho: number
  }

  export type photos_tags_recherche_linkCreateOrConnectWithoutPhotos_tags_rechercheInput = {
    where: photos_tags_recherche_linkWhereUniqueInput
    create: XOR<photos_tags_recherche_linkCreateWithoutPhotos_tags_rechercheInput, photos_tags_recherche_linkUncheckedCreateWithoutPhotos_tags_rechercheInput>
  }

  export type photos_tags_recherche_linkCreateManyPhotos_tags_rechercheInputEnvelope = {
    data: photos_tags_recherche_linkCreateManyPhotos_tags_rechercheInput | photos_tags_recherche_linkCreateManyPhotos_tags_rechercheInput[]
    skipDuplicates?: boolean
  }

  export type photos_tags_recherche_linkUpsertWithWhereUniqueWithoutPhotos_tags_rechercheInput = {
    where: photos_tags_recherche_linkWhereUniqueInput
    update: XOR<photos_tags_recherche_linkUpdateWithoutPhotos_tags_rechercheInput, photos_tags_recherche_linkUncheckedUpdateWithoutPhotos_tags_rechercheInput>
    create: XOR<photos_tags_recherche_linkCreateWithoutPhotos_tags_rechercheInput, photos_tags_recherche_linkUncheckedCreateWithoutPhotos_tags_rechercheInput>
  }

  export type photos_tags_recherche_linkUpdateWithWhereUniqueWithoutPhotos_tags_rechercheInput = {
    where: photos_tags_recherche_linkWhereUniqueInput
    data: XOR<photos_tags_recherche_linkUpdateWithoutPhotos_tags_rechercheInput, photos_tags_recherche_linkUncheckedUpdateWithoutPhotos_tags_rechercheInput>
  }

  export type photos_tags_recherche_linkUpdateManyWithWhereWithoutPhotos_tags_rechercheInput = {
    where: photos_tags_recherche_linkScalarWhereInput
    data: XOR<photos_tags_recherche_linkUpdateManyMutationInput, photos_tags_recherche_linkUncheckedUpdateManyWithoutPhotos_tags_rechercheInput>
  }

  export type photosCreateWithoutPhotos_tags_recherche_linkInput = {
    lien_high: string
    lien_low: string
    largeur: number
    hauteur: number
    alt: string
    date: Date | string
    afficher_carrousel_main?: boolean
    afficher_carrousel_photos?: boolean
    afficher: boolean
    derniere_modification: Date | string
    photos_albums_link?: photos_albums_linkCreateNestedManyWithoutPhotosInput
    photos_tags_link?: photos_tags_linkCreateNestedManyWithoutPhotosInput
  }

  export type photosUncheckedCreateWithoutPhotos_tags_recherche_linkInput = {
    id_pho?: number
    lien_high: string
    lien_low: string
    largeur: number
    hauteur: number
    alt: string
    date: Date | string
    afficher_carrousel_main?: boolean
    afficher_carrousel_photos?: boolean
    afficher: boolean
    derniere_modification: Date | string
    photos_albums_link?: photos_albums_linkUncheckedCreateNestedManyWithoutPhotosInput
    photos_tags_link?: photos_tags_linkUncheckedCreateNestedManyWithoutPhotosInput
  }

  export type photosCreateOrConnectWithoutPhotos_tags_recherche_linkInput = {
    where: photosWhereUniqueInput
    create: XOR<photosCreateWithoutPhotos_tags_recherche_linkInput, photosUncheckedCreateWithoutPhotos_tags_recherche_linkInput>
  }

  export type photos_tags_rechercheCreateWithoutPhotos_tags_recherche_linkInput = {
    titre: string
    important: boolean
  }

  export type photos_tags_rechercheUncheckedCreateWithoutPhotos_tags_recherche_linkInput = {
    id_tags?: number
    titre: string
    important: boolean
  }

  export type photos_tags_rechercheCreateOrConnectWithoutPhotos_tags_recherche_linkInput = {
    where: photos_tags_rechercheWhereUniqueInput
    create: XOR<photos_tags_rechercheCreateWithoutPhotos_tags_recherche_linkInput, photos_tags_rechercheUncheckedCreateWithoutPhotos_tags_recherche_linkInput>
  }

  export type photosUpsertWithoutPhotos_tags_recherche_linkInput = {
    update: XOR<photosUpdateWithoutPhotos_tags_recherche_linkInput, photosUncheckedUpdateWithoutPhotos_tags_recherche_linkInput>
    create: XOR<photosCreateWithoutPhotos_tags_recherche_linkInput, photosUncheckedCreateWithoutPhotos_tags_recherche_linkInput>
    where?: photosWhereInput
  }

  export type photosUpdateToOneWithWhereWithoutPhotos_tags_recherche_linkInput = {
    where?: photosWhereInput
    data: XOR<photosUpdateWithoutPhotos_tags_recherche_linkInput, photosUncheckedUpdateWithoutPhotos_tags_recherche_linkInput>
  }

  export type photosUpdateWithoutPhotos_tags_recherche_linkInput = {
    lien_high?: StringFieldUpdateOperationsInput | string
    lien_low?: StringFieldUpdateOperationsInput | string
    largeur?: IntFieldUpdateOperationsInput | number
    hauteur?: IntFieldUpdateOperationsInput | number
    alt?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    afficher_carrousel_main?: BoolFieldUpdateOperationsInput | boolean
    afficher_carrousel_photos?: BoolFieldUpdateOperationsInput | boolean
    afficher?: BoolFieldUpdateOperationsInput | boolean
    derniere_modification?: DateTimeFieldUpdateOperationsInput | Date | string
    photos_albums_link?: photos_albums_linkUpdateManyWithoutPhotosNestedInput
    photos_tags_link?: photos_tags_linkUpdateManyWithoutPhotosNestedInput
  }

  export type photosUncheckedUpdateWithoutPhotos_tags_recherche_linkInput = {
    id_pho?: IntFieldUpdateOperationsInput | number
    lien_high?: StringFieldUpdateOperationsInput | string
    lien_low?: StringFieldUpdateOperationsInput | string
    largeur?: IntFieldUpdateOperationsInput | number
    hauteur?: IntFieldUpdateOperationsInput | number
    alt?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    afficher_carrousel_main?: BoolFieldUpdateOperationsInput | boolean
    afficher_carrousel_photos?: BoolFieldUpdateOperationsInput | boolean
    afficher?: BoolFieldUpdateOperationsInput | boolean
    derniere_modification?: DateTimeFieldUpdateOperationsInput | Date | string
    photos_albums_link?: photos_albums_linkUncheckedUpdateManyWithoutPhotosNestedInput
    photos_tags_link?: photos_tags_linkUncheckedUpdateManyWithoutPhotosNestedInput
  }

  export type photos_tags_rechercheUpsertWithoutPhotos_tags_recherche_linkInput = {
    update: XOR<photos_tags_rechercheUpdateWithoutPhotos_tags_recherche_linkInput, photos_tags_rechercheUncheckedUpdateWithoutPhotos_tags_recherche_linkInput>
    create: XOR<photos_tags_rechercheCreateWithoutPhotos_tags_recherche_linkInput, photos_tags_rechercheUncheckedCreateWithoutPhotos_tags_recherche_linkInput>
    where?: photos_tags_rechercheWhereInput
  }

  export type photos_tags_rechercheUpdateToOneWithWhereWithoutPhotos_tags_recherche_linkInput = {
    where?: photos_tags_rechercheWhereInput
    data: XOR<photos_tags_rechercheUpdateWithoutPhotos_tags_recherche_linkInput, photos_tags_rechercheUncheckedUpdateWithoutPhotos_tags_recherche_linkInput>
  }

  export type photos_tags_rechercheUpdateWithoutPhotos_tags_recherche_linkInput = {
    titre?: StringFieldUpdateOperationsInput | string
    important?: BoolFieldUpdateOperationsInput | boolean
  }

  export type photos_tags_rechercheUncheckedUpdateWithoutPhotos_tags_recherche_linkInput = {
    id_tags?: IntFieldUpdateOperationsInput | number
    titre?: StringFieldUpdateOperationsInput | string
    important?: BoolFieldUpdateOperationsInput | boolean
  }

  export type videos_tags_linkCreateWithoutVideosInput = {
    videos_tags: videos_tagsCreateNestedOneWithoutVideos_tags_linkInput
  }

  export type videos_tags_linkUncheckedCreateWithoutVideosInput = {
    id_tags: number
  }

  export type videos_tags_linkCreateOrConnectWithoutVideosInput = {
    where: videos_tags_linkWhereUniqueInput
    create: XOR<videos_tags_linkCreateWithoutVideosInput, videos_tags_linkUncheckedCreateWithoutVideosInput>
  }

  export type videos_tags_linkCreateManyVideosInputEnvelope = {
    data: videos_tags_linkCreateManyVideosInput | videos_tags_linkCreateManyVideosInput[]
    skipDuplicates?: boolean
  }

  export type videos_tags_linkUpsertWithWhereUniqueWithoutVideosInput = {
    where: videos_tags_linkWhereUniqueInput
    update: XOR<videos_tags_linkUpdateWithoutVideosInput, videos_tags_linkUncheckedUpdateWithoutVideosInput>
    create: XOR<videos_tags_linkCreateWithoutVideosInput, videos_tags_linkUncheckedCreateWithoutVideosInput>
  }

  export type videos_tags_linkUpdateWithWhereUniqueWithoutVideosInput = {
    where: videos_tags_linkWhereUniqueInput
    data: XOR<videos_tags_linkUpdateWithoutVideosInput, videos_tags_linkUncheckedUpdateWithoutVideosInput>
  }

  export type videos_tags_linkUpdateManyWithWhereWithoutVideosInput = {
    where: videos_tags_linkScalarWhereInput
    data: XOR<videos_tags_linkUpdateManyMutationInput, videos_tags_linkUncheckedUpdateManyWithoutVideosInput>
  }

  export type videos_tags_linkScalarWhereInput = {
    AND?: videos_tags_linkScalarWhereInput | videos_tags_linkScalarWhereInput[]
    OR?: videos_tags_linkScalarWhereInput[]
    NOT?: videos_tags_linkScalarWhereInput | videos_tags_linkScalarWhereInput[]
    id_vid?: IntFilter<"videos_tags_link"> | number
    id_tags?: IntFilter<"videos_tags_link"> | number
  }

  export type videos_tags_linkCreateWithoutVideos_tagsInput = {
    videos: videosCreateNestedOneWithoutVideos_tags_linkInput
  }

  export type videos_tags_linkUncheckedCreateWithoutVideos_tagsInput = {
    id_vid: number
  }

  export type videos_tags_linkCreateOrConnectWithoutVideos_tagsInput = {
    where: videos_tags_linkWhereUniqueInput
    create: XOR<videos_tags_linkCreateWithoutVideos_tagsInput, videos_tags_linkUncheckedCreateWithoutVideos_tagsInput>
  }

  export type videos_tags_linkCreateManyVideos_tagsInputEnvelope = {
    data: videos_tags_linkCreateManyVideos_tagsInput | videos_tags_linkCreateManyVideos_tagsInput[]
    skipDuplicates?: boolean
  }

  export type videos_tags_linkUpsertWithWhereUniqueWithoutVideos_tagsInput = {
    where: videos_tags_linkWhereUniqueInput
    update: XOR<videos_tags_linkUpdateWithoutVideos_tagsInput, videos_tags_linkUncheckedUpdateWithoutVideos_tagsInput>
    create: XOR<videos_tags_linkCreateWithoutVideos_tagsInput, videos_tags_linkUncheckedCreateWithoutVideos_tagsInput>
  }

  export type videos_tags_linkUpdateWithWhereUniqueWithoutVideos_tagsInput = {
    where: videos_tags_linkWhereUniqueInput
    data: XOR<videos_tags_linkUpdateWithoutVideos_tagsInput, videos_tags_linkUncheckedUpdateWithoutVideos_tagsInput>
  }

  export type videos_tags_linkUpdateManyWithWhereWithoutVideos_tagsInput = {
    where: videos_tags_linkScalarWhereInput
    data: XOR<videos_tags_linkUpdateManyMutationInput, videos_tags_linkUncheckedUpdateManyWithoutVideos_tagsInput>
  }

  export type videosCreateWithoutVideos_tags_linkInput = {
    titre: string
    lien: string
    date: Date | string
    afficher_carrousel_main?: boolean
    afficher_section_videos?: boolean
    tag_section_videos?: number | null
    afficher: boolean
    derniere_modification: Date | string
  }

  export type videosUncheckedCreateWithoutVideos_tags_linkInput = {
    id_vid?: number
    titre: string
    lien: string
    date: Date | string
    afficher_carrousel_main?: boolean
    afficher_section_videos?: boolean
    tag_section_videos?: number | null
    afficher: boolean
    derniere_modification: Date | string
  }

  export type videosCreateOrConnectWithoutVideos_tags_linkInput = {
    where: videosWhereUniqueInput
    create: XOR<videosCreateWithoutVideos_tags_linkInput, videosUncheckedCreateWithoutVideos_tags_linkInput>
  }

  export type videos_tagsCreateWithoutVideos_tags_linkInput = {
    titre: string
    important: boolean
  }

  export type videos_tagsUncheckedCreateWithoutVideos_tags_linkInput = {
    id_tags?: number
    titre: string
    important: boolean
  }

  export type videos_tagsCreateOrConnectWithoutVideos_tags_linkInput = {
    where: videos_tagsWhereUniqueInput
    create: XOR<videos_tagsCreateWithoutVideos_tags_linkInput, videos_tagsUncheckedCreateWithoutVideos_tags_linkInput>
  }

  export type videosUpsertWithoutVideos_tags_linkInput = {
    update: XOR<videosUpdateWithoutVideos_tags_linkInput, videosUncheckedUpdateWithoutVideos_tags_linkInput>
    create: XOR<videosCreateWithoutVideos_tags_linkInput, videosUncheckedCreateWithoutVideos_tags_linkInput>
    where?: videosWhereInput
  }

  export type videosUpdateToOneWithWhereWithoutVideos_tags_linkInput = {
    where?: videosWhereInput
    data: XOR<videosUpdateWithoutVideos_tags_linkInput, videosUncheckedUpdateWithoutVideos_tags_linkInput>
  }

  export type videosUpdateWithoutVideos_tags_linkInput = {
    titre?: StringFieldUpdateOperationsInput | string
    lien?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    afficher_carrousel_main?: BoolFieldUpdateOperationsInput | boolean
    afficher_section_videos?: BoolFieldUpdateOperationsInput | boolean
    tag_section_videos?: NullableIntFieldUpdateOperationsInput | number | null
    afficher?: BoolFieldUpdateOperationsInput | boolean
    derniere_modification?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type videosUncheckedUpdateWithoutVideos_tags_linkInput = {
    id_vid?: IntFieldUpdateOperationsInput | number
    titre?: StringFieldUpdateOperationsInput | string
    lien?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    afficher_carrousel_main?: BoolFieldUpdateOperationsInput | boolean
    afficher_section_videos?: BoolFieldUpdateOperationsInput | boolean
    tag_section_videos?: NullableIntFieldUpdateOperationsInput | number | null
    afficher?: BoolFieldUpdateOperationsInput | boolean
    derniere_modification?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type videos_tagsUpsertWithoutVideos_tags_linkInput = {
    update: XOR<videos_tagsUpdateWithoutVideos_tags_linkInput, videos_tagsUncheckedUpdateWithoutVideos_tags_linkInput>
    create: XOR<videos_tagsCreateWithoutVideos_tags_linkInput, videos_tagsUncheckedCreateWithoutVideos_tags_linkInput>
    where?: videos_tagsWhereInput
  }

  export type videos_tagsUpdateToOneWithWhereWithoutVideos_tags_linkInput = {
    where?: videos_tagsWhereInput
    data: XOR<videos_tagsUpdateWithoutVideos_tags_linkInput, videos_tagsUncheckedUpdateWithoutVideos_tags_linkInput>
  }

  export type videos_tagsUpdateWithoutVideos_tags_linkInput = {
    titre?: StringFieldUpdateOperationsInput | string
    important?: BoolFieldUpdateOperationsInput | boolean
  }

  export type videos_tagsUncheckedUpdateWithoutVideos_tags_linkInput = {
    id_tags?: IntFieldUpdateOperationsInput | number
    titre?: StringFieldUpdateOperationsInput | string
    important?: BoolFieldUpdateOperationsInput | boolean
  }

  export type photos_albums_linkCreateManyPhotosInput = {
    id_alb: number
    position?: number | null
  }

  export type photos_tags_linkCreateManyPhotosInput = {
    id_tags: number
  }

  export type photos_tags_recherche_linkCreateManyPhotosInput = {
    id_tags: number
  }

  export type photos_albums_linkUpdateWithoutPhotosInput = {
    position?: NullableIntFieldUpdateOperationsInput | number | null
    photos_albums?: photos_albumsUpdateOneRequiredWithoutPhotos_albums_linkNestedInput
  }

  export type photos_albums_linkUncheckedUpdateWithoutPhotosInput = {
    id_alb?: IntFieldUpdateOperationsInput | number
    position?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type photos_albums_linkUncheckedUpdateManyWithoutPhotosInput = {
    id_alb?: IntFieldUpdateOperationsInput | number
    position?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type photos_tags_linkUpdateWithoutPhotosInput = {
    photos_tags?: photos_tagsUpdateOneRequiredWithoutPhotos_tags_linkNestedInput
  }

  export type photos_tags_linkUncheckedUpdateWithoutPhotosInput = {
    id_tags?: IntFieldUpdateOperationsInput | number
  }

  export type photos_tags_linkUncheckedUpdateManyWithoutPhotosInput = {
    id_tags?: IntFieldUpdateOperationsInput | number
  }

  export type photos_tags_recherche_linkUpdateWithoutPhotosInput = {
    photos_tags_recherche?: photos_tags_rechercheUpdateOneRequiredWithoutPhotos_tags_recherche_linkNestedInput
  }

  export type photos_tags_recherche_linkUncheckedUpdateWithoutPhotosInput = {
    id_tags?: IntFieldUpdateOperationsInput | number
  }

  export type photos_tags_recherche_linkUncheckedUpdateManyWithoutPhotosInput = {
    id_tags?: IntFieldUpdateOperationsInput | number
  }

  export type photos_albums_linkCreateManyPhotos_albumsInput = {
    id_pho: number
    position?: number | null
  }

  export type photos_albums_tags_linkCreateManyPhotos_albumsInput = {
    id_tags: number
  }

  export type photos_albums_linkUpdateWithoutPhotos_albumsInput = {
    position?: NullableIntFieldUpdateOperationsInput | number | null
    photos?: photosUpdateOneRequiredWithoutPhotos_albums_linkNestedInput
  }

  export type photos_albums_linkUncheckedUpdateWithoutPhotos_albumsInput = {
    id_pho?: IntFieldUpdateOperationsInput | number
    position?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type photos_albums_linkUncheckedUpdateManyWithoutPhotos_albumsInput = {
    id_pho?: IntFieldUpdateOperationsInput | number
    position?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type photos_albums_tags_linkUpdateWithoutPhotos_albumsInput = {
    photos_tags?: photos_tagsUpdateOneRequiredWithoutPhotos_albums_tags_linkNestedInput
  }

  export type photos_albums_tags_linkUncheckedUpdateWithoutPhotos_albumsInput = {
    id_tags?: IntFieldUpdateOperationsInput | number
  }

  export type photos_albums_tags_linkUncheckedUpdateManyWithoutPhotos_albumsInput = {
    id_tags?: IntFieldUpdateOperationsInput | number
  }

  export type photos_albums_tags_linkCreateManyPhotos_tagsInput = {
    id_alb: number
  }

  export type photos_tags_linkCreateManyPhotos_tagsInput = {
    id_pho: number
  }

  export type photos_albums_tags_linkUpdateWithoutPhotos_tagsInput = {
    photos_albums?: photos_albumsUpdateOneRequiredWithoutPhotos_albums_tags_linkNestedInput
  }

  export type photos_albums_tags_linkUncheckedUpdateWithoutPhotos_tagsInput = {
    id_alb?: IntFieldUpdateOperationsInput | number
  }

  export type photos_albums_tags_linkUncheckedUpdateManyWithoutPhotos_tagsInput = {
    id_alb?: IntFieldUpdateOperationsInput | number
  }

  export type photos_tags_linkUpdateWithoutPhotos_tagsInput = {
    photos?: photosUpdateOneRequiredWithoutPhotos_tags_linkNestedInput
  }

  export type photos_tags_linkUncheckedUpdateWithoutPhotos_tagsInput = {
    id_pho?: IntFieldUpdateOperationsInput | number
  }

  export type photos_tags_linkUncheckedUpdateManyWithoutPhotos_tagsInput = {
    id_pho?: IntFieldUpdateOperationsInput | number
  }

  export type photos_tags_recherche_linkCreateManyPhotos_tags_rechercheInput = {
    id_pho: number
  }

  export type photos_tags_recherche_linkUpdateWithoutPhotos_tags_rechercheInput = {
    photos?: photosUpdateOneRequiredWithoutPhotos_tags_recherche_linkNestedInput
  }

  export type photos_tags_recherche_linkUncheckedUpdateWithoutPhotos_tags_rechercheInput = {
    id_pho?: IntFieldUpdateOperationsInput | number
  }

  export type photos_tags_recherche_linkUncheckedUpdateManyWithoutPhotos_tags_rechercheInput = {
    id_pho?: IntFieldUpdateOperationsInput | number
  }

  export type videos_tags_linkCreateManyVideosInput = {
    id_tags: number
  }

  export type videos_tags_linkUpdateWithoutVideosInput = {
    videos_tags?: videos_tagsUpdateOneRequiredWithoutVideos_tags_linkNestedInput
  }

  export type videos_tags_linkUncheckedUpdateWithoutVideosInput = {
    id_tags?: IntFieldUpdateOperationsInput | number
  }

  export type videos_tags_linkUncheckedUpdateManyWithoutVideosInput = {
    id_tags?: IntFieldUpdateOperationsInput | number
  }

  export type videos_tags_linkCreateManyVideos_tagsInput = {
    id_vid: number
  }

  export type videos_tags_linkUpdateWithoutVideos_tagsInput = {
    videos?: videosUpdateOneRequiredWithoutVideos_tags_linkNestedInput
  }

  export type videos_tags_linkUncheckedUpdateWithoutVideos_tagsInput = {
    id_vid?: IntFieldUpdateOperationsInput | number
  }

  export type videos_tags_linkUncheckedUpdateManyWithoutVideos_tagsInput = {
    id_vid?: IntFieldUpdateOperationsInput | number
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}